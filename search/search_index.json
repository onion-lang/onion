{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Onion Programming Language","text":"<p>Onion is a statically-typed, object-oriented programming language that compiles to JVM bytecode. It combines the power of static typing with a concise, expressive syntax and seamless Java interoperability.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Statically Typed - Catch errors at compile time with local type inference</li> <li>Object-Oriented - Classes, inheritance, interfaces, and method overloading</li> <li>Functional Elements - Lambda expressions, closures, and first-class functions</li> <li>Java Interoperability - Direct access to Java libraries and frameworks</li> <li>JVM Target - Compiles to efficient JVM bytecode</li> <li>Concise Syntax - Clean, readable code with minimal boilerplate</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>// Hello World\nIO::println(\"Hello, World!\")\n\n// Class definition with inheritance\nclass Calculator : JFrame &lt;: ActionListener {\n  var result: Long\n\n  public:\n    def this {\n      // Constructor logic\n      this.result = 0L;\n    }\n\n    def calculate(x: Long, y: Long): Long {\n      return x + y;\n    }\n}\n\n// Lambda expressions\nval filter: String -&gt; Boolean = (line: String) -&gt; {\n  return line.startsWith(\"ERROR\");\n}\n\n// Pattern matching with select\nval value = 3\nselect value {\n  case 0, 1, 2:\n    IO::println(\"Low\")\n  case 3, 4, 5:\n    IO::println(\"Medium\")\n  else:\n    IO::println(\"High\")\n}\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide - Set up Onion on your system</li> <li>Hello World Tutorial - Your first Onion program</li> <li>Quick Start - Essential language features</li> </ul>"},{"location":"#language-guide","title":"Language Guide","text":"<ul> <li>Overview - Language philosophy and design</li> <li>Basic Syntax - Variables, operators, and expressions</li> <li>Control Flow - if, while, for, foreach, and select</li> <li>Functions - Function definitions and lambda expressions</li> <li>Classes and Objects - Object-oriented programming</li> <li>Java Interoperability - Using Java libraries</li> </ul>"},{"location":"#tools","title":"Tools","text":"<ul> <li>onionc - Compile Onion source files to .class files</li> <li>onion - Run Onion scripts directly (compile and execute)</li> <li>Shell - Interactive REPL for experimentation</li> </ul>"},{"location":"#project-history","title":"Project History","text":"<p>Originally written in Java in 2005, Onion has been completely rewritten in Scala 3.6.2, with only the parser using JavaCC. The compiler follows a classic multi-phase architecture:</p> <ol> <li>Parsing - JavaCC-generated parser produces untyped AST</li> <li>Rewriting - AST normalization and transformation</li> <li>Type Checking - Type inference and validation</li> <li>Code Generation - ASM-based bytecode generation</li> </ol>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>Onion is open source software. See LICENSE for details.</p> <p>This software includes software developed by Apache Software Foundation.</p>"},{"location":"GENERICS_DESIGN/","title":"Generics (Erasure-Based) \u2013 Design &amp; TODO","text":"<p>Goal: Add basic generics with Scala-style erasure (upper bounds, generic classes/methods, bridge emission for overriding). Deliver in small PR-sized steps.</p>"},{"location":"GENERICS_DESIGN/#scope","title":"Scope","text":"<ul> <li>Type params on classes/methods with optional upper bounds using <code>extends</code> (e.g., <code>T extends Foo</code>). No variance for now. Syntax uses brackets <code>[]</code> for both definitions and applications: <code>class Box[T extends Foo]</code>, <code>def id[T extends Foo](x: T): T</code>.</li> <li>Type applications on types/expressions: <code>Box[Int]</code>, <code>foo[String](x)</code> (brackets only).</li> <li>Erasure: map type params to <code>Object</code> or bound\u2019s erasure in JVM signatures. Emit bridges when overriding causes erased signature collisions.</li> <li>Primitive type arguments: allowed (e.g., <code>ArrayList[Int]</code>); boxed/unboxed at erased JVM boundaries.</li> </ul> <p>Out of scope (for later): variance, wildcards, lower bounds, reified generics, generic fields with runtime type info, constraints beyond single upper bound.</p>"},{"location":"GENERICS_DESIGN/#incremental-plan","title":"Incremental Plan","text":""},{"location":"GENERICS_DESIGN/#1-grammar-ast","title":"1) Grammar &amp; AST","text":"<ul> <li>Extend grammar (JavaCC) to parse:</li> <li>Type parameter lists on classes/methods: <code>[T]</code> / <code>[T extends Bound]</code> (brackets unified with applications).</li> <li>Type applications on types and expressions: <code>Foo[Bar]</code>.</li> <li>AST changes (parser-level <code>AST</code>):</li> <li>Add <code>TypeParameter(name, upperBound: Option[TypeNode])</code>.</li> <li>Add <code>TypeApplication(target: TypeNode, args: List[TypeNode])</code>.</li> <li>Thread type params into <code>ClassDeclaration</code>, <code>MethodDeclaration</code>, <code>FunctionDeclaration</code>, <code>ClosureExpression</code> if applicable.</li> <li>Thread type args into <code>NewObject</code>, <code>StaticMethodCall</code>, <code>MethodCall</code>, <code>StaticMemberSelection</code> when present.</li> <li>Regenerate parser sources (JavaCC) after grammar updates.</li> </ul> <p>Checkpoint: Parser builds; AST nodes produced for simple examples like <code>class Box[T] { def get(x: T): T = x }</code> and <code>new Box[Int]()</code>.</p>"},{"location":"GENERICS_DESIGN/#2-typed-ast-typing","title":"2) Typed AST &amp; Typing","text":"<ul> <li>Typed model additions:</li> <li><code>TypedAST.TypeParameter(name, upperBound: IRT.Type)</code> and <code>TypeApplication</code> nodes.</li> <li>Include type params on <code>ClassDefinition</code>, <code>MethodDefinition</code>.</li> <li>Environment/bindings:</li> <li>Track type param scopes (class-level + method-level) with bounds.</li> <li>Validate type argument arity at use sites.</li> <li>Bound checking: substitute type args into bounds, ensure conformity (erased to bound when unknown).</li> <li>Erasure semantics in typing:</li> <li>Compute erased type for type params: <code>erasure(T) = erasure(bound)</code> else <code>Object</code>.</li> <li>Erase generic method/class types for codegen signatures.</li> <li>Type inference: supported for common generic method calls; explicit type arguments are still supported.</li> </ul> <p>Checkpoint: Typing accepts generic class/method definitions and applications, rejects arity/bound errors, produces TypedAST with erased info attached.</p>"},{"location":"GENERICS_DESIGN/#3-code-generation-asm","title":"3) Code Generation (ASM)","text":"<ul> <li>Signature computation: use erased types for descriptors.</li> <li>Bridge methods:</li> <li>When a subclass overrides a generic parent method where the erased signature would differ, emit a bridge that delegates to the typed implementation.</li> <li>Detect collisions during method table assembly (compare erased names+descs).</li> <li>Class/method naming: no mangling beyond erasure; rely on bridges for dispatch correctness.</li> </ul> <p>Checkpoint: Bytecode for generic hierarchies loads and runs; overridden generic methods dispatch correctly via bridges.</p>"},{"location":"GENERICS_DESIGN/#testing-plan","title":"Testing Plan","text":"<ul> <li>Parser round-trips: generic class/method definitions and instantiations.</li> <li>Typing: arity/bound errors; correct acceptance of <code>Box[Int]</code>, rejection of <code>Box[Int, String]</code>.</li> <li>Runtime: execute small programs with generic collections/identity methods; override scenarios that require bridges.</li> <li>Non-generic regressions: full existing test suite.</li> </ul>"},{"location":"GENERICS_DESIGN/#notes","title":"Notes","text":"<ul> <li>Keep resource strings (errors) consistent; add new keys for arity/bound errors.</li> <li>Maintain backward compatibility: existing non-generic code should compile unchanged.</li> <li>Consider feature flags if rollout needs to be staged; otherwise, ship as a single feature branch with checkpoints.</li> </ul>"},{"location":"parser-refactoring/","title":"Parser Refactoring: Separating Grammar from AST Building","text":""},{"location":"parser-refactoring/#overview","title":"Overview","text":"<p>This refactoring introduces the Builder pattern to separate parsing concerns from AST construction in the Onion compiler. This separation provides several benefits:</p> <ol> <li>Testability: AST construction can be tested independently of parsing</li> <li>Flexibility: Different AST builders can be used for different purposes</li> <li>Maintainability: Grammar changes don't require AST construction changes and vice versa</li> <li>Extensibility: New behaviors can be added without modifying the parser</li> </ol>"},{"location":"parser-refactoring/#architecture","title":"Architecture","text":""},{"location":"parser-refactoring/#before-refactoring","title":"Before Refactoring","text":"<p>The original parser (<code>JJOnionParser.jj</code>) directly constructs AST nodes within the grammar rules:</p> <pre><code>AST.ClassDeclaration class_decl(int mset) : {\n  // ... variable declarations ...\n}{\n  t1=\"class\" t2=&lt;ID&gt; /* ... parsing ... */ {\n    return new AST.ClassDeclaration(  // Direct AST construction\n      p(t1), mset, t2.image, ty1, toList(ty2s), sec3, toList(sec2s)\n    );\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#after-refactoring","title":"After Refactoring","text":"<p>The refactored parser uses an <code>ASTBuilder</code> interface:</p> <pre><code>AST.ClassDeclaration class_decl(int mset) : {\n  // ... variable declarations ...\n}{\n  t1=\"class\" t2=&lt;ID&gt; /* ... parsing ... */ {\n    return builder.createClassDeclaration(  // Delegated to builder\n      p(t1), mset, t2.image, ty1, toList(ty2s), sec3, toList(sec2s)\n    );\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#components","title":"Components","text":""},{"location":"parser-refactoring/#1-astbuilder-trait-astbuilderscala","title":"1. ASTBuilder Trait (<code>ASTBuilder.scala</code>)","text":"<p>Defines the interface for AST construction:</p> <pre><code>trait ASTBuilder {\n  def createCompilationUnit(...): AST.CompilationUnit\n  def createClassDeclaration(...): AST.ClassDeclaration\n  def createMethodDeclaration(...): AST.MethodDeclaration\n  // ... other AST node creation methods\n}\n</code></pre>"},{"location":"parser-refactoring/#2-defaultastbuilder-astbuilderscala","title":"2. DefaultASTBuilder (<code>ASTBuilder.scala</code>)","text":"<p>Provides the default implementation that simply constructs AST nodes:</p> <pre><code>class DefaultASTBuilder extends ASTBuilder {\n  def createClassDeclaration(...) = {\n    AST.ClassDeclaration(location, modifiers, name, ...)\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#3-astbuilderadapter-astbuilderadapterjava","title":"3. ASTBuilderAdapter (<code>ASTBuilderAdapter.java</code>)","text":"<p>Java adapter for seamless integration with JavaCC:</p> <pre><code>public class ASTBuilderAdapter {\n  private final ASTBuilder builder;\n\n  // Handles Java-Scala interop complexities\n  public AST.ClassDeclaration createClassDeclaration(...) {\n    return builder.createClassDeclaration(...);\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#4-jjonionparserrefactored-jjonionparserrefactoredjj","title":"4. JJOnionParserRefactored (<code>JJOnionParserRefactored.jj</code>)","text":"<p>Modified JavaCC grammar that uses the builder pattern instead of direct AST construction.</p>"},{"location":"parser-refactoring/#use-cases","title":"Use Cases","text":""},{"location":"parser-refactoring/#1-custom-analysis","title":"1. Custom Analysis","text":"<pre><code>class AnalyzingASTBuilder extends DefaultASTBuilder {\n  var methodCount = 0\n\n  override def createMethodDeclaration(...) = {\n    methodCount += 1\n    super.createMethodDeclaration(...)\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#2-validation","title":"2. Validation","text":"<pre><code>class ValidatingASTBuilder extends DefaultASTBuilder {\n  override def createMethodDeclaration(...) = {\n    if (args.length &gt; 10) {\n      throw new IllegalArgumentException(\"Too many parameters\")\n    }\n    super.createMethodDeclaration(...)\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#3-transformation","title":"3. Transformation","text":"<pre><code>class TransformingASTBuilder extends DefaultASTBuilder {\n  override def createMethodDeclaration(...) = {\n    val modifiedBody = addLogging(body)\n    super.createMethodDeclaration(..., modifiedBody)\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#4-debugging","title":"4. Debugging","text":"<pre><code>class LoggingASTBuilder extends DefaultASTBuilder {\n  override def createClassDeclaration(...) = {\n    println(s\"Creating class: $name at $location\")\n    super.createClassDeclaration(...)\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#migration-strategy","title":"Migration Strategy","text":"<ol> <li>Phase 1: Create builder infrastructure (completed)</li> <li>ASTBuilder trait</li> <li>DefaultASTBuilder implementation</li> <li> <p>ASTBuilderAdapter for Java interop</p> </li> <li> <p>Phase 2: Refactor parser gradually</p> </li> <li>Start with simple constructs (literals, identifiers)</li> <li>Move to complex constructs (classes, methods)</li> <li> <p>Maintain backward compatibility</p> </li> <li> <p>Phase 3: Update existing code</p> </li> <li>Modify Parsing.scala to use new parser</li> <li> <p>Update tests to use refactored components</p> </li> <li> <p>Phase 4: Leverage new capabilities</p> </li> <li>Add validation builders</li> <li>Implement transformation builders</li> <li>Create specialized builders for different compilation modes</li> </ol>"},{"location":"parser-refactoring/#benefits-realized","title":"Benefits Realized","text":"<ol> <li>Separation of Concerns: Grammar rules focus on syntax; builders focus on semantics</li> <li>Testability: AST construction logic can be unit tested without parsing</li> <li>Extensibility: New compilation features can be added via custom builders</li> <li>Maintainability: Changes to AST structure don't require grammar modifications</li> <li>Debugging: Logging/tracing can be added without touching the parser</li> </ol>"},{"location":"parser-refactoring/#future-enhancements","title":"Future Enhancements","text":"<ol> <li>Builder Composition: Chain multiple builders for complex transformations</li> <li>Context-Aware Building: Builders that maintain compilation context</li> <li>Error Recovery: Builders that can construct partial ASTs for better error messages</li> <li>Optimization: Builders that perform early optimizations during parsing</li> </ol>"},{"location":"stdlib-reference/","title":"Onion Standard Library Reference","text":"<p>This document describes the standard library classes available in Onion programs.</p>"},{"location":"stdlib-reference/#overview","title":"Overview","text":"Class Description <code>IO</code> Console input/output <code>Strings</code> String manipulation <code>Files</code> File operations <code>Json</code> JSON parsing and serialization <code>Http</code> HTTP client <code>DateTime</code> Date and time utilities <code>Regex</code> Regular expressions"},{"location":"stdlib-reference/#io","title":"IO","text":"<p>Console input/output utilities.</p>"},{"location":"stdlib-reference/#output","title":"Output","text":"<pre><code>IO::println(obj)        // Print with newline\nIO::print(obj)          // Print without newline\nIO::printf(format, args...)  // Formatted output\nIO::newline()           // Print empty line\nIO::clear()             // Clear screen (ANSI)\n</code></pre>"},{"location":"stdlib-reference/#error-output","title":"Error Output","text":"<pre><code>IO::eprintln(obj)       // Print to stderr with newline\nIO::eprint(obj)         // Print to stderr\nIO::eprintf(format, args...)  // Formatted stderr output\n</code></pre>"},{"location":"stdlib-reference/#input","title":"Input","text":"<pre><code>IO::readLine(): String       // Read line from stdin\nIO::readln(): String         // Alias for readLine\nIO::readln(prompt): String   // Read with prompt\nIO::input(prompt): String    // Read with prompt\nIO::readAll(): String        // Read entire stdin\n</code></pre>"},{"location":"stdlib-reference/#type-safe-input","title":"Type-Safe Input","text":"<pre><code>IO::readInt(): Int           // Read integer\nIO::readInt(prompt): Int     // Read integer with prompt\nIO::readLong(): Long\nIO::readDouble(): Double\nIO::readBoolean(): Boolean   // Accepts: true/false, yes/no, 1/0\n</code></pre>"},{"location":"stdlib-reference/#safe-input-returns-null-on-error","title":"Safe Input (returns null on error)","text":"<pre><code>IO::tryReadInt(prompt): Integer\nIO::tryReadDouble(prompt): Double\n</code></pre>"},{"location":"stdlib-reference/#example","title":"Example","text":"<pre><code>IO::println(\"Hello, World!\");\nval name: String = IO::readln(\"Enter name: \");\nval age: Int = IO::readInt(\"Enter age: \");\nIO::printf(\"Hello %s, you are %d years old%n\", name, age);\n</code></pre>"},{"location":"stdlib-reference/#strings","title":"Strings","text":"<p>String manipulation utilities.</p>"},{"location":"stdlib-reference/#split-and-join","title":"Split and Join","text":"<pre><code>Strings::split(str, delimiter): String[]\nStrings::splitRegex(str, regex): String[]\nStrings::join(parts, delimiter): String\n</code></pre>"},{"location":"stdlib-reference/#transformation","title":"Transformation","text":"<pre><code>Strings::trim(str): String\nStrings::upper(str): String\nStrings::lower(str): String\nStrings::replace(str, target, replacement): String\nStrings::replaceRegex(str, regex, replacement): String\nStrings::reverse(str): String\n</code></pre>"},{"location":"stdlib-reference/#inspection","title":"Inspection","text":"<pre><code>Strings::startsWith(str, prefix): Boolean\nStrings::endsWith(str, suffix): Boolean\nStrings::contains(str, substring): Boolean\nStrings::isEmpty(str): Boolean\nStrings::isBlank(str): Boolean\n</code></pre>"},{"location":"stdlib-reference/#extraction","title":"Extraction","text":"<pre><code>Strings::substring(str, start): String\nStrings::substring(str, start, end): String\nStrings::indexOf(str, substring): Int\nStrings::lastIndexOf(str, substring): Int\nStrings::lines(str): String[]\n</code></pre>"},{"location":"stdlib-reference/#padding-and-formatting","title":"Padding and Formatting","text":"<pre><code>Strings::padLeft(str, length, padChar): String\nStrings::padRight(str, length, padChar): String\nStrings::repeat(str, count): String\n</code></pre>"},{"location":"stdlib-reference/#example_1","title":"Example","text":"<pre><code>val words: String[] = Strings::split(\"a,b,c\", \",\");\nval upper: String = Strings::upper(\"hello\");  // \"HELLO\"\nval padded: String = Strings::padLeft(\"42\", 5, '0');  // \"00042\"\n</code></pre>"},{"location":"stdlib-reference/#files","title":"Files","text":"<p>File I/O utilities.</p>"},{"location":"stdlib-reference/#reading","title":"Reading","text":"<pre><code>Files::readText(path): String\nFiles::readText(path, charset): String\nFiles::readLines(path): String[]\nFiles::readBytes(path): Byte[]\n</code></pre>"},{"location":"stdlib-reference/#writing","title":"Writing","text":"<pre><code>Files::writeText(path, content): void\nFiles::writeText(path, content, charset): void\nFiles::writeLines(path, lines): void\nFiles::appendText(path, content): void\nFiles::writeBytes(path, data): void\n</code></pre>"},{"location":"stdlib-reference/#file-operations","title":"File Operations","text":"<pre><code>Files::exists(path): Boolean\nFiles::isFile(path): Boolean\nFiles::isDirectory(path): Boolean\nFiles::delete(path): Boolean\nFiles::mkdirs(path): Boolean\nFiles::listFiles(path): File[]\nFiles::size(path): Long\n</code></pre>"},{"location":"stdlib-reference/#path-operations","title":"Path Operations","text":"<pre><code>Files::joinPath(parts...): String\nFiles::getFileName(path): String\nFiles::getParent(path): String\nFiles::getAbsolutePath(path): String\n</code></pre>"},{"location":"stdlib-reference/#example_2","title":"Example","text":"<pre><code>val content: String = Files::readText(\"input.txt\");\nFiles::writeText(\"output.txt\", Strings::upper(content));\n\nif (Files::exists(\"data.json\")) {\n  val lines: String[] = Files::readLines(\"data.json\");\n  IO::println(\"Lines: \" + lines.length);\n}\n</code></pre>"},{"location":"stdlib-reference/#json","title":"Json","text":"<p>JSON parsing and serialization (no external dependencies).</p>"},{"location":"stdlib-reference/#parsing","title":"Parsing","text":"<pre><code>Json::parse(jsonString): Object           // Throws JsonParseException\nJson::parseOrNull(jsonString): Object     // Returns null on error\n</code></pre>"},{"location":"stdlib-reference/#serialization","title":"Serialization","text":"<pre><code>Json::stringify(obj): String              // Compact JSON\nJson::stringifyPretty(obj): String        // Pretty-printed JSON\n</code></pre>"},{"location":"stdlib-reference/#type-safe-accessors","title":"Type-Safe Accessors","text":"<pre><code>Json::asObject(value): Map                // Cast to object (or null)\nJson::asArray(value): List                // Cast to array (or null)\nJson::get(obj, key): Object               // Get value by key\nJson::getInt(obj, key): Int\nJson::getDouble(obj, key): Double\nJson::getBoolean(obj, key): Boolean\nJson::getString(obj, key): String\n</code></pre>"},{"location":"stdlib-reference/#example_3","title":"Example","text":"<pre><code>val json: String = \"{\\\"name\\\": \\\"Alice\\\", \\\"age\\\": 30}\";\nval data: Object = Json::parse(json);\nval name: String = Json::getString(data, \"name\");\nval age: Int = Json::getInt(data, \"age\");\n\nval output: String = Json::stringify(data);\n</code></pre>"},{"location":"stdlib-reference/#http","title":"Http","text":"<p>HTTP client utilities (uses Java 11+ HttpClient).</p>"},{"location":"stdlib-reference/#get-requests","title":"GET Requests","text":"<pre><code>Http::get(url): String\nHttp::get(url, headers): String    // headers: [\"Key1\", \"Value1\", ...]\n</code></pre>"},{"location":"stdlib-reference/#post-requests","title":"POST Requests","text":"<pre><code>Http::post(url, body): String\nHttp::postJson(url, jsonBody): String    // Sets Content-Type: application/json\nHttp::post(url, body, headers): String\n</code></pre>"},{"location":"stdlib-reference/#other-methods","title":"Other Methods","text":"<pre><code>Http::put(url, body): String\nHttp::delete(url): String\n</code></pre>"},{"location":"stdlib-reference/#url-utilities","title":"URL Utilities","text":"<pre><code>Http::urlEncode(str): String\nHttp::urlDecode(str): String\nHttp::buildQuery(params): String    // params: [\"key1\", \"val1\", ...]\n</code></pre>"},{"location":"stdlib-reference/#example_4","title":"Example","text":"<pre><code>val response: String = Http::get(\"https://api.example.com/data\");\nval data: Object = Json::parse(response);\n\nval postResponse: String = Http::postJson(\n  \"https://api.example.com/users\",\n  \"{\\\"name\\\": \\\"Bob\\\"}\"\n);\n</code></pre>"},{"location":"stdlib-reference/#datetime","title":"DateTime","text":"<p>Date and time utilities using epoch milliseconds.</p>"},{"location":"stdlib-reference/#current-time","title":"Current Time","text":"<pre><code>DateTime::now(): Long              // Current epoch milliseconds\nDateTime::nowString(): String      // ISO format (local timezone)\nDateTime::nowString(pattern): String\n</code></pre>"},{"location":"stdlib-reference/#parsing_1","title":"Parsing","text":"<pre><code>DateTime::parse(isoString): Long\nDateTime::parse(dateTime, pattern): Long\n</code></pre>"},{"location":"stdlib-reference/#formatting","title":"Formatting","text":"<pre><code>DateTime::format(epochMillis): String\nDateTime::format(epochMillis, pattern): String\n</code></pre>"},{"location":"stdlib-reference/#components","title":"Components","text":"<pre><code>DateTime::year(epochMillis): Int\nDateTime::month(epochMillis): Int       // 1-12\nDateTime::day(epochMillis): Int         // 1-31\nDateTime::hour(epochMillis): Int        // 0-23\nDateTime::minute(epochMillis): Int      // 0-59\nDateTime::second(epochMillis): Int      // 0-59\nDateTime::dayOfWeek(epochMillis): Int   // 1=Monday, 7=Sunday\nDateTime::dayOfYear(epochMillis): Int   // 1-366\n</code></pre>"},{"location":"stdlib-reference/#arithmetic","title":"Arithmetic","text":"<pre><code>DateTime::addDays(epochMillis, days): Long\nDateTime::addHours(epochMillis, hours): Long\nDateTime::addMinutes(epochMillis, minutes): Long\nDateTime::addSeconds(epochMillis, seconds): Long\nDateTime::addMonths(epochMillis, months): Long\nDateTime::addYears(epochMillis, years): Long\n</code></pre>"},{"location":"stdlib-reference/#comparison","title":"Comparison","text":"<pre><code>DateTime::diff(time1, time2): Long       // Difference in milliseconds\nDateTime::diffDays(time1, time2): Int\nDateTime::isBefore(time1, time2): Boolean\nDateTime::isAfter(time1, time2): Boolean\n</code></pre>"},{"location":"stdlib-reference/#factory","title":"Factory","text":"<pre><code>DateTime::of(year, month, day): Long\nDateTime::of(year, month, day, hour, minute, second): Long\nDateTime::startOfDay(epochMillis): Long\nDateTime::endOfDay(epochMillis): Long\n</code></pre>"},{"location":"stdlib-reference/#example_5","title":"Example","text":"<pre><code>val now: Long = DateTime::now();\nIO::println(\"Today: \" + DateTime::format(now, \"yyyy-MM-dd\"));\n\nval tomorrow: Long = DateTime::addDays(now, 1);\nIO::println(\"Tomorrow: \" + DateTime::format(tomorrow));\n\nval birthday: Long = DateTime::of(1990, 5, 15);\nval age: Int = DateTime::diffDays(now, birthday) / 365;\n</code></pre>"},{"location":"stdlib-reference/#regex","title":"Regex","text":"<p>Regular expression utilities.</p>"},{"location":"stdlib-reference/#matching","title":"Matching","text":"<pre><code>Regex::matches(input, pattern): Boolean   // Entire string matches\nRegex::find(input, pattern): Boolean      // Pattern found anywhere\n</code></pre>"},{"location":"stdlib-reference/#extraction_1","title":"Extraction","text":"<pre><code>Regex::findAll(input, pattern): String[]\nRegex::findFirst(input, pattern): String\nRegex::groups(input, pattern): String[]       // First match groups\nRegex::groupsAll(input, pattern): String[][]  // All matches groups\n</code></pre>"},{"location":"stdlib-reference/#replacement","title":"Replacement","text":"<pre><code>Regex::replace(input, pattern, replacement): String\nRegex::replaceFirst(input, pattern, replacement): String\n</code></pre>"},{"location":"stdlib-reference/#splitting","title":"Splitting","text":"<pre><code>Regex::split(input, pattern): String[]\nRegex::split(input, pattern, limit): String[]\n</code></pre>"},{"location":"stdlib-reference/#utility","title":"Utility","text":"<pre><code>Regex::quote(literal): String    // Escape special characters\nRegex::isValid(pattern): Boolean\n</code></pre>"},{"location":"stdlib-reference/#example_6","title":"Example","text":"<pre><code>val text: String = \"Email: alice@example.com, bob@test.org\";\nval emails: String[] = Regex::findAll(text, \"[\\\\w.]+@[\\\\w.]+\");\n// [\"alice@example.com\", \"bob@test.org\"]\n\nval masked: String = Regex::replace(text, \"@[\\\\w.]+\", \"@***\");\n// \"Email: alice@***, bob@***\"\n\nif (Regex::matches(\"hello123\", \"[a-z]+\\\\d+\")) {\n  IO::println(\"Pattern matched!\");\n}\n</code></pre>"},{"location":"stdlib-reference/#function-interfaces","title":"Function Interfaces","text":"<p>Onion provides function interfaces for closures (Function0 through Function10).</p> <pre><code>interface Function0[R] { def apply(): R }\ninterface Function1[T, R] { def apply(arg: T): R }\ninterface Function2[T1, T2, R] { def apply(arg1: T1, arg2: T2): R }\n// ... up to Function10\n</code></pre>"},{"location":"stdlib-reference/#example_7","title":"Example","text":"<pre><code>val add: Function2[Int, Int, Int] = (a: Int, b: Int) -&gt; { return a + b; };\nval result: Int = add.apply(3, 4);  // 7\n</code></pre>"},{"location":"stdlib-reference/#notes","title":"Notes","text":"<ul> <li>All utility classes use static methods accessible via <code>ClassName::methodName</code></li> <li>Methods handle null inputs gracefully (returning empty strings/arrays or false)</li> <li>File operations may throw <code>IOException</code></li> <li>HTTP operations may throw <code>Exception</code></li> <li>JSON parsing may throw <code>JsonParseException</code> (use <code>parseOrNull</code> for safe parsing)</li> </ul>"},{"location":"contributing/building/","title":"Building from Source","text":"<p>Complete guide to building the Onion compiler from source.</p>"},{"location":"contributing/building/#prerequisites","title":"Prerequisites","text":""},{"location":"contributing/building/#required-software","title":"Required Software","text":"<ol> <li>Java Development Kit (JDK) 17 or later</li> </ol> <p>Check version:    <pre><code>java -version\njavac -version\n</code></pre></p> <p>Install:    - macOS: <code>brew install openjdk@17</code>    - Ubuntu/Debian: <code>sudo apt install openjdk-17-jdk</code>    - Windows: Download from Adoptium</p> <ol> <li>SBT (Scala Build Tool)</li> </ol> <p>Check version:    <pre><code>sbt version\n</code></pre></p> <p>Install:    - macOS: <code>brew install sbt</code>    - Ubuntu/Debian: Follow official guide    - Windows: Download MSI installer</p> <ol> <li>Git</li> </ol> <pre><code>git --version\n</code></pre>"},{"location":"contributing/building/#cloning-the-repository","title":"Cloning the Repository","text":"<pre><code>git clone https://github.com/onion-lang/onion.git\ncd onion\n</code></pre>"},{"location":"contributing/building/#building","title":"Building","text":""},{"location":"contributing/building/#basic-compilation","title":"Basic Compilation","text":"<p>Compile the entire project:</p> <pre><code>sbt compile\n</code></pre> <p>This will: 1. Download dependencies (first time only) 2. Generate parser from JavaCC grammar 3. Compile Scala and Java source files</p> <p>Expected output: <pre><code>[info] compiling 70 Scala sources and 15 Java sources to target/scala-3.6.2/classes ...\n[success] Total time: 45 s\n</code></pre></p>"},{"location":"contributing/building/#clean-build","title":"Clean Build","text":"<p>Remove all generated files and rebuild:</p> <pre><code>sbt clean compile\n</code></pre>"},{"location":"contributing/building/#incremental-compilation","title":"Incremental Compilation","text":"<p>SBT automatically performs incremental compilation. Only changed files are recompiled:</p> <pre><code># Edit a file\nvim src/main/scala/onion/compiler/Typing.scala\n\n# Fast recompilation\nsbt compile\n</code></pre>"},{"location":"contributing/building/#testing","title":"Testing","text":""},{"location":"contributing/building/#run-all-tests","title":"Run All Tests","text":"<pre><code>sbt test\n</code></pre>"},{"location":"contributing/building/#run-specific-test-suite","title":"Run Specific Test Suite","text":"<pre><code>sbt 'testOnly *HelloWorldSpec'\nsbt 'testOnly *FactorialSpec'\n</code></pre>"},{"location":"contributing/building/#run-tests-matching-pattern","title":"Run Tests Matching Pattern","text":"<pre><code>sbt 'testOnly *String*'\n</code></pre>"},{"location":"contributing/building/#creating-distributions","title":"Creating Distributions","text":""},{"location":"contributing/building/#standalone-jar","title":"Standalone JAR","text":"<p>Create a fat JAR with all dependencies:</p> <pre><code>sbt assembly\n</code></pre> <p>Output: <code>target/scala-3.6.2/onion.jar</code></p> <p>Run it: <pre><code>java -jar target/scala-3.6.2/onion.jar Hello.on\n</code></pre></p>"},{"location":"contributing/building/#distribution-package","title":"Distribution Package","text":"<p>Create a complete distribution ZIP:</p> <pre><code>sbt dist\n</code></pre> <p>Output: <code>target/onion-dist.zip</code></p> <p>Contents: <pre><code>onion-dist/\n\u251c\u2500\u2500 onion.jar          # Main compiler JAR\n\u251c\u2500\u2500 lib/               # Dependencies\n\u2502   \u251c\u2500\u2500 asm-9.8.jar\n\u2502   \u251c\u2500\u2500 scala-library-3.6.2.jar\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 bin/               # Executables\n\u2502   \u251c\u2500\u2500 onionc\n\u2502   \u2514\u2500\u2500 onion\n\u251c\u2500\u2500 run/               # Example programs\n\u2502   \u251c\u2500\u2500 Hello.on\n\u2502   \u251c\u2500\u2500 Array.on\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 README.md\n</code></pre></p> <p>Extract and use: <pre><code>unzip target/onion-dist.zip\ncd onion-dist\nexport PATH=$PATH:$PWD/bin\nonionc run/Hello.on\n</code></pre></p>"},{"location":"contributing/building/#development-build","title":"Development Build","text":""},{"location":"contributing/building/#continuous-compilation","title":"Continuous Compilation","text":"<p>Watch for changes and recompile automatically:</p> <pre><code>sbt ~compile\n</code></pre>"},{"location":"contributing/building/#run-from-sbt","title":"Run from SBT","text":"<p>Execute without creating a JAR:</p> <pre><code>sbt 'run Hello.on'\n</code></pre> <p>Run script runner:</p> <pre><code>sbt 'runScript run/Hello.on'\n</code></pre>"},{"location":"contributing/building/#interactive-sbt","title":"Interactive SBT","text":"<p>Start SBT shell:</p> <pre><code>sbt\n</code></pre> <p>Then run commands: <pre><code>&gt; compile\n&gt; test\n&gt; run Hello.on\n&gt; ~compile  # Continuous compilation\n&gt; exit\n</code></pre></p>"},{"location":"contributing/building/#parser-development","title":"Parser Development","text":""},{"location":"contributing/building/#modifying-the-grammar","title":"Modifying the Grammar","text":"<ol> <li> <p>Edit the JavaCC grammar:    <pre><code>vim grammar/JJOnionParser.jj\n</code></pre></p> </li> <li> <p>Regenerate parser:    <pre><code>sbt clean compile\n</code></pre></p> </li> </ol> <p>The parser is automatically regenerated when: - Grammar file is newer than generated parser - Running <code>sbt clean</code></p>"},{"location":"contributing/building/#parser-location","title":"Parser Location","text":"<p>Generated parser: <pre><code>target/scala-3.6.2/src_managed/main/java/onion/compiler/parser/\n\u251c\u2500\u2500 JJOnionParser.java\n\u251c\u2500\u2500 Token.java\n\u251c\u2500\u2500 TokenManager.java\n\u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"contributing/building/#ide-setup","title":"IDE Setup","text":""},{"location":"contributing/building/#intellij-idea","title":"IntelliJ IDEA","text":"<ol> <li>Install Scala plugin</li> <li>Open project: <code>File &gt; Open &gt; select build.sbt</code></li> <li>Wait for indexing to complete</li> <li>Build: <code>Build &gt; Build Project</code></li> </ol> <p>Run configuration: - Main class: <code>onion.tools.CompilerFrontend</code> - Program arguments: <code>path/to/source.on</code> - Working directory: <code>$PROJECT_DIR$</code></p>"},{"location":"contributing/building/#visual-studio-code","title":"Visual Studio Code","text":"<ol> <li>Install Metals extension</li> <li>Open project folder</li> <li>Wait for import to complete</li> <li>Build via command palette: <code>Metals: Compile workspace</code></li> </ol>"},{"location":"contributing/building/#troubleshooting","title":"Troubleshooting","text":""},{"location":"contributing/building/#parser-generation-fails","title":"Parser Generation Fails","text":"<pre><code># Clean and rebuild\nsbt clean\nrm -rf target\nsbt compile\n</code></pre>"},{"location":"contributing/building/#out-of-memory","title":"Out of Memory","text":"<p>Increase SBT memory: <pre><code>export SBT_OPTS=\"-Xmx2G\"\nsbt compile\n</code></pre></p> <p>Or edit <code>.sbtopts</code>: <pre><code>-Xmx2G\n-Xss2M\n</code></pre></p>"},{"location":"contributing/building/#dependency-issues","title":"Dependency Issues","text":"<p>Clear Ivy cache: <pre><code>rm -rf ~/.ivy2/cache\nsbt update\nsbt compile\n</code></pre></p>"},{"location":"contributing/building/#compilation-errors","title":"Compilation Errors","text":"<p>Check Scala and Java versions: <pre><code>sbt scalaVersion\njava -version\n</code></pre></p> <p>Ensure they match requirements: - Scala 3.6.2 - Java 17+</p>"},{"location":"contributing/building/#build-configuration","title":"Build Configuration","text":""},{"location":"contributing/building/#buildsbt","title":"build.sbt","text":"<p>Key settings:</p> <pre><code>version := \"0.2.0-SNAPSHOT\"\nscalaVersion := \"3.6.2\"\nname := \"onion\"\norganization := \"org.onion_lang\"\n\n// Dependencies\nlibraryDependencies ++= Seq(\n  \"org.ow2.asm\" % \"asm\" % \"9.8\",\n  \"net.java.dev.javacc\" % \"javacc\" % \"5.0\",\n  \"org.scalatest\" %% \"scalatest\" % \"3.2.19\" % \"test\"\n)\n\n// Main class\nmainClass := Some(\"onion.tools.CompilerFrontend\")\n</code></pre>"},{"location":"contributing/building/#compiler-options","title":"Compiler Options","text":"<p>Scala compiler options: <pre><code>scalacOptions ++= Seq(\n  \"-encoding\", \"utf8\",\n  \"-unchecked\",\n  \"-deprecation\",\n  \"-feature\"\n)\n</code></pre></p> <p>Java compiler options: <pre><code>javacOptions ++= Seq(\n  \"-source\", \"17\",\n  \"-Xlint:unchecked\"\n)\n</code></pre></p>"},{"location":"contributing/building/#performance-tips","title":"Performance Tips","text":""},{"location":"contributing/building/#faster-builds","title":"Faster Builds","text":"<ol> <li>Use incremental compilation (default)</li> <li>Don't clean unless necessary</li> <li>Increase JVM memory</li> <li>Use SBT shell for multiple commands</li> </ol>"},{"location":"contributing/building/#parallel-compilation","title":"Parallel Compilation","text":"<p>SBT compiles in parallel by default. Adjust thread count:</p> <pre><code>Global / concurrentRestrictions := Seq(\n  Tags.limitAll(4)\n)\n</code></pre>"},{"location":"contributing/building/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"contributing/building/#macos","title":"macOS","text":"<p>May need to set JAVA_HOME: <pre><code>export JAVA_HOME=$(/usr/libexec/java_home -v 17)\n</code></pre></p>"},{"location":"contributing/building/#linux","title":"Linux","text":"<p>Ensure sufficient memory: <pre><code>free -h\n# Increase swap if needed\n</code></pre></p>"},{"location":"contributing/building/#windows","title":"Windows","text":"<p>Use PowerShell or Git Bash. Paths use backslashes: <pre><code>sbt compile\njava -jar target\\scala-3.6.2\\onion.jar Hello.on\n</code></pre></p>"},{"location":"contributing/building/#next-steps","title":"Next Steps","text":"<ul> <li>Development Guide - Contributing to Onion</li> <li>Compiler Architecture - Internals</li> <li>Running Tests - Testing guide</li> </ul>"},{"location":"contributing/development/","title":"Development Guide","text":"<p>Guide for contributing to the Onion programming language.</p>"},{"location":"contributing/development/#getting-started","title":"Getting Started","text":""},{"location":"contributing/development/#prerequisites","title":"Prerequisites","text":"<ul> <li>JDK 17 or later</li> <li>SBT (Scala Build Tool)</li> <li>Git</li> <li>Text editor or IDE (IntelliJ IDEA recommended)</li> </ul>"},{"location":"contributing/development/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/onion-lang/onion.git\ncd onion\n</code></pre>"},{"location":"contributing/development/#build-the-project","title":"Build the Project","text":"<pre><code>sbt compile\n</code></pre> <p>This will: - Download dependencies - Generate the parser from JavaCC grammar - Compile all Scala and Java source files</p>"},{"location":"contributing/development/#project-structure","title":"Project Structure","text":"<pre><code>onion/\n\u251c\u2500\u2500 build.sbt                 # SBT build configuration\n\u251c\u2500\u2500 grammar/\n\u2502   \u2514\u2500\u2500 JJOnionParser.jj     # JavaCC parser grammar\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main/\n\u2502   \u2502   \u251c\u2500\u2500 scala/           # Scala source code\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 onion/\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 compiler/        # Compiler phases\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 tools/           # CLI tools\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 ...\n\u2502   \u2502   \u2514\u2500\u2500 java/            # Java runtime library\n\u2502   \u2502       \u2514\u2500\u2500 onion/\n\u2502   \u2502           \u251c\u2500\u2500 Function0.java - Function10.java\n\u2502   \u2502           \u251c\u2500\u2500 IO.java\n\u2502   \u2502           \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 test/\n\u2502       \u251c\u2500\u2500 scala/           # Test suites\n\u2502       \u2514\u2500\u2500 run/             # Example programs\n\u251c\u2500\u2500 run/                     # Example Onion programs\n\u2514\u2500\u2500 docs/                    # Documentation\n</code></pre>"},{"location":"contributing/development/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/development/#1-create-a-feature-branch","title":"1. Create a Feature Branch","text":"<pre><code>git checkout -b feature/my-new-feature\n</code></pre>"},{"location":"contributing/development/#2-make-changes","title":"2. Make Changes","text":"<p>Edit source files using your preferred editor.</p>"},{"location":"contributing/development/#3-compile","title":"3. Compile","text":"<pre><code>sbt compile\n</code></pre>"},{"location":"contributing/development/#4-run-tests","title":"4. Run Tests","text":"<pre><code>sbt test\n</code></pre>"},{"location":"contributing/development/#5-test-manually","title":"5. Test Manually","text":"<pre><code># Run examples\nsbt 'runScript run/Hello.on'\n\n# Or use the compiler\nsbt compile\nsbt 'run-main onion.tools.CompilerFrontend run/Hello.on'\njava -cp . Hello\n</code></pre>"},{"location":"contributing/development/#6-format-code","title":"6. Format Code","text":"<p>Follow Scala style conventions: - 2 spaces for indentation - Line length limit: 120 characters - Use meaningful variable names</p>"},{"location":"contributing/development/#7-commit-changes","title":"7. Commit Changes","text":"<pre><code>git add .\ngit commit -m \"Add feature: description of change\"\n</code></pre>"},{"location":"contributing/development/#8-push-and-create-pr","title":"8. Push and Create PR","text":"<pre><code>git push origin feature/my-new-feature\n</code></pre> <p>Then create a Pull Request on GitHub.</p>"},{"location":"contributing/development/#common-development-tasks","title":"Common Development Tasks","text":""},{"location":"contributing/development/#modifying-the-parser","title":"Modifying the Parser","text":"<p>Edit <code>grammar/JJOnionParser.jj</code>, then:</p> <pre><code>sbt clean compile\n</code></pre> <p>The parser will be regenerated automatically.</p>"},{"location":"contributing/development/#adding-a-language-feature","title":"Adding a Language Feature","text":"<ol> <li>Update grammar in <code>JJOnionParser.jj</code></li> <li>Update AST in <code>AST.scala</code></li> <li>Update type checking in <code>Typing.scala</code></li> <li>Update code generation in <code>AsmCodeGeneration.scala</code></li> <li>Add tests</li> </ol>"},{"location":"contributing/development/#adding-a-test","title":"Adding a Test","text":"<p>Create a new test in <code>src/test/scala/onion/compiler/tools/</code>:</p> <pre><code>package onion.compiler.tools\n\nclass MyFeatureSpec extends AbstractShellSpec {\n  \"MyFeature\" should \"work correctly\" in {\n    val source = \"\"\"\n      |// Your test code here\n      |IO::println(\"Test\")\n    \"\"\".stripMargin\n\n    val result = runShell(source)\n    result should include(\"Test\")\n  }\n}\n</code></pre> <p>Run the test:</p> <pre><code>sbt 'testOnly *MyFeatureSpec'\n</code></pre>"},{"location":"contributing/development/#debugging-the-compiler","title":"Debugging the Compiler","text":"<p>Add print statements or use a debugger:</p> <pre><code>// In compiler code\nprintln(s\"Debug: AST = $ast\")\n</code></pre> <p>Or use IntelliJ IDEA's debugger: 1. Set breakpoints 2. Run tests in debug mode</p>"},{"location":"contributing/development/#code-organization","title":"Code Organization","text":""},{"location":"contributing/development/#compiler-phases","title":"Compiler Phases","text":"<p>Parsing (<code>Parsing.scala</code>): - Entry point for compilation - Uses JavaCC-generated parser - Produces untyped AST</p> <p>Rewriting (<code>Rewriting.scala</code>): - Normalizes AST - Desugars complex constructs</p> <p>Type Checking (<code>Typing.scala</code>): - Type inference and validation - Name resolution - Symbol table management</p> <p>Code Generation (<code>AsmCodeGeneration.scala</code>): - ASM-based bytecode generation - JVM instruction emission</p>"},{"location":"contributing/development/#support-modules","title":"Support Modules","text":"<p>AST (<code>AST.scala</code>, <code>TypedAST.scala</code>): - Abstract syntax tree definitions</p> <p>Symbol Tables (<code>ClassTable.scala</code>, <code>LocalContext.scala</code>): - Symbol management - Scope handling</p> <p>Error Handling (<code>SemanticError.scala</code>, <code>CompilationReporter.scala</code>): - Error collection - Error formatting</p>"},{"location":"contributing/development/#testing-strategy","title":"Testing Strategy","text":""},{"location":"contributing/development/#unit-tests","title":"Unit Tests","text":"<p>Test individual components:</p> <pre><code>class TypingSpec extends AnyFlatSpec with Matchers {\n  \"Type checker\" should \"infer Int type\" in {\n    // Test type inference\n  }\n}\n</code></pre>"},{"location":"contributing/development/#integration-tests","title":"Integration Tests","text":"<p>Test complete compilation:</p> <pre><code>class IntegrationSpec extends AbstractShellSpec {\n  \"Compiler\" should \"compile and run program\" in {\n    val source = \"\"\"IO::println(\"Hello\")\"\"\"\n    val result = runShell(source)\n    result should include(\"Hello\")\n  }\n}\n</code></pre>"},{"location":"contributing/development/#example-based-tests","title":"Example-Based Tests","text":"<p>Verify example programs compile and run:</p> <pre><code>sbt test\n# Runs all tests including example verification\n</code></pre>"},{"location":"contributing/development/#documentation","title":"Documentation","text":""},{"location":"contributing/development/#code-documentation","title":"Code Documentation","text":"<p>Use ScalaDoc for public APIs:</p> <pre><code>/**\n * Compiles Onion source code to JVM bytecode.\n *\n * @param source Source code string\n * @param config Compiler configuration\n * @return Compilation outcome\n */\ndef compile(source: String, config: CompilerConfig): CompilationOutcome = {\n  // ...\n}\n</code></pre>"},{"location":"contributing/development/#user-documentation","title":"User Documentation","text":"<p>Update docs in <code>docs/</code> directory: - Use Markdown format - Include code examples - Keep examples up-to-date</p>"},{"location":"contributing/development/#contributing-guidelines","title":"Contributing Guidelines","text":""},{"location":"contributing/development/#code-style","title":"Code Style","text":"<ul> <li>Follow Scala conventions</li> <li>Use meaningful names</li> <li>Keep functions focused</li> <li>Add comments for complex logic</li> </ul>"},{"location":"contributing/development/#commit-messages","title":"Commit Messages","text":"<p>Use clear, descriptive commit messages:</p> <pre><code>Add feature: Lambda expression support\n\n- Implement lambda syntax in parser\n- Add lambda type checking\n- Generate Function interface calls\n- Add lambda tests\n</code></pre>"},{"location":"contributing/development/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make changes with tests</li> <li>Ensure all tests pass</li> <li>Update documentation</li> <li>Create pull request</li> <li>Respond to review feedback</li> </ol>"},{"location":"contributing/development/#issues","title":"Issues","text":"<p>When creating issues: - Use descriptive titles - Provide example code - Include error messages - Specify Onion version</p>"},{"location":"contributing/development/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Parser generation is slow; avoid unnecessary recompilation</li> <li>Type checking can be expensive for large files</li> <li>Use incremental compilation when possible</li> </ul>"},{"location":"contributing/development/#debugging-tips","title":"Debugging Tips","text":""},{"location":"contributing/development/#compiler-crashes","title":"Compiler Crashes","text":"<ol> <li>Identify the failing phase</li> <li>Add debug output</li> <li>Check AST structure</li> <li>Verify type information</li> </ol>"},{"location":"contributing/development/#type-errors","title":"Type Errors","text":"<ol> <li>Check symbol table</li> <li>Verify type resolution</li> <li>Review type conversion rules</li> </ol>"},{"location":"contributing/development/#bytecode-issues","title":"Bytecode Issues","text":"<ol> <li>Use <code>javap</code> to inspect generated bytecode</li> <li>Verify stack frame correctness</li> <li>Check local variable indices</li> </ol>"},{"location":"contributing/development/#release-process","title":"Release Process","text":"<ol> <li>Update version in <code>build.sbt</code></li> <li>Run all tests: <code>sbt test</code></li> <li>Create distribution: <code>sbt dist</code></li> <li>Tag release: <code>git tag v0.2.0</code></li> <li>Push tag: <code>git push origin v0.2.0</code></li> <li>Create GitHub release</li> </ol>"},{"location":"contributing/development/#next-steps","title":"Next Steps","text":"<ul> <li>Building from Source - Detailed build instructions</li> <li>Compiler Architecture - Compiler internals</li> <li>Language Specification - Language details</li> </ul>"},{"location":"examples/basic/","title":"Basic Examples","text":"<p>Simple programs demonstrating fundamental Onion features.</p>"},{"location":"examples/basic/#hello-world","title":"Hello World","text":"<p>The simplest Onion program:</p> <p>File: <code>Hello.on</code> <pre><code>IO::println(\"Hello\")\n</code></pre></p> <p>Run: <pre><code>onion Hello.on\n</code></pre></p> <p>Output: <pre><code>Hello\n</code></pre></p>"},{"location":"examples/basic/#arrays","title":"Arrays","text":"<p>Working with arrays:</p> <p>File: <code>Array.on</code> <pre><code>val array: String[] = new String[3]\narray[0] = \"A\"\narray[1] = \"B\"\narray[2] = \"C\"\n\nfor var i: Int = 0; i &lt; array.length; i = i + 1 {\n  IO::println(array[i])\n}\n</code></pre></p> <p>Topics: - Array declaration and initialization - Index-based access - For loop with <code>.length</code> property</p>"},{"location":"examples/basic/#string-concatenation","title":"String Concatenation","text":"<p>String operations and list iteration:</p> <p>File: <code>StringCat.on</code> <pre><code>val list: List = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"];\nfor var i: Int = 0; i &lt; list.size; i = i + 1 {\n  System::out.println(\"list[\" + i + \"] = \" + list[i]);\n}\n</code></pre></p> <p>Topics: - Array literals - String concatenation with <code>+</code> - <code>.size</code> property - System output</p>"},{"location":"examples/basic/#user-input","title":"User Input","text":"<p>Reading user input:</p> <p>File: <code>ReadLine.on</code> <pre><code>val name: String = IO::readln(\"What's your name? \")\nIO::println(\"Hello, \" + name + \"!\")\n</code></pre></p> <p>Run: <pre><code>onion ReadLine.on\n</code></pre></p> <p>Interaction: <pre><code>What's your name? Alice\nHello, Alice!\n</code></pre></p> <p>Topics: - <code>IO::readln()</code> for reading input - String concatenation - Interactive programs</p>"},{"location":"examples/basic/#dynamic-lists","title":"Dynamic Lists","text":"<p>Using ArrayList with the <code>&lt;&lt;</code> append operator:</p> <p>File: <code>List.on</code> <pre><code>val list: List = [];\n\nlist &lt;&lt; \"a\";\nlist &lt;&lt; \"b\";\nlist &lt;&lt; \"c\";\nlist &lt;&lt; \"d\";\n\nfor var i: Int = 0; i &lt; list.size; i = i + 1 {\n  System::out.println(list[i]);\n}\n</code></pre></p> <p>Topics: - Importing Java classes - ArrayList creation - <code>&lt;&lt;</code> append operator - Index-based access on collections</p>"},{"location":"examples/basic/#foreach-loop","title":"Foreach Loop","text":"<p>Enhanced for loop with collections:</p> <p>File: <code>Foreach.on</code> <pre><code>import { java.util.ArrayList; }\n\nval list: ArrayList[String] = new ArrayList[String]\nlist &lt;&lt; \"HELLO\";\nlist &lt;&lt; \"WORLD\";\nlist &lt;&lt; \"ONION\";\n\nforeach object :String in list {\n  IO::println(object.toLowerCase())\n}\n</code></pre></p> <p>Output: <pre><code>hello\nworld\nonion\n</code></pre></p> <p>Topics: - <code>foreach</code> loop syntax - Type annotations in loops - Method calls on loop variables</p>"},{"location":"examples/basic/#pattern-matching","title":"Pattern Matching","text":"<p>Using the <code>select</code> statement:</p> <p>File: <code>Select.on</code> <pre><code>val value: Int = (Math::random() * 10)$Int\n\nselect value {\n  case 0, 1, 2, 3:\n    IO::println(\"Low: \" + value)\n  case 4, 5, 6:\n    IO::println(\"Medium: \" + value)\n  case 7, 8, 9:\n    IO::println(\"High: \" + value)\n  else:\n    IO::println(\"Out of range: \" + value)\n}\n</code></pre></p> <p>Topics: - <code>select</code> statement - Multiple values per case - <code>else</code> default clause - Type casting with <code>$</code> - <code>Math::random()</code> function</p>"},{"location":"examples/basic/#complete-example-array-processing","title":"Complete Example: Array Processing","text":"<p>Combining multiple concepts:</p> <pre><code>import { java.util.ArrayList; }\n\n// Create numbers list\nval numbers: java.util.List = [10, 20, 30, 40, 50]\n\n// Filter even numbers\nval evens: ArrayList = new ArrayList\nforeach num :Int in numbers {\n  if num % 2 == 0 {\n    evens &lt;&lt; num\n  }\n}\n\n// Print results\nIO::println(\"Even numbers:\")\nforeach even :Object in evens {\n  IO::println(even$Int)\n}\n</code></pre> <p>Output: <pre><code>Even numbers:\n10\n20\n30\n40\n50\n</code></pre></p>"},{"location":"examples/basic/#complete-example-simple-calculator","title":"Complete Example: Simple Calculator","text":"<pre><code>val x: Int = 10\nval y: Int = 3\n\nIO::println(\"Addition: \" + (x + y))\nIO::println(\"Subtraction: \" + (x - y))\nIO::println(\"Multiplication: \" + (x * y))\nIO::println(\"Division: \" + (x / y))\nIO::println(\"Modulo: \" + (x % y))\n</code></pre> <p>Output: <pre><code>Addition: 13\nSubtraction: 7\nMultiplication: 30\nDivision: 3\nModulo: 1\n</code></pre></p>"},{"location":"examples/basic/#next-steps","title":"Next Steps","text":"<ul> <li>OOP Examples - Object-oriented programs</li> <li>Functional Examples - Lambdas and higher-order functions</li> <li>Language Guide - Deep dive into features</li> </ul>"},{"location":"examples/functional/","title":"Functional Programming Examples","text":"<p>Examples demonstrating functional programming features in Onion.</p>"},{"location":"examples/functional/#lambda-expressions","title":"Lambda Expressions","text":"<p>Basic lambda syntax:</p> <pre><code>// Simple lambda\nval double: (Int) -&gt; Int = (x: Int) -&gt; { return x * 2; }\nIO::println(double.call(5))  // 10\n\n// Lambda with multiple parameters\nval add: (Int, Int) -&gt; Int = (x: Int, y: Int) -&gt; { return x + y; }\nIO::println(add.call(3, 7))  // 10\n\n// Lambda with no parameters\nval greet: () -&gt; String = () -&gt; { IO::println(\"Hello!\"); return \"done\"; }\ngreet.call()\n</code></pre>"},{"location":"examples/functional/#closures","title":"Closures","text":"<p>Lambdas that capture variables:</p> <p>File: <code>LineFilter.on</code> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.FileReader;\n  java.io.StringReader;\n}\n\nvar i: Int = 0\nval filter: (String) -&gt; String = (line: String) -&gt; {\n  i = i + 1\n  return line + \" (\" + i + \")\";\n}\n\nval reader: BufferedReader = new BufferedReader(\n  new StringReader(\"First\\nSecond\\nThird\")\n)\n\nvar line: String = null\nwhile (line = reader.readLine()) != null {\n  IO::println(filter.call(line))\n}\n</code></pre></p> <p>Output: <pre><code>First (1)\nSecond (2)\nThird (3)\n</code></pre></p> <p>Topics: - Closure capturing variable <code>i</code> - Lambda returning modified string - Post-increment in closure</p>"},{"location":"examples/functional/#counter-factory","title":"Counter Factory","text":"<p>Creating multiple independent counters:</p> <pre><code>def makeCounter(): () -&gt; Int {\n  var count: Int = 0\n  return () -&gt; {\n    count = count + 1\n    return count;\n  };\n}\n\nval counter1: () -&gt; Int = makeCounter()\nval counter2: () -&gt; Int = makeCounter()\n\nIO::println(counter1.call())  // 1\nIO::println(counter1.call())  // 2\nIO::println(counter2.call())  // 1\nIO::println(counter1.call())  // 3\nIO::println(counter2.call())  // 2\n</code></pre> <p>Each counter maintains its own <code>count</code> variable.</p>"},{"location":"examples/functional/#recursion","title":"Recursion","text":"<p>File: <code>Factorial.on</code> <pre><code>import { java.lang.NumberFormatException; }\n\ndef fact(n :Int) :Int {\n  if n &lt; 0 {\n    IO::println(\"Illegal argument\")\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return n * fact(n - 1)\n}\n\nvar line: String = null\nwhile (line = IO::readln(\"Enter number: \")) != null {\n  try {\n    val value: Int = JInteger::parseInt(line)\n    val result: Int = fact(value)\n    IO::println(\"Factorial: \" + result)\n  } catch e :NumberFormatException {\n    IO::println(\"Invalid number\")\n  }\n}\n</code></pre></p> <p>Topics: - Recursive function calls - Base case handling - Try-catch for error handling</p>"},{"location":"examples/functional/#file-line-counter-with-recursion","title":"File Line Counter with Recursion","text":"<p>File: <code>LineCounter.on</code> (simplified) <pre><code>import {\n  java.io.File;\n  java.io.FileReader;\n  java.io.BufferedReader;\n}\n\ndef countLines(file :File) :Int {\n  if file == null {\n    return 0\n  }\n\n  if file.isDirectory() {\n    var total: Int = 0\n    val files: File[] = file.listFiles()\n\n    if files != null {\n      foreach f :File in files {\n        total = total + countLines(f)\n      }\n    }\n\n    return total\n  }\n\n  if !file.name.endsWith(\".on\") {\n    return 0\n  }\n\n  val reader: BufferedReader = new BufferedReader(\n    new FileReader(file)\n  )\n\n  var count: Int = 0\n  var line: String = null\n  while (line = reader.readLine()) != null {\n    count = count + 1\n  }\n\n  reader.close()\n  IO::println(file.name + \": \" + count)\n  return count\n}\n\n// Usage\nval dir: File = new File(\"src\")\nval total: Int = countLines(dir)\nIO::println(\"Total lines: \" + total)\n</code></pre></p> <p>Topics: - Recursive directory traversal - File operations - Conditional logic</p>"},{"location":"examples/functional/#filter-function","title":"Filter Function","text":"<p>Higher-order function that filters a list:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.List;\n}\n\ndef filter(items: List, predicate: (String) -&gt; Boolean): ArrayList {\n  val result: ArrayList = new ArrayList\n\n  foreach item: String in items {\n    if predicate.call(item) {\n      result &lt;&lt; item\n    }\n  }\n\n  return result\n}\n\n// Usage\nval logs: List = [\n  \"INFO: Started\",\n  \"ERROR: Failed\",\n  \"INFO: Processing\",\n  \"ERROR: Timeout\",\n  \"INFO: Complete\"\n]\n\nval isError: (String) -&gt; Boolean = (line: String) -&gt; { return line.startsWith(\"ERROR\"); }\n\nval errors: ArrayList = filter(logs, isError)\n\nforeach error: String in errors {\n  IO::println(error)\n}\n</code></pre> <p>Output: <pre><code>ERROR: Failed\nERROR: Timeout\n</code></pre></p>"},{"location":"examples/functional/#map-function","title":"Map Function","text":"<p>Transform each element in a collection:</p> <pre><code>import { java.util.ArrayList; }\n\ndef map(items: java.util.List, transform: (String) -&gt; String): ArrayList {\n  val result: ArrayList = new ArrayList\n\n  foreach item: String in items {\n    result &lt;&lt; transform.call(item)\n  }\n\n  return result\n}\n\n// Usage\nval words: java.util.List = [\"hello\", \"world\", \"onion\"]\nval toUpper: (String) -&gt; String = (s: String) -&gt; { return s.toUpperCase(); }\n\nval upper: ArrayList = map(words, toUpper)\n\nforeach word: String in upper {\n  IO::println(word)\n}\n</code></pre> <p>Output: <pre><code>HELLO\nWORLD\nONION\n</code></pre></p>"},{"location":"examples/functional/#reduce-function","title":"Reduce Function","text":"<p>Accumulate values:</p> <pre><code>import { java.util.List; }\n\ndef reduce(items: List, operation: (Int, Int) -&gt; Int, initial: Int): Int {\n  var accumulator: Int = initial\n\n  foreach item: Int in items {\n    accumulator = operation.call(accumulator, item)\n  }\n\n  return accumulator\n}\n\n// Sum\nval numbers: List = [1, 2, 3, 4, 5]\nval sum: (Int, Int) -&gt; Int = (acc: Int, n: Int) -&gt; { return acc + n; }\nval total: Int = reduce(numbers, sum, 0)\nIO::println(\"Sum: \" + total)  // 15\n\n// Product\nval product: (Int, Int) -&gt; Int = (acc: Int, n: Int) -&gt; { return acc * n; }\nval result: Int = reduce(numbers, product, 1)\nIO::println(\"Product: \" + result)  // 120\n</code></pre>"},{"location":"examples/functional/#composing-functions","title":"Composing Functions","text":"<p>Combine multiple operations:</p> <pre><code>def compose(f: (Int) -&gt; Int, g: (Int) -&gt; Int): (Int) -&gt; Int {\n  return (x: Int) -&gt; { return f.call(g.call(x)); }\n}\n\n// Define functions\nval addTen: (Int) -&gt; Int = (x: Int) -&gt; { return x + 10; }\nval double: (Int) -&gt; Int = (x: Int) -&gt; { return x * 2; }\n\n// Compose: double then add 10\nval composed: (Int) -&gt; Int = compose(addTen, double)\n\nIO::println(composed.call(5))  // (5 * 2) + 10 = 20\n</code></pre>"},{"location":"examples/functional/#currying","title":"Currying","text":"<p>Transform multi-parameter functions:</p> <pre><code>def add(x: Int): (Int) -&gt; Int = (y: Int) -&gt; { return x + y; }\n\nval add5: (Int) -&gt; Int = add(5)\nval add10: (Int) -&gt; Int = add(10)\n\nIO::println(add5.call(3))   // 8\nIO::println(add10.call(3))  // 13\n</code></pre>"},{"location":"examples/functional/#practical-log-analyzer","title":"Practical: Log Analyzer","text":"<p>Complete example combining functional concepts:</p> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.FileReader;\n  java.util.ArrayList;\n}\n\ndef analyzeLog(filename :String) {\n  val reader: BufferedReader = new BufferedReader(\n    new FileReader(filename)\n  )\n\n  var errorCount: Int = 0\n  var warningCount: Int = 0\n  var infoCount: Int = 0\n\n  val isError: (String) -&gt; Boolean = (line: String) -&gt; { return line.startsWith(\"ERROR\"); }\n  val isWarning: (String) -&gt; Boolean = (line: String) -&gt; { return line.startsWith(\"WARNING\"); }\n  val isInfo: (String) -&gt; Boolean = (line: String) -&gt; { return line.startsWith(\"INFO\"); }\n\n  var line: String = null\n  while (line = reader.readLine()) != null {\n    if isError.call(line) {\n      errorCount = errorCount + 1\n    } else if isWarning.call(line) {\n      warningCount = warningCount + 1\n    } else if isInfo.call(line) {\n      infoCount = infoCount + 1\n    }\n  }\n\n  reader.close()\n\n  IO::println(\"Errors: \" + errorCount)\n  IO::println(\"Warnings: \" + warningCount)\n  IO::println(\"Info: \" + infoCount)\n}\n\nanalyzeLog(\"app.log\")\n</code></pre>"},{"location":"examples/functional/#next-steps","title":"Next Steps","text":"<ul> <li>Lambda Expressions Guide - Detailed lambda documentation</li> <li>Functions Guide - Function definitions</li> <li>Basic Examples - Simpler programs</li> </ul>"},{"location":"examples/oop/","title":"Object-Oriented Examples","text":"<p>Examples demonstrating object-oriented programming in Onion.</p>"},{"location":"examples/oop/#classes-and-objects","title":"Classes and Objects","text":"<p>Basic class definition:</p> <pre><code>class Person {\n  val name: String\n  var age: Int\n\n  public:\n    def this(n: String, a: Int) {\n      this.name = n\n      this.age = a\n    }\n\n    def greet: String = \"Hello, I'm \" + this.name + \" and I'm \" + this.age + \" years old\"\n\n    def haveBirthday {\n      this.age = this.age + 1\n      IO::println(\"Happy birthday! Now \" + this.age)\n    }\n}\n\nval person: Person = new Person(\"Alice\", 30)\nIO::println(person.greet())\nperson.haveBirthday()\n</code></pre> <p>Output: <pre><code>Hello, I'm Alice and I'm 30 years old\nHappy birthday! Now 31\n</code></pre></p>"},{"location":"examples/oop/#inheritance","title":"Inheritance","text":"<p>Extending classes:</p> <pre><code>class Animal {\nprotected:\n  val name: String\n\n  public:\n    def this(n: String) {\n      this.name = n\n    }\n\n    def speak: String = this.name + \" makes a sound\"\n}\n\nclass Dog : Animal {\n  val breed: String\n\n  public:\n    def this(n: String, b: String): (n) {\n      this.breed = b\n    }\n\n    def speak: String = this.name + \" barks: Woof!\"\n\n    def getBreed: String = this.breed\n}\n\nval dog: Dog = new Dog(\"Buddy\", \"Golden Retriever\")\nIO::println(dog.speak())\nIO::println(\"Breed: \" + dog.getBreed())\n</code></pre> <p>Output: <pre><code>Buddy barks: Woof!\nBreed: Golden Retriever\n</code></pre></p>"},{"location":"examples/oop/#interfaces","title":"Interfaces","text":"<p>Implementing Java interfaces:</p> <pre><code>import { java.lang.Comparable; }\n\nclass Student &lt;: Comparable {\n  val name: String\n  val grade: Int\n\n  public:\n    def this(n: String, g: Int) {\n      this.name = n\n      this.grade = g\n    }\n\n    def compareTo(other: Object): Int {\n      val otherStudent: Student = other$Student\n      return this.grade - otherStudent.grade\n    }\n\n    def toString: String = this.name + \": \" + this.grade\n}\n\nval students: Student[] = new Student[3]\nstudents[0] = new Student(\"Alice\", 85)\nstudents[1] = new Student(\"Bob\", 92)\nstudents[2] = new Student(\"Charlie\", 78)\n\n// Sort students by grade\nimport { java.util.Arrays; }\nArrays::sort(students)\n\nforeach s :Student in students {\n  IO::println(s.toString())\n}\n</code></pre> <p>Output: <pre><code>Charlie: 78\nAlice: 85\nBob: 92\n</code></pre></p>"},{"location":"examples/oop/#delegation-pattern","title":"Delegation Pattern","text":"<p>Using <code>forward</code> for delegation:</p> <p>File: <code>Delegation.on</code> <pre><code>import {\n  java.util.List;\n  java.util.ArrayList;\n}\n\nclass Delegation &lt;: List {\n  forward val n: List;\n\n  public:\n    def this {\n      this.n = new ArrayList;\n    }\n\n    static def main(args: String[]) {\n      val list: List = new Delegation;\n      list &lt;&lt; \"a\";\n      list &lt;&lt; \"b\";\n      list &lt;&lt; \"c\";\n\n      for var i: Int = 0; i &lt; list.size; i = i + 1 {\n        IO::println(list[i]);\n      }\n    }\n}\n</code></pre></p> <p>Topics: - <code>forward</code> directive delegates interface methods - <code>&lt;&lt;</code> operator for adding elements - Implementing interfaces via delegation</p>"},{"location":"examples/oop/#javabean-pattern","title":"JavaBean Pattern","text":"<p>File: <code>Bean.on</code> <pre><code>import {\n  java.io.Serializable;\n  java.beans.XMLEncoder;\n  java.beans.XMLDecoder;\n  java.io.ByteArrayOutputStream;\n  java.io.ByteArrayInputStream;\n}\n\nclass ExampleBean &lt;: Serializable {\n  var name: String\n  var value: Int\n\n  public:\n    def this {\n      // Default constructor required for beans\n    }\n\n    def this(name: String, value: Int) {\n      this.name = name\n      this.value = value\n    }\n\n    // Getters\n    def getName: String = this.name\n    def getValue: Int = this.value\n\n    // Setters\n    def setName(name: String) {\n      this.name = name\n    }\n\n    def setValue(value: Int) {\n      this.value = value\n    }\n\n    static def main(args: String[]) {\n      // Create bean\n      val bean: ExampleBean = new ExampleBean(\"Test\", 42)\n\n      // Serialize to XML\n      val out: ByteArrayOutputStream = new ByteArrayOutputStream\n      val encoder: XMLEncoder = new XMLEncoder(out)\n      encoder.writeObject(bean)\n      encoder.close()\n\n      IO::println(\"Serialized bean\")\n\n      // Deserialize from XML\n      val inStream: ByteArrayInputStream = new ByteArrayInputStream(\n        out.toByteArray()\n      )\n      val decoder: XMLDecoder = new XMLDecoder(inStream)\n      val restored: ExampleBean = decoder.readObject()$ExampleBean\n      decoder.close()\n\n      IO::println(\"Name: \" + restored.getName())\n      IO::println(\"Value: \" + restored.getValue())\n    }\n}\n</code></pre></p> <p>Topics: - JavaBean conventions - Getter and setter methods - Serialization with XMLEncoder/XMLDecoder - Multiple constructors</p>"},{"location":"examples/oop/#gui-application","title":"GUI Application","text":"<p>File: <code>Calculator.on</code> (simplified) <pre><code>import {\n  javax.swing.JFrame;\n  javax.swing.JButton;\n  javax.swing.JTextField;\n  javax.swing.JPanel;\n  java.awt.event.ActionListener;\n  java.awt.event.ActionEvent;\n  java.awt.GridLayout;\n  java.awt.BorderLayout;\n}\n\nclass Calculator : JFrame &lt;: ActionListener {\n  val text: JTextField\n  var currentValue: Long\n  var operator: String\n\n  public:\n    def this {\n      setTitle(\"Simple Calculator\")\n      setSize(300, 400)\n      setLayout(new BorderLayout())\n\n      this.text = new JTextField(\"0\")\n      add(this.text, BorderLayout::NORTH)\n\n      val panel: JPanel = new JPanel()\n      panel.setLayout(new GridLayout(4, 4))\n\n      val buttons: java.util.List = [\n        \"7\", \"8\", \"9\", \"/\",\n        \"4\", \"5\", \"6\", \"*\",\n        \"1\", \"2\", \"3\", \"-\",\n        \"0\", \"C\", \"=\", \"+\"\n      ]\n\n      foreach label: String in buttons {\n        val button: JButton = new JButton(label)\n        button.addActionListener(this)\n        panel.add(button)\n      }\n\n      add(panel, BorderLayout::CENTER)\n\n      this.currentValue = 0L\n      this.operator = null\n\n      setDefaultCloseOperation(JFrame::EXIT_ON_CLOSE)\n      setVisible(true)\n    }\n\n    def actionPerformed(event :ActionEvent) {\n      val button: JButton = event.getSource()$JButton\n      val label: String = button.getText()\n\n      // Handle button click\n      if label == \"C\" {\n        this.text.setText(\"0\")\n        this.currentValue = 0L\n        this.operator = null\n      } else if label == \"=\" {\n        calculate()\n      } else if label == \"+\" || label == \"-\" ||\n                label == \"*\" || label == \"/\" {\n        this.operator = label\n        this.currentValue = JLong::parseLong(this.text.getText())\n        this.text.setText(\"0\")\n      } else {\n        // Number button\n        val current: String = this.text.getText()\n        if current == \"0\" {\n          this.text.setText(label)\n        } else {\n          this.text.setText(current + label)\n        }\n      }\n    }\n\n    def calculate {\n      if this.operator != null {\n        val value: Long = JLong::parseLong(this.text.getText())\n        var result: Long = 0L\n\n        select this.operator {\n          case \"+\":\n            result = this.currentValue + value\n          case \"-\":\n            result = this.currentValue - value\n          case \"*\":\n            result = this.currentValue * value\n          case \"/\":\n            result = this.currentValue / value\n        }\n\n        this.text.setText(JLong::toString(result))\n        this.operator = null\n      }\n    }\n\n    static def main(args :String[]) {\n      val calc: Calculator = new Calculator\n    }\n}\n</code></pre></p> <p>Topics: - Multiple inheritance (extends JFrame, implements ActionListener) - Swing GUI components - Event handling - <code>self</code> reference - <code>select</code> statement for operations</p>"},{"location":"examples/oop/#next-steps","title":"Next Steps","text":"<ul> <li>Functional Examples - Lambdas and closures</li> <li>Basic Examples - Simpler programs</li> <li>Inheritance Guide - Learn more about OOP</li> </ul>"},{"location":"examples/overview/","title":"Examples Overview","text":"<p>This section provides practical examples of Onion programs, demonstrating various language features and programming patterns.</p>"},{"location":"examples/overview/#example-programs","title":"Example Programs","text":"<p>All examples can be found in the <code>run/</code> directory of the Onion repository.</p>"},{"location":"examples/overview/#basic-programs","title":"Basic Programs","text":"<ul> <li>Hello World - Simple output</li> <li>Arrays - Array manipulation</li> <li>User Input - Reading input</li> </ul>"},{"location":"examples/overview/#object-oriented-examples","title":"Object-Oriented Examples","text":"<ul> <li>Classes and Objects - Basic OOP</li> <li>Inheritance - Extending classes</li> <li>Interfaces - Interface implementation</li> </ul>"},{"location":"examples/overview/#functional-programming","title":"Functional Programming","text":"<ul> <li>Lambda Expressions - Anonymous functions</li> <li>Closures - Capturing variables</li> <li>Recursion - Recursive algorithms</li> </ul>"},{"location":"examples/overview/#running-examples","title":"Running Examples","text":""},{"location":"examples/overview/#using-the-script-runner","title":"Using the Script Runner","text":"<pre><code>cd run\nonion Hello.on\n</code></pre>"},{"location":"examples/overview/#compiling-and-running","title":"Compiling and Running","text":"<pre><code>onionc Hello.on\njava Hello\n</code></pre>"},{"location":"examples/overview/#example-index","title":"Example Index","text":"File Description Topics Covered <code>Hello.on</code> Hello World Basic I/O <code>Array.on</code> Array operations Arrays, loops <code>StringCat.on</code> String concatenation Strings, arrays <code>ReadLine.on</code> User input I/O, strings <code>List.on</code> Dynamic lists ArrayList, <code>&lt;&lt;</code> operator <code>Foreach.on</code> Foreach loop Iteration, collections <code>Select.on</code> Pattern matching Select statement <code>LineFilter.on</code> Lambda filtering Lambdas, closures <code>LineCounter.on</code> File processing Recursion, I/O <code>Factorial.on</code> Recursion Recursive functions <code>Delegation.on</code> Delegation pattern Interfaces, forward <code>Calculator.on</code> GUI calculator Swing, event handling <code>Bean.on</code> JavaBean pattern Serialization, getters/setters"},{"location":"examples/overview/#learning-path","title":"Learning Path","text":""},{"location":"examples/overview/#beginner","title":"Beginner","text":"<ol> <li>Start with <code>Hello.on</code> - Basic syntax</li> <li>Try <code>Array.on</code> - Data structures</li> <li>Explore <code>Foreach.on</code> - Iteration</li> </ol>"},{"location":"examples/overview/#intermediate","title":"Intermediate","text":"<ol> <li>Study <code>Factorial.on</code> - Recursion</li> <li>Learn <code>LineFilter.on</code> - Lambdas</li> <li>Review <code>Bean.on</code> - OOP patterns</li> </ol>"},{"location":"examples/overview/#advanced","title":"Advanced","text":"<ol> <li>Analyze <code>Calculator.on</code> - GUI programming</li> <li>Understand <code>Delegation.on</code> - Design patterns</li> <li>Examine <code>LineCounter.on</code> - File processing</li> </ol>"},{"location":"examples/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Examples - Simple programs</li> <li>OOP Examples - Object-oriented code</li> <li>Functional Examples - Functional programming</li> </ul>"},{"location":"getting-started/hello-world/","title":"Hello World","text":"<p>Let's write and run your first Onion program!</p>"},{"location":"getting-started/hello-world/#the-classic-hello-world","title":"The Classic Hello World","text":"<p>Create a file named <code>Hello.on</code>:</p> <pre><code>IO::println(\"Hello, World!\")\n</code></pre> <p>That's it! This single line is a complete Onion program.</p>"},{"location":"getting-started/hello-world/#running-your-program","title":"Running Your Program","text":"<p>There are two ways to run Onion programs:</p>"},{"location":"getting-started/hello-world/#method-1-direct-execution-with-onion","title":"Method 1: Direct Execution with <code>onion</code>","text":"<p>The <code>onion</code> command compiles and runs your program in memory:</p> <pre><code>onion Hello.on\n</code></pre> <p>Output: <pre><code>Hello, World!\n</code></pre></p>"},{"location":"getting-started/hello-world/#method-2-compilation-with-onionc","title":"Method 2: Compilation with <code>onionc</code>","text":"<p>Compile to <code>.class</code> files and run with Java:</p> <pre><code># Compile\nonionc Hello.on\n\n# Run with Java\njava Hello\n</code></pre>"},{"location":"getting-started/hello-world/#understanding-the-code","title":"Understanding the Code","text":"<pre><code>IO::println(\"Hello, World!\")\n</code></pre> <ul> <li><code>IO</code> - The built-in I/O module</li> <li><code>::</code> - Static method access operator (similar to Java's <code>.</code>)</li> <li><code>println()</code> - Print with newline function</li> <li><code>\"Hello, World!\"</code> - String literal</li> </ul>"},{"location":"getting-started/hello-world/#more-examples","title":"More Examples","text":""},{"location":"getting-started/hello-world/#using-variables","title":"Using Variables","text":"<pre><code>val message: String = \"Hello, Onion!\"\nIO::println(message)\n</code></pre>"},{"location":"getting-started/hello-world/#getting-user-input","title":"Getting User Input","text":"<pre><code>val name: String = IO::readln(\"What's your name? \")\nIO::println(\"Hello, \" + name + \"!\")\n</code></pre> <p>Run it: <pre><code>onion greeting.on\n</code></pre></p> <p>Output: <pre><code>What's your name? Alice\nHello, Alice!\n</code></pre></p>"},{"location":"getting-started/hello-world/#with-a-main-class","title":"With a Main Class","text":"<p>You can also write programs with explicit class definitions:</p> <pre><code>class HelloWorld {\n  public:\n    static def main(args: String[]) {\n      IO::println(\"Hello, World!\")\n    }\n}\n</code></pre> <p>This follows the traditional Java main method pattern.</p>"},{"location":"getting-started/hello-world/#command-line-arguments","title":"Command-Line Arguments","text":"<p>Access command-line arguments through the <code>main</code> method:</p> <pre><code>class ArgsDemo {\n  public:\n    static def main(args: String[]) {\n      IO::println(\"Number of arguments: \" + args.length)\n      for var i: Int = 0; i &lt; args.length; i = i + 1 {\n        IO::println(\"Arg \" + i + \": \" + args[i])\n      }\n    }\n}\n</code></pre> <p>Run with arguments: <pre><code>onion ArgsDemo.on hello world 123\n</code></pre></p> <p>Output: <pre><code>Number of arguments: 3\nArg 0: hello\nArg 1: world\nArg 2: 123\n</code></pre></p>"},{"location":"getting-started/hello-world/#next-steps","title":"Next Steps","text":"<p>Now that you've written your first Onion program, continue with:</p> <ul> <li>Quick Start Guide - Learn essential language features</li> <li>Basic Syntax - Variables, types, and operators</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install and set up the Onion programming language on your system.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Onion runs on the JVM and requires:</p> <ul> <li>Java Development Kit (JDK) 17 or later</li> <li>SBT (Scala Build Tool) - for building from source</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-download-pre-built-binary-recommended","title":"Method 1: Download Pre-built Binary (Recommended)","text":"<ol> <li>Download the latest release from the GitHub Releases page</li> <li>Extract the archive:    <pre><code>unzip onion-dist.zip\ncd onion-dist\n</code></pre></li> <li>Add the <code>bin</code> directory to your PATH:    <pre><code>export PATH=$PATH:/path/to/onion-dist/bin\n</code></pre></li> </ol>"},{"location":"getting-started/installation/#method-2-build-from-source","title":"Method 2: Build from Source","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/onion-lang/onion.git\ncd onion\n</code></pre></p> </li> <li> <p>Build the project with SBT:    <pre><code>sbt compile\n</code></pre></p> </li> <li> <p>Create the distribution package:    <pre><code>sbt dist\n</code></pre></p> </li> </ol> <p>This creates a distribution ZIP in <code>target/onion-dist.zip</code></p> <ol> <li>Or build a standalone JAR:    <pre><code>sbt assembly\n</code></pre></li> </ol> <p>This creates <code>onion.jar</code> in the <code>target/scala-3.6.2/</code> directory</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Check that Onion is installed correctly:</p> <pre><code># If using the distribution\nonionc --help\n\n# If using the JAR directly\njava -jar onion.jar --help\n</code></pre>"},{"location":"getting-started/installation/#ide-setup","title":"IDE Setup","text":""},{"location":"getting-started/installation/#visual-studio-code","title":"Visual Studio Code","text":"<p>While there's no official Onion extension yet, you can use:</p> <ul> <li>Generic syntax highlighting for similar languages</li> <li>Java/Scala extensions for dependency management</li> </ul>"},{"location":"getting-started/installation/#intellij-idea","title":"IntelliJ IDEA","text":"<p>For developing the Onion compiler itself:</p> <ol> <li>Install the Scala plugin</li> <li>Import the project as an SBT project</li> <li>The IDE will automatically download dependencies</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Hello World Tutorial - Write your first Onion program</li> <li>Quick Start Guide - Learn the essential features</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide covers the essential features of Onion to get you productive quickly.</p>"},{"location":"getting-started/quick-start/#variables-and-types","title":"Variables and Types","text":"<p>Onion is statically typed. Local <code>val</code> / <code>var</code> declarations can include a type annotation, or omit it when an initializer is present:</p> <pre><code>// Type annotation\nval name: String = \"Alice\"\nval age: Int = 30\nval price: Double = 19.99\n\n// Type inference (local only)\nval count = 42         // Inferred as Int\nvar greeting = \"Hello\" // Inferred as String\n</code></pre>"},{"location":"getting-started/quick-start/#control-flow","title":"Control Flow","text":""},{"location":"getting-started/quick-start/#if-else","title":"If-Else","text":"<pre><code>val x: Int = 10\n\nif x &gt; 5 {\n  IO::println(\"x is greater than 5\")\n} else {\n  IO::println(\"x is 5 or less\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#while-loop","title":"While Loop","text":"<pre><code>var i: Int = 0\nwhile i &lt; 5 {\n  IO::println(i)\n  i = i + 1\n}\n</code></pre>"},{"location":"getting-started/quick-start/#for-loop","title":"For Loop","text":"<pre><code>for var i: Int = 0; i &lt; 10; i = i + 1 {\n  IO::println(\"Count: \" + i)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#foreach-loop","title":"Foreach Loop","text":"<pre><code>val names: java.util.List = [\"Alice\", \"Bob\", \"Charlie\"]\nforeach name: String in names {\n  IO::println(\"Hello, \" + name)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#select-statement-pattern-matching","title":"Select Statement (Pattern Matching)","text":"<pre><code>val score: Int = 85\n\nselect score {\n  case 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100:\n    IO::println(\"Grade: A\")\n  case 80, 81, 82, 83, 84, 85, 86, 87, 88, 89:\n    IO::println(\"Grade: B\")\n  case 70, 71, 72, 73, 74, 75, 76, 77, 78, 79:\n    IO::println(\"Grade: C\")\n  else:\n    IO::println(\"Grade: F\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#functions","title":"Functions","text":""},{"location":"getting-started/quick-start/#basic-function","title":"Basic Function","text":"<pre><code>def greet(name: String): String = \"Hello, \" + name + \"!\"\n\nval message: String = greet(\"World\")\nIO::println(message)\n</code></pre>"},{"location":"getting-started/quick-start/#lambda-expressions","title":"Lambda Expressions","text":"<pre><code>// Lambda syntax: (params) -&gt; { body }\nval add: (Int, Int) -&gt; Int = (x: Int, y: Int) -&gt; { return x + y; }\n\nval result: Int = add.call(5, 3)  // 8\nIO::println(result)\n</code></pre>"},{"location":"getting-started/quick-start/#function-with-multiple-parameters","title":"Function with Multiple Parameters","text":"<pre><code>def multiply(a: Int, b: Int): Int = a * b\n\nIO::println(multiply(6, 7))  // 42\n</code></pre>"},{"location":"getting-started/quick-start/#arrays-and-collections","title":"Arrays and Collections","text":""},{"location":"getting-started/quick-start/#arrays","title":"Arrays","text":"<pre><code>// Fixed-size array\nval numbers: Int[] = new Int[5]\nnumbers[0] = 10\nnumbers[1] = 20\n\nval colors: String[] = new String[3]\ncolors[0] = \"red\"\ncolors[1] = \"green\"\ncolors[2] = \"blue\"\n\n// Iterate over array\nforeach color :String in colors {\n  IO::println(color)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#lists-arraylist","title":"Lists (ArrayList)","text":"<pre><code>import {\n  java.util.ArrayList;\n}\n\nval list: ArrayList = new ArrayList\nlist &lt;&lt; \"First\"   // &lt;&lt; is the append operator\nlist &lt;&lt; \"Second\"\nlist &lt;&lt; \"Third\"\n\nIO::println(list.size)  // 3\nIO::println(list[0])     // \"First\"\n</code></pre>"},{"location":"getting-started/quick-start/#classes-and-objects","title":"Classes and Objects","text":""},{"location":"getting-started/quick-start/#basic-class","title":"Basic Class","text":"<pre><code>class Person {\n  val name: String\n  var age: Int\n\n  public:\n    def this(n: String, a: Int) {\n      this.name = n\n      this.age = a\n    }\n\n    def greet: String = \"Hello, I'm \" + this.name\n}\n\nval person: Person = new Person(\"Alice\", 30)\nIO::println(person.greet)\n</code></pre> <p>Key points: - Fields are accessed via <code>this.field</code> - Members are private by default - Use <code>public:</code> to mark public members - <code>def this</code> declares a constructor</p>"},{"location":"getting-started/quick-start/#inheritance","title":"Inheritance","text":"<pre><code>import {\n  java.util.List;\n  java.util.ArrayList;\n}\n\nclass MyList &lt;: List {\n  forward val internal: List;\n\n  public:\n    def this {\n      this.internal = new ArrayList;\n    }\n}\n</code></pre> <p>Syntax: - <code>class Child : Parent</code> - extends a class - <code>class Impl &lt;: Interface</code> - implements an interface - <code>class Multi : Parent &lt;: Interface</code> - both</p>"},{"location":"getting-started/quick-start/#java-interoperability","title":"Java Interoperability","text":"<p>Onion has seamless access to Java libraries:</p> <pre><code>import {\n  java.io.File;\n  javax.swing.JFrame;\n  javax.swing.JButton;\n}\n\nval frame: JFrame = new JFrame(\"My Window\")\nframe.setSize(400, 300)\nframe.setVisible(true)\n\nval file: File = new File(\"data.txt\")\nif file.exists {\n  IO::println(\"File exists!\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#common-java-classes","title":"Common Java Classes","text":"<pre><code>// Math operations\nval random: Double = Math::random()\nval sqrt: Double = Math::sqrt(16.0)\n\n// String operations\nval upper: String = \"hello\".toUpperCase()\nval length: Int = \"hello\".length\n\n// Parsing\nval num: Int = JInteger::parseInt(\"42\")\n</code></pre>"},{"location":"getting-started/quick-start/#exception-handling","title":"Exception Handling","text":"<pre><code>try {\n  val value: Int = JInteger::parseInt(\"not a number\")\n  IO::println(value)\n} catch e :NumberFormatException {\n  IO::println(\"Invalid number format: \" + e.getMessage)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#type-casting","title":"Type Casting","text":"<p>Use the <code>$</code> operator for type casting:</p> <pre><code>val random: Double = Math::random()\nval randomInt: Int = (random * 100)$Int\n\nval obj: Object = \"Hello\"\nval str: String = obj$String\n</code></pre>"},{"location":"getting-started/quick-start/#module-system","title":"Module System","text":"<pre><code>// Import Java classes\nimport {\n  java.util.ArrayList;\n  java.util.HashMap;\n  java.io.File;\n}\n\n// Use fully qualified names without import\nval list: java.util.ArrayList = new java.util.ArrayList\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Language Guide - Deep dive into language features</li> <li>Examples - More complete program examples</li> <li>Tools Reference - Learn about compiler options</li> </ul>"},{"location":"guide/basic-syntax/","title":"Basic Syntax","text":"<p>This guide covers the fundamental syntax elements of the Onion programming language.</p>"},{"location":"guide/basic-syntax/#comments","title":"Comments","text":"<p>Currently, Onion supports C-style comments:</p> <pre><code>// Single-line comment\n\n/*\n * Multi-line comment\n * Spans multiple lines\n */\n</code></pre>"},{"location":"guide/basic-syntax/#variables","title":"Variables","text":""},{"location":"guide/basic-syntax/#variable-declaration","title":"Variable Declaration","text":"<p>Variables are declared with <code>val</code> (immutable) or <code>var</code> (mutable). Local declarations can omit the type when an initializer is present; otherwise provide an explicit type:</p> <pre><code>val name = \"Alice\"\nvar count = 0\nval age: Int = 30\nval price: Double = 19.99\nval isActive: Boolean = true\n</code></pre> <p>Assignments update existing variables; they do not declare new ones.</p>"},{"location":"guide/basic-syntax/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Variable names use camelCase: <code>firstName</code>, <code>totalCount</code></li> <li>Class names use PascalCase: <code>Person</code>, <code>Calculator</code></li> <li>Fields are accessed via <code>this.field</code></li> </ul>"},{"location":"guide/basic-syntax/#primitive-types","title":"Primitive Types","text":"<p>Onion supports the standard JVM primitive types:</p> Type Description Example <code>Int</code> 32-bit integer <code>42</code> <code>Long</code> 64-bit integer <code>42L</code> <code>Double</code> 64-bit floating point <code>3.14</code> <code>Float</code> 32-bit floating point <code>3.14f</code> <code>Boolean</code> true or false <code>true</code>, <code>false</code> <code>Char</code> Single character <code>'A'</code> <code>Byte</code> 8-bit integer <code>127</code> <code>Short</code> 16-bit integer <code>1000</code>"},{"location":"guide/basic-syntax/#literals","title":"Literals","text":""},{"location":"guide/basic-syntax/#string-literals","title":"String Literals","text":"<pre><code>val greeting: String = \"Hello, World!\"\nval multiline: String = \"Line 1\\nLine 2\\nLine 3\"\nval withQuotes: String = \"She said \\\"Hello\\\"\"\n</code></pre>"},{"location":"guide/basic-syntax/#numeric-literals","title":"Numeric Literals","text":"<pre><code>val decimal: Int = 42\nval hex: Int = 0xFF\nval octal: Int = 077\nval longValue: Long = 100L\nval doubleValue: Double = 3.14\nval scientific: Double = 1.23e10\n</code></pre>"},{"location":"guide/basic-syntax/#character-literals","title":"Character Literals","text":"<pre><code>val letter: Char = 'A'\nval newline: Char = '\\n'\nval tab: Char = '\\t'\n</code></pre>"},{"location":"guide/basic-syntax/#boolean-literals","title":"Boolean Literals","text":"<pre><code>val isTrue: Boolean = true\nval isFalse: Boolean = false\n</code></pre>"},{"location":"guide/basic-syntax/#null-literal","title":"Null Literal","text":"<pre><code>val nullable: String = null\n</code></pre>"},{"location":"guide/basic-syntax/#operators","title":"Operators","text":""},{"location":"guide/basic-syntax/#arithmetic-operators","title":"Arithmetic Operators","text":"<pre><code>val a: Int = 10\nval b: Int = 3\n\nval sum: Int = a + b        // 13\nval diff: Int = a - b       // 7\nval product: Int = a * b    // 30\nval quotient: Int = a / b   // 3\nval remainder: Int = a % b  // 1\n</code></pre>"},{"location":"guide/basic-syntax/#comparison-operators","title":"Comparison Operators","text":"<pre><code>val x: Int = 5\nval y: Int = 10\n\nx == y  // false (equal)\nx != y  // true  (not equal)\nx &lt; y   // true  (less than)\nx &gt; y   // false (greater than)\nx &lt;= y  // true  (less than or equal)\nx &gt;= y  // false (greater than or equal)\n</code></pre>"},{"location":"guide/basic-syntax/#logical-operators","title":"Logical Operators","text":"<pre><code>val a: Boolean = true\nval b: Boolean = false\n\na &amp;&amp; b  // false (logical AND)\na || b  // true  (logical OR)\n!a      // false (logical NOT)\n</code></pre>"},{"location":"guide/basic-syntax/#assignment-operators","title":"Assignment Operators","text":"<pre><code>var x: Int = 10\n\nx = 20       // Simple assignment\nx = x + 5    // Add and assign (no += syntax yet)\nx = x - 3    // Subtract and assign\nx = x * 2    // Multiply and assign\n</code></pre>"},{"location":"guide/basic-syntax/#incrementdecrement","title":"Increment/Decrement","text":"<pre><code>var count: Int = 0\ncount = count + 1  // Increment\n// Or use post-increment (in some contexts)\ncount++\ncount--\n</code></pre>"},{"location":"guide/basic-syntax/#type-casting-operator","title":"Type Casting Operator","text":"<p>The <code>$</code> operator performs type casting:</p> <pre><code>val x: Double = 3.14\nval y: Int = x$Int  // Cast to Int (3)\n\nval random: Double = Math::random()\nval randomInt: Int = (random * 100)$Int\n</code></pre>"},{"location":"guide/basic-syntax/#list-append-operator","title":"List Append Operator","text":"<p>The <code>&lt;&lt;</code> operator appends to lists:</p> <pre><code>import { java.util.ArrayList; }\n\nval list: ArrayList = new ArrayList\nlist &lt;&lt; \"First\"\nlist &lt;&lt; \"Second\"\nlist &lt;&lt; \"Third\"\n</code></pre>"},{"location":"guide/basic-syntax/#arrays","title":"Arrays","text":""},{"location":"guide/basic-syntax/#array-declaration","title":"Array Declaration","text":"<pre><code>// Create array with size\nval numbers: Int[] = new Int[10]\n\n// Initialize elements\nval colors: String[] = new String[3]\ncolors[0] = \"red\"\ncolors[1] = \"green\"\ncolors[2] = \"blue\"\n\nval scores: Double[] = new Double[5]\nscores[0] = 95.5\nscores[1] = 87.3\n</code></pre>"},{"location":"guide/basic-syntax/#array-access","title":"Array Access","text":"<pre><code>val fruits: String[] = new String[3]\nfruits[0] = \"apple\"\nfruits[1] = \"banana\"\nfruits[2] = \"orange\"\n\nval first: String = fruits[0]     // \"apple\"\nval second: String = fruits[1]    // \"banana\"\n\nfruits[2] = \"grape\"  // Modify element\n\nval length: Int = fruits.length  // Array length\n</code></pre>"},{"location":"guide/basic-syntax/#expressions","title":"Expressions","text":""},{"location":"guide/basic-syntax/#arithmetic-expressions","title":"Arithmetic Expressions","text":"<pre><code>val result: Int = (10 + 5) * 2 - 3  // 27\nval average: Double = (10 + 20 + 30) / 3.0\n</code></pre>"},{"location":"guide/basic-syntax/#string-concatenation","title":"String Concatenation","text":"<pre><code>val firstName: String = \"Alice\"\nval lastName: String = \"Smith\"\nval fullName: String = firstName + \" \" + lastName\n\nval age: Int = 30\nval message: String = \"I am \" + age + \" years old\"\n</code></pre>"},{"location":"guide/basic-syntax/#method-calls","title":"Method Calls","text":"<pre><code>// Static method call\nIO::println(\"Hello\")\n\n// Instance method call\nval text: String = \"hello\"\nval upper: String = text.toUpperCase()\nval len: Int = text.length\n</code></pre>"},{"location":"guide/basic-syntax/#object-creation","title":"Object Creation","text":"<pre><code>import { java.util.ArrayList; }\n\nval list: ArrayList = new ArrayList\nval array: String[] = new String[10]\n</code></pre>"},{"location":"guide/basic-syntax/#statements","title":"Statements","text":""},{"location":"guide/basic-syntax/#expression-statements","title":"Expression Statements","text":"<p>Any expression can be a statement:</p> <pre><code>IO::println(\"Hello\")\nvar x: Int = 10\nx = x + 1\n</code></pre>"},{"location":"guide/basic-syntax/#block-statements","title":"Block Statements","text":"<p>Blocks are enclosed in curly braces:</p> <pre><code>{\n  val temp: Int = 5\n  IO::println(temp)\n  // temp is only visible in this block\n}\n</code></pre>"},{"location":"guide/basic-syntax/#scope-and-visibility","title":"Scope and Visibility","text":""},{"location":"guide/basic-syntax/#local-variables","title":"Local Variables","text":"<p>Variables declared in a method or block are local to that scope:</p> <pre><code>def method {\n  val local: Int = 10\n  // local is only visible here\n}\n</code></pre>"},{"location":"guide/basic-syntax/#fields","title":"Fields","text":"<p>Fields are declared with <code>val</code> / <code>var</code> and accessed via <code>this.field</code>:</p> <pre><code>class Example {\n  var count: Int\n  val name: String = \"default\"\n\n  public:\n    def increment {\n      this.count = this.count + 1\n    }\n}\n</code></pre>"},{"location":"guide/basic-syntax/#access-modifiers","title":"Access Modifiers","text":"<p>By default, members are private. Use <code>public:</code> to mark public members:</p> <pre><code>class Person {\n  val ssn: String = \"000-00-0000\"  // Private by default\n\n  public:\n    val name: String = \"Alice\"  // Public\n\n    def getName: String = this.name  // Public method\n}\n</code></pre>"},{"location":"guide/basic-syntax/#module-system","title":"Module System","text":""},{"location":"guide/basic-syntax/#import-statements","title":"Import Statements","text":"<p>Import Java classes for use in your Onion code:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.HashMap;\n  java.io.File;\n}\n\nval list: ArrayList = new ArrayList\nval map: HashMap = new HashMap\nval file: File = new File(\"data.txt\")\n</code></pre>"},{"location":"guide/basic-syntax/#fully-qualified-names","title":"Fully Qualified Names","text":"<p>You can also use fully qualified names without importing:</p> <pre><code>val list: java.util.ArrayList = new java.util.ArrayList\n</code></pre>"},{"location":"guide/basic-syntax/#next-steps","title":"Next Steps","text":"<ul> <li>Variables and Types - Deep dive into the type system</li> <li>Control Flow - Conditionals and loops</li> <li>Functions - Function definitions and lambdas</li> </ul>"},{"location":"guide/classes-and-objects/","title":"Classes and Objects","text":"<p>Onion is an object-oriented language with full support for classes, inheritance, and interfaces.</p>"},{"location":"guide/classes-and-objects/#class-definition","title":"Class Definition","text":""},{"location":"guide/classes-and-objects/#basic-class","title":"Basic Class","text":"<p>Define a class with the <code>class</code> keyword:</p> <pre><code>class Person {\n  val name: String\n  var age: Int\n\n  public:\n    def this(n: String, a: Int) {\n      this.name = n\n      this.age = a\n    }\n\n    def greet: String = \"Hello, I'm \" + this.name\n}\n</code></pre>"},{"location":"guide/classes-and-objects/#creating-objects","title":"Creating Objects","text":"<p>Instantiate objects with the <code>new</code> keyword:</p> <pre><code>val person: Person = new Person(\"Alice\", 30)\nIO::println(person.greet())  // \"Hello, I'm Alice\"\n</code></pre>"},{"location":"guide/classes-and-objects/#fields","title":"Fields","text":""},{"location":"guide/classes-and-objects/#instance-fields","title":"Instance Fields","text":"<p>Declare instance fields with <code>val</code> (immutable) or <code>var</code> (mutable), and access them via <code>this.field</code>:</p> <pre><code>class Counter {\n  var count: Int\n\n  public:\n    def this {\n      this.count = 0\n    }\n\n    def increment {\n      this.count = this.count + 1\n    }\n\n    def getCount: Int = this.count\n}\n</code></pre>"},{"location":"guide/classes-and-objects/#access-modifiers","title":"Access Modifiers","text":"<p>Members are private by default. Use <code>public:</code> to mark public members:</p> <pre><code>class BankAccount {\n  var balance: Double  // Private (default)\n  val accountNumber: String  // Private\n\n  public:\n    val owner: String  // Public\n\n    def this(owner: String, initial: Double) {\n      this.owner = owner\n      this.balance = initial\n      this.accountNumber = \"UNKNOWN\"\n    }\n\n    def deposit(amount :Double) {  // Public method\n      this.balance = this.balance + amount\n    }\n\n    def getBalance: Double = this.balance  // Public method\n}\n</code></pre>"},{"location":"guide/classes-and-objects/#static-members","title":"Static Members","text":"<p>Static members belong to the class, not instances:</p> <pre><code>class MathUtils {\n  static val PI: Double = 3.14159\n\n  public:\n    static def square(x: Double): Double = x * x\n\n    static def circleArea(radius: Double): Double = MathUtils::PI * radius * radius\n}\n\n// Access static members with ::\nval pi: Double = MathUtils::PI\nval area: Double = MathUtils::circleArea(5.0)\n</code></pre>"},{"location":"guide/classes-and-objects/#constructors","title":"Constructors","text":""},{"location":"guide/classes-and-objects/#default-constructor","title":"Default Constructor","text":"<p>Define constructors with <code>def this</code>:</p> <pre><code>class Point {\n  val x: Int\n  val y: Int\n\n  public:\n    def this(x: Int, y: Int) {\n      this.x = x\n      this.y = y\n    }\n}\n\nval point: Point = new Point(10, 20)\n</code></pre>"},{"location":"guide/classes-and-objects/#multiple-constructors","title":"Multiple Constructors","text":"<p>Overload constructors for different initialization patterns:</p> <pre><code>class Rectangle {\n  val width: Int\n  val height: Int\n\n  public:\n    def this {\n      this.width = 0\n      this.height = 0\n    }\n\n    def this(size: Int) {\n      this.width = size\n      this.height = size\n    }\n\n    def this(w: Int, h: Int) {\n      this.width = w\n      this.height = h\n    }\n}\n\nval rect1: Rectangle = new Rectangle()\nval rect2: Rectangle = new Rectangle(10)\nval rect3: Rectangle = new Rectangle(10, 20)\n</code></pre>"},{"location":"guide/classes-and-objects/#calling-super-constructors","title":"Calling Super Constructors","text":"<p>To call a superclass constructor, add a super-initializer list: <code>def this(args): (superArgs) { ... }</code>.</p>"},{"location":"guide/classes-and-objects/#methods","title":"Methods","text":""},{"location":"guide/classes-and-objects/#instance-methods","title":"Instance Methods","text":"<p>Methods that operate on instance data:</p> <pre><code>class Circle {\n  val radius: Double\n\n  public:\n    def this(r: Double) {\n      this.radius = r\n    }\n\n    def area: Double = 3.14159 * this.radius * this.radius\n\n    def circumference: Double = 2.0 * 3.14159 * this.radius\n}\n\nval circle: Circle = new Circle(5.0)\nIO::println(\"Area: \" + circle.area())\n</code></pre>"},{"location":"guide/classes-and-objects/#method-overloading","title":"Method Overloading","text":"<p>Multiple methods with the same name but different parameters:</p> <pre><code>class Printer {\n  public:\n    def print(value :Int) {\n      IO::println(\"Int: \" + value)\n    }\n\n    def print(value :String) {\n      IO::println(\"String: \" + value)\n    }\n\n    def print(value :Double) {\n      IO::println(\"Double: \" + value)\n    }\n}\n\nval printer: Printer = new Printer\nprinter.print(42)\nprinter.print(\"Hello\")\nprinter.print(3.14)\n</code></pre>"},{"location":"guide/classes-and-objects/#getter-and-setter-methods","title":"Getter and Setter Methods","text":"<pre><code>class Person {\n  var name: String\n  var age: Int\n\n  public:\n    def getName: String = this.name\n\n    def setName(name :String) {\n      this.name = name\n    }\n\n    def getAge: Int = this.age\n\n    def setAge(age :Int) {\n      if age &gt;= 0 {\n        this.age = age\n      }\n    }\n}\n</code></pre>"},{"location":"guide/classes-and-objects/#the-self-reference","title":"The <code>self</code> Reference","text":"<p>Access the current instance with <code>self</code>:</p> <pre><code>import {\n  javax.swing.JButton;\n  java.awt.event.ActionEvent;\n  java.awt.event.ActionListener;\n}\n\nclass ButtonHandler &lt;: ActionListener {\n  public:\n    def actionPerformed(event :ActionEvent) {\n      val button: JButton = event.getSource()$JButton\n      button.addActionListener(self)  // Reference to this instance\n    }\n}\n</code></pre>"},{"location":"guide/classes-and-objects/#next-steps","title":"Next Steps","text":"<ul> <li>Inheritance - Extending classes and implementing interfaces</li> <li>Java Interoperability - Working with Java classes</li> <li>Examples - Object-oriented examples</li> </ul>"},{"location":"guide/control-flow/","title":"Control Flow","text":"<p>Onion provides several control flow constructs for conditionals, loops, and pattern matching.</p>"},{"location":"guide/control-flow/#conditional-statements","title":"Conditional Statements","text":""},{"location":"guide/control-flow/#control-flow-as-expressions","title":"Control Flow as Expressions","text":"<p>Control-flow forms are expressions. Blocks evaluate to the last expression, and <code>return</code>/<code>throw</code>/<code>break</code>/<code>continue</code> are typed as bottom (they never produce a value). Loops evaluate to <code>void</code>.</p> <pre><code>val label: String = if age &gt;= 18 { \"Adult\" } else { \"Minor\" }\n\nval word: String = {\n  val base = \"a\"\n  base + \"!\"\n}\n</code></pre>"},{"location":"guide/control-flow/#if-else","title":"If-Else","text":"<p>Basic conditional execution:</p> <pre><code>val age: Int = 18\n\nif age &gt;= 18 {\n  IO::println(\"Adult\")\n} else {\n  IO::println(\"Minor\")\n}\n</code></pre>"},{"location":"guide/control-flow/#if-else-if-else","title":"If-Else If-Else","text":"<p>Multiple conditions:</p> <pre><code>val score: Int = 85\n\nif score &gt;= 90 {\n  IO::println(\"Grade: A\")\n} else if score &gt;= 80 {\n  IO::println(\"Grade: B\")\n} else if score &gt;= 70 {\n  IO::println(\"Grade: C\")\n} else if score &gt;= 60 {\n  IO::println(\"Grade: D\")\n} else {\n  IO::println(\"Grade: F\")\n}\n</code></pre>"},{"location":"guide/control-flow/#assignment-in-conditions","title":"Assignment in Conditions","text":"<p>You can assign and test in one expression:</p> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.InputStreamReader;\n}\n\nval reader: BufferedReader = new BufferedReader(\n  new InputStreamReader(System::in)\n)\n\nvar line: String = null\nwhile (line = reader.readLine()) != null {\n  IO::println(\"Read: \" + line)\n}\n</code></pre>"},{"location":"guide/control-flow/#loops","title":"Loops","text":""},{"location":"guide/control-flow/#while-loop","title":"While Loop","text":"<p>Execute while a condition is true:</p> <pre><code>var count: Int = 0\nwhile count &lt; 5 {\n  IO::println(\"Count: \" + count)\n  count = count + 1\n}\n</code></pre> <p>Output: <pre><code>Count: 0\nCount: 1\nCount: 2\nCount: 3\nCount: 4\n</code></pre></p>"},{"location":"guide/control-flow/#for-loop","title":"For Loop","text":"<p>Traditional C-style for loop:</p> <pre><code>for var i: Int = 0; i &lt; 10; i = i + 1 {\n  IO::println(i)\n}\n</code></pre> <p>Syntax: <code>for init; condition; update { body }</code></p>"},{"location":"guide/control-flow/#foreach-loop","title":"Foreach Loop","text":"<p>Iterate over arrays and collections:</p> <pre><code>val fruits: String[] = new String[3]\nfruits[0] = \"apple\"\nfruits[1] = \"banana\"\nfruits[2] = \"cherry\"\n\nforeach fruit :String in fruits {\n  IO::println(\"Fruit: \" + fruit)\n}\n</code></pre> <p>With collections:</p> <pre><code>import { java.util.ArrayList; }\n\nval list: ArrayList = new ArrayList\nlist &lt;&lt; \"First\"\nlist &lt;&lt; \"Second\"\nlist &lt;&lt; \"Third\"\n\nforeach item :Object in list {\n  IO::println(item$String)\n}\n</code></pre>"},{"location":"guide/control-flow/#pattern-matching","title":"Pattern Matching","text":""},{"location":"guide/control-flow/#select-statement","title":"Select Statement","text":"<p>Switch-style pattern matching with multiple values per case:</p> <pre><code>val day: Int = 3\n\nselect day {\n  case 1:\n    IO::println(\"Monday\")\n  case 2:\n    IO::println(\"Tuesday\")\n  case 3:\n    IO::println(\"Wednesday\")\n  case 4:\n    IO::println(\"Thursday\")\n  case 5:\n    IO::println(\"Friday\")\n  case 6, 7:\n    IO::println(\"Weekend\")\n  else:\n    IO::println(\"Invalid day\")\n}\n</code></pre> <p>Select can also produce a value:</p> <pre><code>val grade: String = select score {\n  case 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100:\n    \"A\"\n  case 80, 81, 82, 83, 84, 85, 86, 87, 88, 89:\n    \"B\"\n  else:\n    \"F\"\n}\n</code></pre>"},{"location":"guide/control-flow/#multiple-values-per-case","title":"Multiple Values Per Case","text":"<p>Group multiple values in a single case:</p> <pre><code>val num: Int = (Math::random() * 10)$Int\n\nselect num {\n  case 0, 1, 2, 3:\n    IO::println(\"Low\")\n  case 4, 5, 6:\n    IO::println(\"Medium\")\n  case 7, 8, 9:\n    IO::println(\"High\")\n  else:\n    IO::println(\"Other\")\n}\n</code></pre>"},{"location":"guide/control-flow/#select-with-expressions","title":"Select with Expressions","text":"<pre><code>val score: Int = 85\nvar grade: String = null\n\nselect score {\n  case 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100:\n    grade = \"A\"\n  case 80, 81, 82, 83, 84, 85, 86, 87, 88, 89:\n    grade = \"B\"\n  case 70, 71, 72, 73, 74, 75, 76, 77, 78, 79:\n    grade = \"C\"\n  else:\n    grade = \"F\"\n}\n\nIO::println(\"Grade: \" + grade)\n</code></pre>"},{"location":"guide/control-flow/#break-and-continue","title":"Break and Continue","text":""},{"location":"guide/control-flow/#break-statement","title":"Break Statement","text":"<p>Exit a loop early:</p> <pre><code>var i: Int = 0\nwhile true {\n  if i &gt;= 5 {\n    break\n  }\n  IO::println(i)\n  i = i + 1\n}\n</code></pre>"},{"location":"guide/control-flow/#continue-statement","title":"Continue Statement","text":"<p>Skip to the next iteration:</p> <pre><code>for var i: Int = 0; i &lt; 10; i = i + 1 {\n  if i % 2 == 0 {\n    continue  // Skip even numbers\n  }\n  IO::println(i)  // Print odd numbers only\n}\n</code></pre> <p>Output: <code>1 3 5 7 9</code></p>"},{"location":"guide/control-flow/#exception-handling","title":"Exception Handling","text":""},{"location":"guide/control-flow/#try-catch","title":"Try-Catch","text":"<p>Handle exceptions with try-catch blocks:</p> <pre><code>import { java.lang.NumberFormatException; }\n\nval input: String = \"not a number\"\n\ntry {\n  val number: Int = JInteger::parseInt(input)\n  IO::println(\"Parsed: \" + number)\n} catch e :NumberFormatException {\n  IO::println(\"Invalid number: \" + e.getMessage())\n}\n</code></pre>"},{"location":"guide/control-flow/#multiple-catch-blocks","title":"Multiple Catch Blocks","text":"<pre><code>import {\n  java.io.FileReader;\n  java.io.FileNotFoundException;\n  java.io.IOException;\n}\n\ntry {\n  val reader: FileReader = new FileReader(\"file.txt\")\n  // Use reader...\n} catch e :FileNotFoundException {\n  IO::println(\"File not found: \" + e.getMessage())\n} catch e :IOException {\n  IO::println(\"IO error: \" + e.getMessage())\n}\n</code></pre>"},{"location":"guide/control-flow/#accessing-exception-information","title":"Accessing Exception Information","text":"<pre><code>try {\n  val result: Int = 10 / 0\n} catch e :ArithmeticException {\n  IO::println(\"Error: \" + e.getMessage())\n  IO::println(\"Type: \" + e.getClass().getName())\n}\n</code></pre>"},{"location":"guide/control-flow/#control-flow-best-practices","title":"Control Flow Best Practices","text":""},{"location":"guide/control-flow/#early-return","title":"Early Return","text":"<p>Use early returns to reduce nesting:</p> <pre><code>def processData(data :String) :Int {\n  if data == null {\n    return 0\n  }\n\n  if data.length() == 0 {\n    return 0\n  }\n\n  // Process data...\n  return data.length()\n}\n</code></pre>"},{"location":"guide/control-flow/#guard-clauses","title":"Guard Clauses","text":"<p>Validate preconditions early:</p> <pre><code>def divide(a :Int, b :Int) :Int {\n  if b == 0 {\n    IO::println(\"Error: Division by zero\")\n    return 0\n  }\n\n  return a / b\n}\n</code></pre>"},{"location":"guide/control-flow/#avoid-deep-nesting","title":"Avoid Deep Nesting","text":"<p>Prefer flat code over deeply nested conditions:</p> <pre><code>// Bad: Deep nesting\nif condition1 {\n  if condition2 {\n    if condition3 {\n      // Code here\n    }\n  }\n}\n\n// Good: Early returns or guard clauses\nif !condition1 { return }\nif !condition2 { return }\nif !condition3 { return }\n// Code here\n</code></pre>"},{"location":"guide/control-flow/#next-steps","title":"Next Steps","text":"<ul> <li>Functions - Function definitions and lambdas</li> <li>Classes and Objects - OOP in Onion</li> <li>Examples - See control flow in action</li> </ul>"},{"location":"guide/functions/","title":"Functions","text":"<p>Functions in Onion allow you to encapsulate reusable code. Onion supports both named functions (methods) and anonymous functions (lambdas).</p>"},{"location":"guide/functions/#function-definitions","title":"Function Definitions","text":""},{"location":"guide/functions/#basic-function","title":"Basic Function","text":"<p>Define functions with the <code>def</code> keyword:</p> <pre><code>def greet(name: String): String = \"Hello, \" + name + \"!\"\n\nval message: String = greet(\"Alice\")\nIO::println(message)  // \"Hello, Alice!\"\n</code></pre>"},{"location":"guide/functions/#function-with-multiple-parameters","title":"Function with Multiple Parameters","text":"<pre><code>def add(a: Int, b: Int): Int = a + b\n\nval sum: Int = add(5, 3)\nIO::println(sum)  // 8\n</code></pre>"},{"location":"guide/functions/#function-with-no-parameters","title":"Function with No Parameters","text":"<pre><code>def getCurrentTime: String = System::currentTimeMillis()$String\n\nIO::println(getCurrentTime())\n</code></pre>"},{"location":"guide/functions/#function-with-no-return-value","title":"Function with No Return Value","text":"<p>Functions that don't return a value implicitly return nothing:</p> <pre><code>def printMessage(msg :String) {\n  IO::println(\"Message: \" + msg)\n}\n\nprintMessage(\"Hello\")\n</code></pre>"},{"location":"guide/functions/#return-statements","title":"Return Statements","text":""},{"location":"guide/functions/#explicit-return","title":"Explicit Return","text":"<p>Use <code>return</code> to exit a function early:</p> <pre><code>def max(a :Int, b :Int) :Int {\n  if a &gt; b {\n    return a\n  }\n  return b\n}\n</code></pre>"},{"location":"guide/functions/#expression-body","title":"Expression Body","text":"<p>For concise functions, prefer an expression body using <code>=</code>:</p> <pre><code>def square(x: Int): Int = x * x\n</code></pre>"},{"location":"guide/functions/#lambda-expressions","title":"Lambda Expressions","text":""},{"location":"guide/functions/#lambda-syntax","title":"Lambda Syntax","text":"<p>Anonymous functions use the <code>(params) -&gt; { body }</code> syntax:</p> <pre><code>val double: (Int) -&gt; Int = (x: Int) -&gt; { return x * 2; }\n\nval result: Int = double.call(5)  // 10\n</code></pre>"},{"location":"guide/functions/#lambda-with-multiple-parameters","title":"Lambda with Multiple Parameters","text":"<pre><code>val add: (Int, Int) -&gt; Int = (x: Int, y: Int) -&gt; { return x + y; }\n\nval sum: Int = add.call(3, 7)  // 10\n</code></pre>"},{"location":"guide/functions/#lambda-with-no-parameters","title":"Lambda with No Parameters","text":"<pre><code>val sayHello: () -&gt; String = () -&gt; { IO::println(\"Hello!\"); return \"done\"; }\n\nsayHello.call()\n</code></pre>"},{"location":"guide/functions/#closures","title":"Closures","text":"<p>Lambdas can capture variables from their enclosing scope:</p> <pre><code>def makeCounter(): () -&gt; Int {\n  var count: Int = 0\n  return () -&gt; {\n    count = count + 1\n    return count;\n  };\n}\n\nval counter: () -&gt; Int = makeCounter()\nIO::println(counter.call())  // 1\nIO::println(counter.call())  // 2\nIO::println(counter.call())  // 3\n</code></pre>"},{"location":"guide/functions/#capturing-loop-variables","title":"Capturing Loop Variables","text":"<pre><code>var i: Int = 0\nval filter: (String) -&gt; String = (line: String) -&gt; {\n  i = i + 1\n  return line + \" (line \" + i + \")\";\n}\n\nIO::println(filter.call(\"First\"))   // \"First (line 1)\"\nIO::println(filter.call(\"Second\"))  // \"Second (line 2)\"\n</code></pre>"},{"location":"guide/functions/#function-types","title":"Function Types","text":"<p>You can either use the <code>Function0</code> through <code>Function10</code> interfaces, or the arrow type syntax <code>(A, B) -&gt; R</code> (for a single parameter, parentheses are optional: <code>A -&gt; R</code>):</p> <pre><code>// Function with 1 parameter\nval func1: Int -&gt; Int = (x: Int) -&gt; { return x * 2; }\n\n// Function with 2 parameters\nval func2: (Int, Int) -&gt; Int = (x: Int, y: Int) -&gt; { return x + y; }\n\n// Function with no parameters\nval func0: () -&gt; Int = () -&gt; { return 42; }\n</code></pre> <p>The number indicates the parameter count: - <code>Function0</code> - No parameters - <code>Function1</code> - One parameter - <code>Function2</code> - Two parameters - ... up to <code>Function10</code> - Ten parameters</p>"},{"location":"guide/functions/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Functions that accept or return other functions:</p> <pre><code>def applyTwice(f: (Int) -&gt; Int, value: Int): Int {\n  val temp: Int = f.call(value)\n  return f.call(temp)\n}\n\nval increment: (Int) -&gt; Int = (x: Int) -&gt; { return x + 1; }\nval result: Int = applyTwice(increment, 5)  // 7\n</code></pre>"},{"location":"guide/functions/#recursive-functions","title":"Recursive Functions","text":"<p>Functions can call themselves:</p> <pre><code>def factorial(n :Int) :Int {\n  if n &lt;= 1 {\n    return 1\n  }\n  return n * factorial(n - 1)\n}\n\nIO::println(factorial(5))  // 120\n</code></pre>"},{"location":"guide/functions/#tail-recursion","title":"Tail Recursion","text":"<p>While Onion doesn't optimize tail calls, you can write tail-recursive functions:</p> <pre><code>def factorialTail(n :Int, acc :Int) :Int {\n  if n &lt;= 1 {\n    return acc\n  }\n  return factorialTail(n - 1, n * acc)\n}\n\ndef factorial(n :Int) :Int {\n  return factorialTail(n, 1)\n}\n\nIO::println(factorial(5))  // 120\n</code></pre>"},{"location":"guide/functions/#method-overloading","title":"Method Overloading","text":"<p>Classes can have multiple methods with the same name but different parameter types:</p> <pre><code>class Calculator {\n  public:\n    def add(a: Int, b: Int): Int = a + b\n\n    def add(a: Double, b: Double): Double = a + b\n\n    def add(a: String, b: String): String = a + b\n}\n\nval calc: Calculator = new Calculator\nIO::println(calc.add(5, 3))           // 8\nIO::println(calc.add(2.5, 3.7))       // 6.2\nIO::println(calc.add(\"Hello\", \"!\"))   // \"Hello!\"\n</code></pre>"},{"location":"guide/functions/#static-methods","title":"Static Methods","text":"<p>Methods can be static (class-level) rather than instance-level:</p> <pre><code>class MathUtils {\n  public:\n    static def square(x: Int): Int = x * x\n\n    static def cube(x: Int): Int = x * x * x\n}\n\n// Call static methods with ::\nIO::println(MathUtils::square(5))  // 25\nIO::println(MathUtils::cube(3))    // 27\n</code></pre>"},{"location":"guide/functions/#function-examples","title":"Function Examples","text":""},{"location":"guide/functions/#filter-function","title":"Filter Function","text":"<pre><code>import {\n  java.util.ArrayList;\n  java.util.List;\n}\n\ndef filterLines(lines: List, predicate: (String) -&gt; Boolean): List {\n  val result: ArrayList = new ArrayList\n\n  foreach line: String in lines {\n    if predicate.call(line) {\n      result &lt;&lt; line\n    }\n  }\n\n  return result\n}\n\nval startsWithError: (String) -&gt; Boolean = (line: String) -&gt; { return line.startsWith(\"ERROR\"); }\n\nval lines: List = [\"INFO: OK\", \"ERROR: Failed\", \"ERROR: Timeout\"]\nval errors: List = filterLines(lines, startsWithError)\n</code></pre>"},{"location":"guide/functions/#map-function","title":"Map Function","text":"<pre><code>import {\n  java.util.ArrayList;\n  java.util.List;\n}\n\ndef mapLines(lines: List, transform: (String) -&gt; String): List {\n  val result: ArrayList = new ArrayList\n\n  foreach line: String in lines {\n    result &lt;&lt; transform.call(line)\n  }\n\n  return result\n}\n\nval toUpper: (String) -&gt; String = (s: String) -&gt; { return s.toUpperCase(); }\n\nval lines: List = [\"hello\", \"world\"]\nval upper: List = mapLines(lines, toUpper)\n</code></pre>"},{"location":"guide/functions/#best-practices","title":"Best Practices","text":""},{"location":"guide/functions/#single-responsibility","title":"Single Responsibility","text":"<p>Each function should do one thing well:</p> <pre><code>// Good: Each function has a single purpose\ndef readFile(path :String) :String { ... }\ndef parseData(content :String) :Data { ... }\ndef validateData(data :Data) :Boolean { ... }\n\n// Bad: Function does too much\ndef processFile(path :String) :Boolean {\n  // Reads, parses, validates, and saves\n  ...\n}\n</code></pre>"},{"location":"guide/functions/#descriptive-names","title":"Descriptive Names","text":"<p>Use clear, descriptive function names:</p> <pre><code>// Good\ndef calculateTotalPrice(items :Item[]) :Double { ... }\ndef isValidEmail(email :String) :Boolean { ... }\n\n// Bad\ndef calc(arr :Item[]) :Double { ... }\ndef check(s :String) :Boolean { ... }\n</code></pre>"},{"location":"guide/functions/#keep-functions-short","title":"Keep Functions Short","text":"<p>Aim for functions that fit on one screen:</p> <pre><code>def processOrder(order :Order) :Boolean {\n  if !validateOrder(order) {\n    return false\n  }\n\n  if !chargePayment(order) {\n    return false\n  }\n\n  if !shipOrder(order) {\n    return false\n  }\n\n  true\n}\n</code></pre>"},{"location":"guide/functions/#next-steps","title":"Next Steps","text":"<ul> <li>Classes and Objects - Methods in classes</li> <li>Lambda Expressions - Deep dive into lambdas</li> <li>Examples - Functional programming examples</li> </ul>"},{"location":"guide/inheritance/","title":"Inheritance","text":"<p>Onion supports both class inheritance and interface implementation, allowing you to build hierarchical type systems.</p>"},{"location":"guide/inheritance/#extending-classes","title":"Extending Classes","text":""},{"location":"guide/inheritance/#basic-inheritance","title":"Basic Inheritance","text":"<p>Use <code>:</code> to extend a parent class:</p> <pre><code>class Animal {\nprotected:\n  val name: String\n\n  public:\n    def this(n: String) {\n      this.name = n\n    }\n\n    def speak: String = \"Some sound\"\n}\n\nclass Dog : Animal {\n  public:\n    def this(n: String): (n) { }\n\n    def speak: String = \"Woof!\"\n}\n\nval dog: Dog = new Dog(\"Buddy\")\nIO::println(dog.speak())  // \"Woof!\"\n</code></pre>"},{"location":"guide/inheritance/#calling-parent-constructor","title":"Calling Parent Constructor","text":"<p>Call the parent constructor via the super-initializer list on <code>def this</code>:</p> <pre><code>class Vehicle {\n  val brand: String\n\n  public:\n    def this(b: String) {\n      this.brand = b\n    }\n}\n\nclass Car : Vehicle {\n  val model: String\n\n  public:\n    def this(b: String, m: String): (b) {\n      this.model = m\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#method-overriding","title":"Method Overriding","text":"<p>Child classes can override parent methods:</p> <pre><code>class Shape {\n  public:\n    def area: Double = 0.0\n\n    def describe: String = \"A shape\"\n}\n\nclass Circle : Shape {\n  val radius: Double\n\n  public:\n    def this(r: Double) {\n      this.radius = r\n    }\n\n    def area: Double = 3.14159 * this.radius * this.radius  // Override\n\n    def describe: String = \"A circle with radius \" + this.radius  // Override\n}\n</code></pre>"},{"location":"guide/inheritance/#implementing-interfaces","title":"Implementing Interfaces","text":""},{"location":"guide/inheritance/#single-interface","title":"Single Interface","text":"<p>Use <code>&lt;:</code> to implement an interface:</p> <pre><code>import { java.lang.Comparable; }\n\nclass Person &lt;: Comparable {\n  val name: String\n  val age: Int\n\n  public:\n    def this(n: String, a: Int) {\n      this.name = n\n      this.age = a\n    }\n\n    def compareTo(other: Object): Int {\n      val otherPerson: Person = other$Person\n      return this.age - otherPerson.age\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#multiple-interfaces","title":"Multiple Interfaces","text":"<p>Implement multiple interfaces with a comma-separated list:</p> <pre><code>import {\n  java.io.Serializable;\n  java.lang.Comparable;\n}\n\nclass Student &lt;: Serializable, Comparable {\n  val id: Int\n  val name: String\n\n  public:\n    def this(i: Int, n: String) {\n      this.id = i\n      this.name = n\n    }\n\n    def compareTo(other: Object): Int {\n      val otherStudent: Student = other$Student\n      return this.id - otherStudent.id\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#combining-inheritance-and-interfaces","title":"Combining Inheritance and Interfaces","text":"<p>Use both <code>:</code> (extend class) and <code>&lt;:</code> (implement interface):</p> <pre><code>import {\n  javax.swing.JFrame;\n  java.awt.event.ActionListener;\n  java.awt.event.ActionEvent;\n}\n\nclass Calculator : JFrame &lt;: ActionListener {\n  var result: Long\n\n  public:\n    def this {\n      // JFrame constructor\n      this.result = 0L\n    }\n\n    def actionPerformed(event :ActionEvent) {\n      // Implement ActionListener interface\n      IO::println(\"Button clicked\")\n    }\n}\n</code></pre> <p>Syntax: <pre><code>class Child : ParentClass &lt;: Interface1, Interface2 {\n  // ...\n}\n</code></pre></p>"},{"location":"guide/inheritance/#delegation-pattern","title":"Delegation Pattern","text":""},{"location":"guide/inheritance/#forward-directive","title":"Forward Directive","text":"<p>Use <code>forward</code> to delegate interface methods to a member:</p> <pre><code>import {\n  java.util.List;\n  java.util.ArrayList;\n}\n\nclass MyList &lt;: List {\n  forward val internal: List;\n\n  public:\n    def this {\n      this.internal = new ArrayList;\n    }\n\n    // Custom methods\n    def addAll(items: String[]) {\n      foreach item: String in items {\n        this.internal &lt;&lt; item;\n      }\n    }\n}\n\nval list: MyList = new MyList;\nlist &lt;&lt; \"First\";\nlist &lt;&lt; \"Second\";\nIO::println(list.size);\n</code></pre> <p>The <code>forward</code> directive automatically implements interface methods by forwarding calls to the specified member.</p>"},{"location":"guide/inheritance/#polymorphism","title":"Polymorphism","text":""},{"location":"guide/inheritance/#type-substitution","title":"Type Substitution","text":"<p>Child objects can be assigned to parent variables:</p> <pre><code>class Animal {\n  public:\n    def speak: String = \"Generic sound\"\n}\n\nclass Dog : Animal {\n  public:\n    def speak: String = \"Woof!\"\n}\n\nclass Cat : Animal {\n  public:\n    def speak: String = \"Meow!\"\n}\n\nval animals: Animal[] = new Animal[3]\nanimals[0] = new Dog\nanimals[1] = new Cat\nanimals[2] = new Animal\n\nforeach animal :Animal in animals {\n  IO::println(animal.speak())\n}\n// Output:\n// Woof!\n// Meow!\n// Generic sound\n</code></pre>"},{"location":"guide/inheritance/#interface-polymorphism","title":"Interface Polymorphism","text":"<pre><code>import {\n  java.util.List;\n  java.util.ArrayList;\n  java.util.LinkedList;\n}\n\nval list1: List = new ArrayList  // ArrayList implements List\nval list2: List = new LinkedList  // LinkedList implements List\n\nval lists: java.util.List = [list1, list2]\nforeach list: List in lists {\n  list.add(\"Item\")\n  IO::println(\"Size: \" + list.size())\n}\n</code></pre>"},{"location":"guide/inheritance/#abstract-concepts","title":"Abstract Concepts","text":""},{"location":"guide/inheritance/#note-on-abstract-methods","title":"Note on Abstract Methods","text":"<p>Onion currently has limited support for abstract method validation. Abstract methods may not be enforced at compile time:</p> <pre><code>// Abstract pattern (not fully enforced)\nclass AbstractShape {\n  public:\n    def area: Double = 0.0  // Should be overridden by subclasses\n}\n\nclass Circle : AbstractShape {\n  val radius: Double\n\n  public:\n    def this(r: Double) {\n      this.radius = r\n    }\n\n    def area: Double = 3.14159 * this.radius * this.radius\n}\n</code></pre>"},{"location":"guide/inheritance/#inheritance-best-practices","title":"Inheritance Best Practices","text":""},{"location":"guide/inheritance/#favor-composition-over-inheritance","title":"Favor Composition Over Inheritance","text":"<p>Use delegation when possible:</p> <pre><code>// Instead of inheriting from ArrayList\nclass MyList : ArrayList {\n  // ...\n}\n\n// Consider delegation\nclass MyList &lt;: List {\n  forward val internal: List;\n\n  public:\n    def this {\n      this.internal = new ArrayList;\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#keep-hierarchies-shallow","title":"Keep Hierarchies Shallow","text":"<p>Avoid deep inheritance chains:</p> <pre><code>// Good: Shallow hierarchy\nAnimal\n  \u251c\u2500 Dog\n  \u2514\u2500 Cat\n\n// Bad: Deep hierarchy\nVehicle\n  \u2514\u2500 MotorVehicle\n      \u2514\u2500 Car\n          \u2514\u2500 Sedan\n              \u2514\u2500 LuxurySedan\n</code></pre>"},{"location":"guide/inheritance/#override-consistently","title":"Override Consistently","text":"<p>When overriding methods, maintain the parent's contract:</p> <pre><code>class Parent {\n  public:\n    def process(value :Int) :Int {\n      if value &lt; 0 {\n        return 0\n      }\n      return value * 2\n    }\n}\n\nclass Child : Parent {\n  public:\n    def process(value :Int) :Int {\n      // Maintain parent's behavior\n      if value &lt; 0 {\n        return 0\n      }\n      return value * 3  // Different implementation, same contract\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#next-steps","title":"Next Steps","text":"<ul> <li>Java Interoperability - Working with Java classes</li> <li>Lambda Expressions - Functional programming</li> <li>Examples - Object-oriented examples</li> </ul>"},{"location":"guide/java-interop/","title":"Java Interoperability","text":"<p>One of Onion's key strengths is seamless interoperability with Java. You can use any Java library directly in your Onion code.</p>"},{"location":"guide/java-interop/#importing-java-classes","title":"Importing Java Classes","text":""},{"location":"guide/java-interop/#import-statement","title":"Import Statement","text":"<p>Use the <code>import</code> statement to import Java classes:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.HashMap;\n  java.io.File;\n}\n\nval list: ArrayList = new ArrayList\nval map: HashMap = new HashMap\nval file: File = new File(\"data.txt\")\n</code></pre>"},{"location":"guide/java-interop/#multiple-imports","title":"Multiple Imports","text":"<p>Group related imports together:</p> <pre><code>import {\n  java.io.File;\n  java.io.FileReader;\n  java.io.BufferedReader;\n  java.io.IOException;\n}\n</code></pre>"},{"location":"guide/java-interop/#fully-qualified-names","title":"Fully Qualified Names","text":"<p>You can use fully qualified names without importing:</p> <pre><code>val list: java.util.ArrayList = new java.util.ArrayList\nval file: java.io.File = new java.io.File(\"data.txt\")\n</code></pre>"},{"location":"guide/java-interop/#creating-java-objects","title":"Creating Java Objects","text":""},{"location":"guide/java-interop/#constructor-calls","title":"Constructor Calls","text":"<p>Create Java objects with the <code>new</code> keyword:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.Date;\n  java.lang.StringBuilder;\n}\n\nval list: ArrayList = new ArrayList\nval date: Date = new Date\nval builder: StringBuilder = new StringBuilder(\"Hello\")\n</code></pre>"},{"location":"guide/java-interop/#constructor-with-parameters","title":"Constructor with Parameters","text":"<pre><code>import {\n  java.io.File;\n  java.awt.Dimension;\n}\n\nval file: File = new File(\"/path/to/file.txt\")\nval size: Dimension = new Dimension(800, 600)\n</code></pre>"},{"location":"guide/java-interop/#calling-java-methods","title":"Calling Java Methods","text":""},{"location":"guide/java-interop/#instance-methods","title":"Instance Methods","text":"<p>Call methods on Java objects normally:</p> <pre><code>import { java.util.ArrayList; }\n\nval list: ArrayList = new ArrayList\nlist.add(\"First\")\nlist.add(\"Second\")\nlist.add(\"Third\")\n\nval size: Int = list.size()  // 3\nval item: Object = list.get(0)  // \"First\"\nval exists: Boolean = list.contains(\"Second\")  // true\n</code></pre>"},{"location":"guide/java-interop/#static-methods","title":"Static Methods","text":"<p>Use <code>::</code> to call static methods:</p> <pre><code>// Math class\nval random: Double = Math::random()\nval sqrt: Double = Math::sqrt(16.0)\nval max: Int = Math::max(10, 20)\n\n// System class\nval time: Long = System::currentTimeMillis()\nval property: String = System::getProperty(\"os.name\")\n\n// Integer parsing\nval number: Int = JInteger::parseInt(\"42\")\n</code></pre>"},{"location":"guide/java-interop/#method-chaining","title":"Method Chaining","text":"<pre><code>import { java.lang.StringBuilder; }\n\nval result: String = new StringBuilder(\"Hello\")\n  .append(\" \")\n  .append(\"World\")\n  .append(\"!\")\n  .toString()\n\nIO::println(result)  // \"Hello World!\"\n</code></pre>"},{"location":"guide/java-interop/#working-with-java-collections","title":"Working with Java Collections","text":""},{"location":"guide/java-interop/#arraylist","title":"ArrayList","text":"<pre><code>import { java.util.ArrayList; }\n\nval list: ArrayList = new ArrayList\nlist &lt;&lt; \"Apple\"     // &lt;&lt; operator for add()\nlist &lt;&lt; \"Banana\"\nlist &lt;&lt; \"Cherry\"\n\nforeach fruit: String in list {\n  IO::println(fruit)\n}\n\nval first: String = list.get(0)$String\nval size: Int = list.size()\n</code></pre>"},{"location":"guide/java-interop/#hashmap","title":"HashMap","text":"<pre><code>import { java.util.HashMap; }\n\nval map: HashMap = new HashMap\nmap.put(\"name\", \"Alice\")\nmap.put(\"age\", 30)\nmap.put(\"city\", \"Tokyo\")\n\nval name: String = map.get(\"name\")$String\nval age: Int = map.get(\"age\")$Int\n\nval hasKey: Boolean = map.containsKey(\"name\")\n</code></pre>"},{"location":"guide/java-interop/#hashset","title":"HashSet","text":"<pre><code>import { java.util.HashSet; }\n\nval set: HashSet = new HashSet\nset.add(\"red\")\nset.add(\"green\")\nset.add(\"blue\")\nset.add(\"red\")  // Duplicate, won't be added\n\nIO::println(set.size())  // 3\n</code></pre>"},{"location":"guide/java-interop/#implementing-java-interfaces","title":"Implementing Java Interfaces","text":""},{"location":"guide/java-interop/#actionlistener-example","title":"ActionListener Example","text":"<pre><code>import {\n  java.awt.event.ActionListener;\n  java.awt.event.ActionEvent;\n  javax.swing.JButton;\n}\n\nclass MyButtonHandler &lt;: ActionListener {\n  public:\n    def actionPerformed(event :ActionEvent) {\n      IO::println(\"Button clicked!\")\n      val source: JButton = event.getSource()$JButton\n      IO::println(\"Button text: \" + source.getText())\n    }\n}\n\nval button: JButton = new JButton(\"Click me\")\nval handler: MyButtonHandler = new MyButtonHandler\nbutton.addActionListener(handler)\n</code></pre>"},{"location":"guide/java-interop/#runnable-example","title":"Runnable Example","text":"<pre><code>import { java.lang.Runnable; }\n\nclass MyTask &lt;: Runnable {\n  val name: String\n\n  public:\n    def this(n: String) {\n      this.name = n\n    }\n\n    def run {\n      IO::println(\"Task \" + this.name + \" is running\")\n    }\n}\n\nval task: MyTask = new MyTask(\"Background Task\")\nval thread: Thread = new Thread(task)\nthread.start()\n</code></pre>"},{"location":"guide/java-interop/#comparable-example","title":"Comparable Example","text":"<pre><code>import { java.lang.Comparable; }\n\nclass Person &lt;: Comparable {\n  val name: String\n  val age: Int\n\n  public:\n    def this(n: String, a: Int) {\n      this.name = n\n      this.age = a\n    }\n\n    def compareTo(other: Object): Int {\n      val otherPerson: Person = other$Person\n      return this.age - otherPerson.age\n    }\n}\n</code></pre>"},{"location":"guide/java-interop/#extending-java-classes","title":"Extending Java Classes","text":""},{"location":"guide/java-interop/#jframe-example","title":"JFrame Example","text":"<pre><code>import {\n  javax.swing.JFrame;\n  javax.swing.JButton;\n  java.awt.FlowLayout;\n}\n\nclass MyWindow : JFrame {\n  public:\n    def this {\n      setTitle(\"My Window\")\n      setSize(400, 300)\n      setLayout(new FlowLayout())\n\n      val button: JButton = new JButton(\"Click me\")\n      add(button)\n\n      setDefaultCloseOperation(JFrame::EXIT_ON_CLOSE)\n      setVisible(true)\n    }\n}\n\nval window: MyWindow = new MyWindow\n</code></pre>"},{"location":"guide/java-interop/#java-io","title":"Java I/O","text":""},{"location":"guide/java-interop/#file-reading","title":"File Reading","text":"<pre><code>import {\n  java.io.File;\n  java.io.FileReader;\n  java.io.BufferedReader;\n  java.io.IOException;\n}\n\ndef readFile(filename :String) {\n  try {\n    val reader: BufferedReader = new BufferedReader(\n      new FileReader(filename)\n    )\n\n    var line: String = null\n    while (line = reader.readLine()) != null {\n      IO::println(line)\n    }\n\n    reader.close()\n  } catch e :IOException {\n    IO::println(\"Error reading file: \" + e.getMessage())\n  }\n}\n\nreadFile(\"data.txt\")\n</code></pre>"},{"location":"guide/java-interop/#file-writing","title":"File Writing","text":"<pre><code>import {\n  java.io.FileWriter;\n  java.io.BufferedWriter;\n  java.io.IOException;\n}\n\ndef writeFile(filename :String, content :String) {\n  try {\n    val writer: BufferedWriter = new BufferedWriter(\n      new FileWriter(filename)\n    )\n\n    writer.write(content)\n    writer.newLine()\n    writer.close()\n\n    IO::println(\"File written successfully\")\n  } catch e :IOException {\n    IO::println(\"Error writing file: \" + e.getMessage())\n  }\n}\n\nwriteFile(\"output.txt\", \"Hello, World!\")\n</code></pre>"},{"location":"guide/java-interop/#java-swing-gui","title":"Java Swing GUI","text":""},{"location":"guide/java-interop/#complete-gui-application","title":"Complete GUI Application","text":"<pre><code>import {\n  javax.swing.JFrame;\n  javax.swing.JButton;\n  javax.swing.JTextField;\n  javax.swing.JPanel;\n  java.awt.BorderLayout;\n  java.awt.event.ActionListener;\n  java.awt.event.ActionEvent;\n}\n\nclass CalculatorApp : JFrame &lt;: ActionListener {\n  val textField: JTextField\n  var currentValue: Double\n\n  public:\n    def this {\n      setTitle(\"Simple Calculator\")\n      setSize(300, 200)\n      setLayout(new BorderLayout())\n\n      this.textField = new JTextField()\n      add(this.textField, BorderLayout::NORTH)\n\n      val panel: JPanel = new JPanel()\n      val button: JButton = new JButton(\"Calculate\")\n      button.addActionListener(this)\n      panel.add(button)\n\n      add(panel, BorderLayout::CENTER)\n\n      this.currentValue = 0.0\n      setDefaultCloseOperation(JFrame::EXIT_ON_CLOSE)\n      setVisible(true)\n    }\n\n    def actionPerformed(event :ActionEvent) {\n      val text: String = this.textField.getText()\n      IO::println(\"Calculating: \" + text)\n    }\n}\n\nval app: CalculatorApp = new CalculatorApp\n</code></pre>"},{"location":"guide/java-interop/#type-casting","title":"Type Casting","text":""},{"location":"guide/java-interop/#casting-objects","title":"Casting Objects","text":"<p>Use the <code>$</code> operator to cast Java objects:</p> <pre><code>val obj: Object = \"Hello\"\nval str: String = obj$String\n\nval list: ArrayList = new ArrayList\nlist.add(\"Item\")\nval item: String = list.get(0)$String\n</code></pre>"},{"location":"guide/java-interop/#numeric-casting","title":"Numeric Casting","text":"<pre><code>val random: Double = Math::random()\nval randomInt: Int = (random * 100)$Int\n\nval longValue: Long = 123456789L\nval intValue: Int = longValue$Int\n</code></pre>"},{"location":"guide/java-interop/#common-java-classes","title":"Common Java Classes","text":""},{"location":"guide/java-interop/#string-operations","title":"String Operations","text":"<pre><code>val text: String = \"Hello, World!\"\nval upper: String = text.toUpperCase()\nval lower: String = text.toLowerCase()\nval length: Int = text.length()\nval sub: String = text.substring(0, 5)\nval contains: Boolean = text.contains(\"World\")\n</code></pre>"},{"location":"guide/java-interop/#integer-and-long","title":"Integer and Long","text":"<pre><code>// Parsing\nval i: Int = JInteger::parseInt(\"42\")\nval l: Long = JLong::parseLong(\"1234567890\")\n\n// Conversion\nval iStr: String = JInteger::toString(42)\nval lStr: String = JLong::toString(1234567890L)\n\n// Min/Max\nval max: Int = JInteger::MAX_VALUE\nval min: Int = JInteger::MIN_VALUE\n</code></pre>"},{"location":"guide/java-interop/#math-operations","title":"Math Operations","text":"<pre><code>val abs: Int = Math::abs(-10)        // 10\nval ceil: Double = Math::ceil(3.14)   // 4.0\nval floor: Double = Math::floor(3.14) // 3.0\nval round: Long = Math::round(3.14)   // 3\nval pow: Double = Math::pow(2.0, 3.0) // 8.0\n</code></pre>"},{"location":"guide/java-interop/#next-steps","title":"Next Steps","text":"<ul> <li>Classes and Objects - OOP in Onion</li> <li>Inheritance - Extending Java classes</li> <li>Examples - Real-world examples</li> </ul>"},{"location":"guide/lambda-expressions/","title":"Lambda Expressions","text":"<p>Lambda expressions provide a concise way to create anonymous functions in Onion.</p>"},{"location":"guide/lambda-expressions/#lambda-syntax","title":"Lambda Syntax","text":"<p>Lambdas use the <code>(parameters) -&gt; { body }</code> syntax:</p> <pre><code>// Lambda with one parameter\nval double: (Int) -&gt; Int = (x: Int) -&gt; { return x * 2; }\n\n// Lambda with multiple parameters\nval add: (Int, Int) -&gt; Int = (x: Int, y: Int) -&gt; { return x + y; }\n\n// Lambda with no parameters\nval greet: () -&gt; String = () -&gt; { IO::println(\"Hello!\"); return \"done\"; }\n</code></pre>"},{"location":"guide/lambda-expressions/#calling-lambdas","title":"Calling Lambdas","text":"<p>Use the <code>.call()</code> method to invoke a lambda:</p> <pre><code>val square: (Int) -&gt; Int = (x: Int) -&gt; { return x * x; }\n\nval result: Int = square.call(5)  // 25\nIO::println(result)\n</code></pre>"},{"location":"guide/lambda-expressions/#function-types","title":"Function Types","text":"<p>Lambdas can be typed using the arrow type syntax <code>(A, B) -&gt; R</code>. For a single parameter, parentheses are optional (<code>A -&gt; R</code>):</p> <pre><code>// Function with 0 parameters\nval func0: () -&gt; Int = () -&gt; { return 42; }\nval value: Int = func0.call()\n\n// Function with 1 parameter\nval func1: Int -&gt; Int = (x: Int) -&gt; { return x * 2; }\nval doubled: Int = func1.call(10)\n\n// Function with 2 parameters\nval func2: (Int, Int) -&gt; Int = (x: Int, y: Int) -&gt; { return x + y; }\nval sum: Int = func2.call(3, 7)\n</code></pre>"},{"location":"guide/lambda-expressions/#closures","title":"Closures","text":"<p>Lambdas can capture variables from their enclosing scope:</p>"},{"location":"guide/lambda-expressions/#simple-closure","title":"Simple Closure","text":"<pre><code>val multiplier: Int = 10\nval multiply: (Int) -&gt; Int = (x: Int) -&gt; { return x * multiplier; }\n\nIO::println(multiply.call(5))  // 50\n</code></pre>"},{"location":"guide/lambda-expressions/#mutable-closures","title":"Mutable Closures","text":"<p>Closures can modify captured variables:</p> <pre><code>var count: Int = 0\nval increment: () -&gt; Int = () -&gt; {\n  count = count + 1\n  return count;\n}\n\nIO::println(increment.call())  // 1\nIO::println(increment.call())  // 2\nIO::println(increment.call())  // 3\n</code></pre>"},{"location":"guide/lambda-expressions/#counter-factory","title":"Counter Factory","text":"<pre><code>def makeCounter(): () -&gt; Int {\n  var count: Int = 0\n  return () -&gt; {\n    count = count + 1\n    return count;\n  };\n}\n\nval counter1: () -&gt; Int = makeCounter()\nval counter2: () -&gt; Int = makeCounter()\n\nIO::println(counter1.call())  // 1\nIO::println(counter1.call())  // 2\nIO::println(counter2.call())  // 1\nIO::println(counter1.call())  // 3\n</code></pre>"},{"location":"guide/lambda-expressions/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Functions that accept lambdas as parameters:</p>"},{"location":"guide/lambda-expressions/#filter-function","title":"Filter Function","text":"<pre><code>import {\n  java.util.ArrayList;\n  java.util.List;\n}\n\ndef filter(items: List, predicate: (String) -&gt; Boolean): List {\n  val result: ArrayList = new ArrayList\n\n  foreach item: String in items {\n    if predicate.call(item) {\n      result &lt;&lt; item\n    }\n  }\n\n  return result\n}\n\nval lines: List = [\n  \"INFO: System started\",\n  \"ERROR: Connection failed\",\n  \"INFO: Processing data\",\n  \"ERROR: Timeout\"\n]\n\nval isError: (String) -&gt; Boolean = (line: String) -&gt; { return line.startsWith(\"ERROR\"); }\n\nval errors: List = filter(lines, isError)\nforeach error: String in errors {\n  IO::println(error)\n}\n// Output:\n// ERROR: Connection failed\n// ERROR: Timeout\n</code></pre>"},{"location":"guide/lambda-expressions/#map-function","title":"Map Function","text":"<pre><code>import {\n  java.util.ArrayList;\n  java.util.List;\n}\n\ndef map(items: List, transform: (String) -&gt; String): List {\n  val result: ArrayList = new ArrayList\n\n  foreach item: String in items {\n    result &lt;&lt; transform.call(item)\n  }\n\n  return result\n}\n\nval words: List = [\"hello\", \"world\", \"onion\"]\nval toUpper: (String) -&gt; String = (s: String) -&gt; { return s.toUpperCase(); }\n\nval upper: List = map(words, toUpper)\nforeach word: String in upper {\n  IO::println(word)\n}\n// Output:\n// HELLO\n// WORLD\n// ONION\n</code></pre>"},{"location":"guide/lambda-expressions/#reduce-function","title":"Reduce Function","text":"<pre><code>import { java.util.List; }\n\ndef reduce(items: List, operation: (Int, Int) -&gt; Int, initial: Int): Int {\n  var accumulator: Int = initial\n\n  foreach item: Int in items {\n    accumulator = operation.call(accumulator, item)\n  }\n\n  return accumulator\n}\n\nval numbers: List = [1, 2, 3, 4, 5]\nval sum: (Int, Int) -&gt; Int = (acc: Int, n: Int) -&gt; { return acc + n; }\n\nval total: Int = reduce(numbers, sum, 0)\nIO::println(total)  // 15\n</code></pre>"},{"location":"guide/lambda-expressions/#practical-examples","title":"Practical Examples","text":""},{"location":"guide/lambda-expressions/#line-filtering","title":"Line Filtering","text":"<pre><code>import {\n  java.io.BufferedReader;\n  java.io.FileReader;\n}\n\ndef filterFile(filename: String, predicate: (String) -&gt; Boolean) {\n  val reader: BufferedReader = new BufferedReader(\n    new FileReader(filename)\n  )\n\n  var line: String = null\n  while (line = reader.readLine()) != null {\n    if predicate.call(line) {\n      IO::println(line)\n    }\n  }\n\n  reader.close()\n}\n\n// Filter lines starting with ERROR\nval errorFilter: (String) -&gt; Boolean = (line: String) -&gt; { return line.startsWith(\"ERROR\"); }\n\nfilterFile(\"logfile.txt\", errorFilter)\n</code></pre>"},{"location":"guide/lambda-expressions/#custom-sort-comparator","title":"Custom Sort Comparator","text":"<pre><code>import {\n  java.util.ArrayList;\n  java.util.Collections;\n  java.util.Comparator;\n}\n\nclass LambdaComparator &lt;: Comparator {\n  val compareFunc: (Object, Object) -&gt; Int\n\n  public:\n    def this(func: (Object, Object) -&gt; Int) {\n      this.compareFunc = func\n    }\n\n    def compare(a: Object, b: Object): Int = this.compareFunc.call(a, b)\n}\n\nval list: ArrayList = new ArrayList\nlist &lt;&lt; \"banana\"\nlist &lt;&lt; \"apple\"\nlist &lt;&lt; \"cherry\"\n\nval alphabetical: (Object, Object) -&gt; Int = (a: Object, b: Object) -&gt; {\n  val s1: String = a$String\n  val s2: String = b$String\n  return s1.compareTo(s2);\n}\n\nval comparator: LambdaComparator = new LambdaComparator(alphabetical)\nCollections::sort(list, comparator)\n\nforeach item :Object in list {\n  IO::println(item$String)\n}\n// Output:\n// apple\n// banana\n// cherry\n</code></pre>"},{"location":"guide/lambda-expressions/#event-handlers","title":"Event Handlers","text":"<pre><code>import {\n  javax.swing.JButton;\n  java.awt.event.ActionListener;\n  java.awt.event.ActionEvent;\n}\n\nclass LambdaActionListener &lt;: ActionListener {\n  val handler: (ActionEvent) -&gt; Int\n\n  public:\n    def this(h: (ActionEvent) -&gt; Int) {\n      this.handler = h\n    }\n\n    def actionPerformed(event :ActionEvent) {\n      this.handler.call(event)\n    }\n}\n\nval button: JButton = new JButton(\"Click me\")\n\nval onClick: (ActionEvent) -&gt; Int = (event: ActionEvent) -&gt; {\n  IO::println(\"Button was clicked!\")\n  return 0\n}\n\nval listener: LambdaActionListener = new LambdaActionListener(onClick)\nbutton.addActionListener(listener)\n</code></pre>"},{"location":"guide/lambda-expressions/#lambda-best-practices","title":"Lambda Best Practices","text":""},{"location":"guide/lambda-expressions/#keep-lambdas-short","title":"Keep Lambdas Short","text":"<pre><code>// Good: Simple, focused lambda\nval isEven: (Int) -&gt; Boolean = (n: Int) -&gt; { return n % 2 == 0; }\n\n// Bad: Complex lambda (use named function instead)\nval complex: (Int) -&gt; Int = (n: Int) -&gt; {\n  val temp: Int = n * 2\n  val result: Int = temp + 10\n  if result &gt; 100 {\n    return result / 2;\n  } else {\n    return result * 3;\n  }\n}\n</code></pre>"},{"location":"guide/lambda-expressions/#use-descriptive-variable-names","title":"Use Descriptive Variable Names","text":"<pre><code>// Good\nval filterErrors: (String) -&gt; Boolean = (logLine: String) -&gt; { return logLine.startsWith(\"ERROR\"); }\n\n// Bad\nval f: (String) -&gt; Boolean = (x: String) -&gt; { return x.startsWith(\"ERROR\"); }\n</code></pre>"},{"location":"guide/lambda-expressions/#avoid-side-effects-when-possible","title":"Avoid Side Effects When Possible","text":"<pre><code>// Good: Pure function\nval double: (Int) -&gt; Int = (x: Int) -&gt; { return x * 2; }\n\n// Less ideal: Side effect\nvar count: Int = 0\nval incrementCounter: () -&gt; Int = () -&gt; {\n  count = count + 1  // Modifies external state\n  return count\n}\n</code></pre>"},{"location":"guide/lambda-expressions/#next-steps","title":"Next Steps","text":"<ul> <li>Functions - Named functions and methods</li> <li>Classes and Objects - Object-oriented programming</li> <li>Examples - Functional programming examples</li> </ul>"},{"location":"guide/overview/","title":"Language Overview","text":"<p>Onion is a statically-typed, object-oriented programming language designed for the Java Virtual Machine (JVM). This page provides an overview of the language's philosophy, design goals, and key characteristics.</p>"},{"location":"guide/overview/#design-philosophy","title":"Design Philosophy","text":"<p>Onion was created with several goals in mind:</p> <ol> <li>Static Type Safety - Catch errors at compile time while maintaining expressiveness</li> <li>Java Interoperability - Seamless integration with existing Java libraries and frameworks</li> <li>Concise Syntax - Reduce boilerplate while keeping code readable</li> <li>Familiar Concepts - Build on established OOP and functional programming patterns</li> <li>JVM Performance - Leverage the mature JVM ecosystem and runtime optimizations</li> </ol>"},{"location":"guide/overview/#language-characteristics","title":"Language Characteristics","text":""},{"location":"guide/overview/#statically-typed","title":"Statically Typed","text":"<p>Every variable and expression has a type known at compile time:</p> <pre><code>val name = \"Alice\"  // Inferred as String\nval age: Int = 30\nval scores: Int[] = new Int[10]\n</code></pre> <p>The type system includes: - Primitive types: <code>Int</code>, <code>Long</code>, <code>Double</code>, <code>Float</code>, <code>Boolean</code>, <code>Byte</code>, <code>Short</code>, <code>Char</code> - Reference types: Classes and interfaces - Array types: <code>Type[]</code> - Null type: Special handling for <code>null</code> values - Bottom type: <code>Nothing</code> for non-returning expressions</p>"},{"location":"guide/overview/#object-oriented","title":"Object-Oriented","text":"<p>Onion fully supports object-oriented programming:</p> <pre><code>class Animal {\n  val name: String\n\n  public:\n    def this(n: String) {\n      this.name = n\n    }\n\n    def speak: String {\n      return \"Some sound\"\n    }\n}\n\nclass Dog : Animal {\n  public:\n    def this(n: String): (n) {\n    }\n\n    def speak: String {\n      return \"Woof!\"\n    }\n}\n</code></pre> <p>Features: - Classes - Encapsulation of data and behavior - Inheritance - Single class inheritance, multiple interface implementation - Polymorphism - Method overriding and overloading - Access Control - Public/private visibility - Interfaces - Abstract contracts</p>"},{"location":"guide/overview/#functional-elements","title":"Functional Elements","text":"<p>While primarily object-oriented, Onion includes functional programming features:</p> <pre><code>// Lambda expressions\nval filter: (Int) -&gt; Boolean = (x: Int) -&gt; { return x &gt; 10; }\n\n// Closures\ndef makeCounter(): () -&gt; Int {\n  var count: Int = 0\n  return () -&gt; {\n    count = count + 1;\n    return count;\n  };\n}\n\nval counter: () -&gt; Int = makeCounter()\nIO::println(counter.call())  // 1\nIO::println(counter.call())  // 2\n</code></pre> <p>Features: - Lambda expressions - Anonymous functions with <code>(params) -&gt; { body }</code> syntax - Closures - Functions that capture variables from their enclosing scope - First-class functions - Functions as values via <code>Function0</code> through <code>Function10</code> interfaces</p>"},{"location":"guide/overview/#jvm-target","title":"JVM Target","text":"<p>Onion compiles directly to JVM bytecode:</p> <ul> <li>Compiled <code>.class</code> files are standard JVM classes</li> <li>Can be packaged in JARs alongside Java classes</li> <li>Inherits JVM's performance characteristics</li> <li>Access to the entire Java ecosystem</li> </ul>"},{"location":"guide/overview/#java-interoperability","title":"Java Interoperability","text":"<p>Direct, seamless access to Java:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.HashMap;\n  javax.swing.JFrame;\n}\n\nval list: ArrayList = new ArrayList\nval map: HashMap = new HashMap\nval window: JFrame = new JFrame(\"Title\")\n</code></pre> <p>Key points: - Import Java classes with <code>import { }</code> - Instantiate Java objects with <code>new</code> - Call Java methods normally - Implement Java interfaces - Extend Java classes - Use <code>::</code> for static method access</p>"},{"location":"guide/overview/#compilation-model","title":"Compilation Model","text":"<p>The Onion compiler follows a multi-phase architecture:</p> <pre><code>Source Code (.on)\n    \u2193\n[Parsing] - JavaCC grammar \u2192 Untyped AST\n    \u2193\n[Rewriting] - Normalization \u2192 Transformed AST\n    \u2193\n[Type Checking] - Type inference &amp; validation \u2192 Typed AST\n    \u2193\n[Code Generation] - ASM bytecode generation \u2192 .class files\n</code></pre>"},{"location":"guide/overview/#compilation-modes","title":"Compilation Modes","text":"<ol> <li>File Compilation (<code>onionc</code>) - Produces <code>.class</code> files</li> <li>Script Execution (<code>onion</code>) - Compiles to memory and runs immediately</li> <li>Interactive REPL (<code>Shell</code>) - Evaluate expressions interactively</li> </ol>"},{"location":"guide/overview/#syntax-highlights","title":"Syntax Highlights","text":""},{"location":"guide/overview/#fields-with-val-var","title":"Fields with <code>val</code> / <code>var</code>","text":"<p>Declare fields with <code>val</code> (immutable) or <code>var</code> (mutable) and access them via <code>this.field</code>:</p> <pre><code>class Counter {\n  var count: Int\n\n  public:\n    def increment {\n      this.count = this.count + 1\n    }\n}\n</code></pre>"},{"location":"guide/overview/#type-annotations-with","title":"Type Annotations with <code>:</code>","text":"<p>Types are specified after a colon. Local declarations can omit the type when an initializer is present:</p> <pre><code>val variable: Type = value\nval inferred = value\ndef method(param: Type): ReturnType { }\n</code></pre>"},{"location":"guide/overview/#static-access-with","title":"Static Access with <code>::</code>","text":"<p>Static methods and fields use <code>::</code>:</p> <pre><code>IO::println(\"Hello\")\nMath::random()\nSystem::out.println(\"Java style\")\n</code></pre> <p>Default static imports make some class members available without <code>::</code> (for example, <code>println(\"Hello\")</code> from <code>onion.IO</code>). The list lives in <code>src/main/resources/onion/default-static-imports.txt</code>.</p>"},{"location":"guide/overview/#type-casting-with","title":"Type Casting with <code>$</code>","text":"<p>Cast expressions use the <code>$</code> operator:</p> <pre><code>val x: Double = 3.14\nval y: Int = x$Int  // Cast to Int\n\nval obj: Object = \"string\"\nval str: String = obj$String  // Cast to String\n</code></pre>"},{"location":"guide/overview/#pattern-matching-with-select","title":"Pattern Matching with <code>select</code>","text":"<p>Switch-style pattern matching:</p> <pre><code>select value {\n  case 1, 2, 3:\n    IO::println(\"Small\")\n  case 4, 5, 6:\n    IO::println(\"Medium\")\n  else:\n    IO::println(\"Large\")\n}\n</code></pre>"},{"location":"guide/overview/#whats-different-from-java","title":"What's Different from Java?","text":"Feature Java Onion Field declarations <code>Type field</code> <code>val/var field: Type</code> Variable declarations <code>Type variable</code> <code>val/var variable[: Type] = value</code> Static access <code>Class.method()</code> <code>Class::method()</code> Type casting <code>(Type) value</code> <code>value$Type</code> Lambda syntax <code>(x) -&gt; x + 1</code> <code>(x :Int) -&gt; { return x + 1; }</code> Pattern matching <code>switch</code> (Java 14+) <code>select</code> List append <code>list.add(x)</code> <code>list &lt;&lt; x</code>"},{"location":"guide/overview/#current-limitations","title":"Current Limitations","text":"<p>As documented in the README:</p> <ol> <li>Incomplete validation - Some compile-time checks (abstract method implementation, final method overriding) are not fully implemented</li> <li>Edge cases - The compiler may crash on certain code patterns</li> <li>Partial features - Some features like <code>finally</code> clauses are not yet supported</li> </ol> <p>The examples in the <code>run/</code> directory are verified to compile and execute correctly.</p>"},{"location":"guide/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Syntax - Learn the fundamentals</li> <li>Classes and Objects - Object-oriented programming</li> <li>Java Interoperability - Working with Java libraries</li> </ul>"},{"location":"guide/variables-and-types/","title":"Variables and Types","text":"<p>Onion is a statically-typed language, meaning every variable has a type determined at compile time.</p>"},{"location":"guide/variables-and-types/#type-annotations","title":"Type Annotations","text":"<p>Local <code>val</code> / <code>var</code> declarations can omit the type when an initializer is present. Use explicit type annotations for fields, top-level declarations, or when no initializer is provided:</p> <pre><code>val name = \"Alice\"\nvar count = 0\nval age: Int = 30\nval height: Double = 5.8\n</code></pre>"},{"location":"guide/variables-and-types/#type-system","title":"Type System","text":""},{"location":"guide/variables-and-types/#primitive-types","title":"Primitive Types","text":"<p>Onion supports all JVM primitive types:</p> <pre><code>val byteVal: Byte = 127\nval shortVal: Short = 32767\nval intVal: Int = 2147483647\nval longVal: Long = 9223372036854775807L\nval floatVal: Float = 3.14f\nval doubleVal: Double = 3.14159\nval charVal: Char = 'A'\nval boolVal: Boolean = true\n</code></pre>"},{"location":"guide/variables-and-types/#reference-types","title":"Reference Types","text":""},{"location":"guide/variables-and-types/#string-type","title":"String Type","text":"<pre><code>val message: String = \"Hello, World!\"\nval empty: String = \"\"\nval multiline: String = \"Line 1\\nLine 2\"\n</code></pre>"},{"location":"guide/variables-and-types/#class-types","title":"Class Types","text":"<p>Any Java or Onion class can be used as a type:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.io.File;\n}\n\nval list: ArrayList = new ArrayList\nval file: File = new File(\"data.txt\")\n</code></pre>"},{"location":"guide/variables-and-types/#interface-types","title":"Interface Types","text":"<pre><code>import {\n  java.util.List;\n  java.util.ArrayList;\n}\n\nval list: List = new ArrayList  // Interface type\n</code></pre>"},{"location":"guide/variables-and-types/#array-types","title":"Array Types","text":"<p>Arrays are declared with <code>Type[]</code> syntax:</p> <pre><code>val integers: Int[] = new Int[10]\nval strings: String[] = new String[3]\nstrings[0] = \"a\"\nstrings[1] = \"b\"\nstrings[2] = \"c\"\nval objects: Object[] = new Object[5]\n</code></pre>"},{"location":"guide/variables-and-types/#null-type","title":"Null Type","text":"<p>The <code>null</code> literal has a special null type:</p> <pre><code>val maybeString: String = null\nval maybeObject: Object = null\n</code></pre>"},{"location":"guide/variables-and-types/#bottom-type-nothing","title":"Bottom Type (Nothing)","text":"<p><code>Nothing</code> is the subtype of all types and is used for expressions that never return, such as <code>return</code>, <code>throw</code>, <code>break</code>, and <code>continue</code>.</p>"},{"location":"guide/variables-and-types/#type-casting","title":"Type Casting","text":""},{"location":"guide/variables-and-types/#using-the-operator","title":"Using the <code>$</code> Operator","text":"<p>Convert between types using the <code>$</code> casting operator:</p> <pre><code>// Numeric casting\nval x: Double = 3.14\nval y: Int = x$Int  // 3\n\n// Object casting\nval obj: Object = \"Hello\"\nval str: String = obj$String\n\n// Random number to Int\nval random: Int = (Math::random() * 100)$Int\n</code></pre>"},{"location":"guide/variables-and-types/#automatic-widening","title":"Automatic Widening","text":"<p>Smaller numeric types automatically widen to larger ones:</p> <pre><code>val i: Int = 42\nval l: Long = i  // Int \u2192 Long (automatic)\nval d: Double = l  // Long \u2192 Double (automatic)\n</code></pre>"},{"location":"guide/variables-and-types/#explicit-narrowing","title":"Explicit Narrowing","text":"<p>Narrowing conversions require explicit casting:</p> <pre><code>val d: Double = 3.14\nval i: Int = d$Int  // Must use $ operator\n</code></pre>"},{"location":"guide/variables-and-types/#type-compatibility","title":"Type Compatibility","text":""},{"location":"guide/variables-and-types/#assignment-compatibility","title":"Assignment Compatibility","text":"<p>A value can be assigned to a variable if:</p> <ol> <li>Types are exactly the same</li> <li>Value type is a subtype of variable type</li> <li>Automatic widening applies (for primitives)</li> </ol> <pre><code>// Same type\nval s1: String = \"Hello\"\nval s2: String = s1  // OK\n\n// Subtype\nimport { java.util.ArrayList; java.util.List; }\nval arrayList: ArrayList = new ArrayList\nval list: List = arrayList  // OK (ArrayList implements List)\n\n// Widening\nval i: Int = 42\nval l: Long = i  // OK (Int \u2192 Long)\n</code></pre>"},{"location":"guide/variables-and-types/#variable-scope","title":"Variable Scope","text":""},{"location":"guide/variables-and-types/#local-variables","title":"Local Variables","text":"<p>Variables declared in methods or blocks:</p> <pre><code>def method {\n  val local: Int = 10\n  if true {\n    val nested: Int = 20\n    IO::println(local)   // OK\n    IO::println(nested)  // OK\n  }\n  // IO::println(nested)  // ERROR: nested not in scope\n}\n</code></pre>"},{"location":"guide/variables-and-types/#fields","title":"Fields","text":"<p>Declare fields with <code>val</code> / <code>var</code> and access them via <code>this.field</code>:</p> <pre><code>class Counter {\n  var count: Int\n\n  public:\n    def this {\n      this.count = 0  // Initialize member\n    }\n\n    def increment {\n      this.count = this.count + 1  // Access member\n    }\n\n    def getCount: Int = this.count  // Return member value\n}\n</code></pre>"},{"location":"guide/variables-and-types/#static-variables","title":"Static Variables","text":"<p>Static members belong to the class, not instances:</p> <pre><code>class MathUtils {\n  static val PI: Double = 3.14159\n\n  public:\n    static def square(x: Double): Double = x * x\n}\n\n// Access static members\nval pi: Double = MathUtils::PI\nval result: Double = MathUtils::square(5.0)\n</code></pre>"},{"location":"guide/variables-and-types/#type-inference","title":"Type Inference","text":"<p>Onion can infer the type of local <code>val</code> / <code>var</code> declarations when an initializer is present (fields and top-level declarations still require explicit types):</p> <pre><code>// With explicit type\nval name: String = \"Alice\"\n\n// Inferred from the initializer\nval age = 30         // Int\nvar greeting = \"Hi\"  // String\n</code></pre>"},{"location":"guide/variables-and-types/#generic-types-java-generics","title":"Generic Types (Java Generics)","text":"<p>When using Java generic types, specify type parameters with <code>[]</code>:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.HashMap;\n}\n\nval list: ArrayList[String] = new ArrayList[String]\nval map: HashMap[String, Int] = new HashMap[String, Int]\n</code></pre>"},{"location":"guide/variables-and-types/#primitive-type-arguments","title":"Primitive Type Arguments","text":"<p>Type arguments may be primitive types (e.g., <code>Int</code>). Onion uses JVM erasure, so primitive type arguments are boxed/unboxed at call boundaries:</p> <pre><code>val list: ArrayList[Int] = new ArrayList[Int]\nlist.add(1)\nval x: Int = list.get(0)\n</code></pre>"},{"location":"guide/variables-and-types/#function-types","title":"Function Types","text":"<p>Functions are represented by <code>Function0</code> through <code>Function10</code> interfaces:</p> <pre><code>val func: (Int) -&gt; Int = (x: Int) -&gt; { return x * 2; }\nval result: Int = func.call(5)$Int  // 10\n</code></pre> <ul> <li><code>Function0</code> - No parameters</li> <li><code>Function1</code> - One parameter</li> <li><code>Function2</code> - Two parameters</li> <li>... up to <code>Function10</code></li> </ul>"},{"location":"guide/variables-and-types/#next-steps","title":"Next Steps","text":"<ul> <li>Control Flow - if, while, for, select</li> <li>Functions - Function definitions and lambdas</li> <li>Classes and Objects - Object-oriented programming</li> </ul>"},{"location":"reference/compiler-architecture/","title":"Compiler Architecture","text":"<p>The Onion compiler is a multi-phase pipeline compiler that transforms source code into JVM bytecode.</p>"},{"location":"reference/compiler-architecture/#overview","title":"Overview","text":"<pre><code>Source Code (.on files)\n    \u2193\n[1] Parsing (JavaCC) \u2192 Untyped AST\n    \u2193\n[2] Rewriting \u2192 Normalized Untyped AST\n    \u2193\n[3] Type Checking \u2192 Typed AST\n    \u2193\n[4] Code Generation (ASM) \u2192 JVM Bytecode (.class files)\n</code></pre>"},{"location":"reference/compiler-architecture/#implementation","title":"Implementation","text":"<ul> <li>Language: Scala 3.6.2</li> <li>Parser Generator: JavaCC 5.0</li> <li>Bytecode Library: ASM 9.8</li> <li>Build Tool: SBT</li> <li>JVM Target: Java 17+</li> </ul>"},{"location":"reference/compiler-architecture/#phase-1-parsing","title":"Phase 1: Parsing","text":"<p>File: <code>src/main/scala/onion/compiler/Parsing.scala</code></p>"},{"location":"reference/compiler-architecture/#grammar","title":"Grammar","text":"<p>The parser grammar is defined in <code>grammar/JJOnionParser.jj</code> using JavaCC syntax.</p>"},{"location":"reference/compiler-architecture/#process","title":"Process","text":"<ol> <li>JavaCC generates <code>JJOnionParser.java</code> from the grammar</li> <li>Source code is tokenized and parsed</li> <li><code>ASTBuilder</code> constructs an untyped Abstract Syntax Tree</li> <li>Parser errors are collected and reported</li> </ol>"},{"location":"reference/compiler-architecture/#output","title":"Output","text":"<p>Untyped AST defined in <code>src/main/scala/onion/compiler/AST.scala</code>:</p> <ul> <li><code>ClassDef</code> - Class definitions</li> <li><code>MethodDef</code> - Method definitions</li> <li><code>VarDef</code> - Variable declarations</li> <li>Expressions: <code>BinaryOp</code>, <code>MethodCall</code>, <code>Literal</code>, etc.</li> </ul>"},{"location":"reference/compiler-architecture/#phase-2-rewriting","title":"Phase 2: Rewriting","text":"<p>File: <code>src/main/scala/onion/compiler/Rewriting.scala</code></p>"},{"location":"reference/compiler-architecture/#purpose","title":"Purpose","text":"<p>Transform and normalize the untyped AST:</p> <ul> <li>Desugar complex constructs</li> <li>Normalize expressions</li> <li>Prepare for type checking</li> </ul>"},{"location":"reference/compiler-architecture/#examples","title":"Examples","text":"<ul> <li>Convert high-level constructs to simpler forms</li> <li>Expand syntactic sugar</li> <li>Normalize operator precedence</li> </ul>"},{"location":"reference/compiler-architecture/#phase-3-type-checking","title":"Phase 3: Type Checking","text":"<p>File: <code>src/main/scala/onion/compiler/Typing.scala</code> (86KB - largest component)</p>"},{"location":"reference/compiler-architecture/#responsibilities","title":"Responsibilities","text":"<ol> <li>Type Inference: Determine types of expressions</li> <li>Type Validation: Ensure type compatibility</li> <li>Name Resolution: Resolve variable and method names</li> <li>Symbol Tables: Build and maintain symbol information</li> </ol>"},{"location":"reference/compiler-architecture/#supporting-components","title":"Supporting Components","text":"<p>Symbol Tables (<code>src/main/scala/onion/compiler/</code>): - <code>ClassTable.scala</code> - Class symbol table - <code>LocalContext.scala</code> - Local variable environments - <code>Symbol.scala</code> - Symbol definitions</p> <p>Error Reporting: - <code>SemanticError.scala</code> - Type error definitions - <code>SemanticErrorReporter.scala</code> - Error collection</p> <p>Type System: - <code>BasicType</code> - Primitive types (Int, Long, Double, etc.) - <code>ClassType</code> - Reference types - <code>ArrayType</code> - Array types - <code>NullType</code> - Null literal type</p>"},{"location":"reference/compiler-architecture/#process_1","title":"Process","text":"<ol> <li>Build class table from class definitions</li> <li>Process imports and resolve external types</li> <li>Type check method bodies</li> <li>Validate assignments and method calls</li> <li>Infer types where possible</li> <li>Report type errors</li> </ol>"},{"location":"reference/compiler-architecture/#output_1","title":"Output","text":"<p>Typed AST defined in <code>src/main/scala/onion/compiler/TypedAST.scala</code>:</p> <ul> <li>Each node has type information</li> <li>Names are resolved to symbols</li> <li>Ready for code generation</li> </ul>"},{"location":"reference/compiler-architecture/#phase-4-code-generation","title":"Phase 4: Code Generation","text":"<p>File: <code>src/main/scala/onion/compiler/AsmCodeGeneration.scala</code> (42KB)</p>"},{"location":"reference/compiler-architecture/#asm-library","title":"ASM Library","text":"<p>Uses the ASM library for bytecode generation: - Type-safe bytecode emission - Stack frame management - Local variable tracking</p>"},{"location":"reference/compiler-architecture/#supporting-components_1","title":"Supporting Components","text":"<p>Bytecode Utilities (<code>src/main/scala/onion/compiler/bytecode/</code>): - <code>MethodEmitter.scala</code> - JVM method generation - <code>LocalVarContext.scala</code> - Local variable management - <code>AsmUtil.scala</code> - ASM helper functions</p> <p>Visitor Pattern: - <code>AsmCodeGenerationVisitor.scala</code> - AST traversal for code generation</p>"},{"location":"reference/compiler-architecture/#process_2","title":"Process","text":"<ol> <li>Create <code>ClassWriter</code> for each class</li> <li>Generate class metadata (name, superclass, interfaces)</li> <li>Generate fields from member variables</li> <li>Generate methods:</li> <li>Create <code>MethodVisitor</code></li> <li>Emit bytecode instructions</li> <li>Manage local variables and stack</li> <li>Generate constructors</li> <li>Finalize class bytecode</li> </ol>"},{"location":"reference/compiler-architecture/#output_2","title":"Output","text":"<p><code>CompiledClass</code> objects containing: - Class name - JVM bytecode (byte array) - Can be written to <code>.class</code> files or loaded in-memory</p>"},{"location":"reference/compiler-architecture/#compiler-orchestration","title":"Compiler Orchestration","text":"<p>File: <code>src/main/scala/onion/compiler/OnionCompiler.scala</code></p>"},{"location":"reference/compiler-architecture/#processor-pipeline","title":"Processor Pipeline","text":"<p>All phases implement <code>Processor[A, B]</code> trait:</p> <pre><code>trait Processor[A, B] {\n  def process(input: A): B\n\n  def andThen[C](next: Processor[B, C]): Processor[A, C]\n}\n</code></pre>"},{"location":"reference/compiler-architecture/#composition","title":"Composition","text":"<p>Phases are composed using <code>andThen</code>:</p> <pre><code>val compiler =\n  Parsing\n    .andThen(Rewriting)\n    .andThen(Typing)\n    .andThen(AsmCodeGeneration)\n</code></pre>"},{"location":"reference/compiler-architecture/#compilation-result","title":"Compilation Result","text":"<p>Returns <code>CompilationOutcome</code>: - <code>Success(classes: Seq[CompiledClass])</code> - Compilation succeeded - <code>Failure(errors: Seq[CompileError])</code> - Compilation failed</p>"},{"location":"reference/compiler-architecture/#entry-points","title":"Entry Points","text":""},{"location":"reference/compiler-architecture/#compilerfrontend","title":"CompilerFrontend","text":"<p>File: <code>src/main/scala/onion/tools/CompilerFrontend.scala</code></p> <p>Command-line interface for <code>onionc</code>: - Parses command-line arguments - Invokes compiler - Writes <code>.class</code> files to disk</p>"},{"location":"reference/compiler-architecture/#scriptrunner","title":"ScriptRunner","text":"<p>File: <code>src/main/scala/onion/tools/ScriptRunner.scala</code></p> <p>Command-line interface for <code>onion</code>: - Compiles source files to memory - Loads classes with custom classloader - Executes main method or top-level code</p>"},{"location":"reference/compiler-architecture/#shell","title":"Shell","text":"<p>File: <code>src/main/scala/onion/tools/Shell.scala</code></p> <p>Interactive REPL: - Reads expressions - Compiles incrementally - Evaluates and prints results</p>"},{"location":"reference/compiler-architecture/#class-loading","title":"Class Loading","text":"<p>File: <code>src/main/scala/onion/compiler/OnionClassLoader.scala</code></p> <p>Custom classloader for in-memory compilation: - Accepts bytecode directly - Defines classes at runtime - Supports script execution</p>"},{"location":"reference/compiler-architecture/#error-handling","title":"Error Handling","text":""},{"location":"reference/compiler-architecture/#compilation-errors","title":"Compilation Errors","text":"<p>Types: - <code>ParseError</code> - Syntax errors - <code>SemanticError</code> - Type errors - <code>CompileError</code> - General compilation errors</p> <p>Reporting: - <code>CompilationReporter</code> - Formats and displays errors - Includes source location (file, line, column) - Shows context around error</p>"},{"location":"reference/compiler-architecture/#example-error","title":"Example Error","text":"<pre><code>Error: Type mismatch\n  Expected: Int\n  Found: String\n  at MyProgram.on:15\n    val x: Int = \"hello\"\n                 ^^^^^^^\n</code></pre>"},{"location":"reference/compiler-architecture/#utilities","title":"Utilities","text":""},{"location":"reference/compiler-architecture/#toolbox","title":"Toolbox","text":"<p>Location: <code>src/main/scala/onion/compiler/toolbox/</code></p> <p>Helper utilities: - <code>Classes.scala</code> - Class manipulation - <code>Paths.scala</code> - Path handling - <code>SymbolGenerator.scala</code> - Unique symbol generation - <code>MethodInvoker.scala</code> - Reflection-based invocation - <code>Boxing.scala</code> - Primitive/object boxing</p>"},{"location":"reference/compiler-architecture/#environment","title":"Environment","text":"<p>Location: <code>src/main/scala/onion/compiler/environment/</code></p> <p>Type resolution: - <code>ClassFileTable.scala</code> - Caches loaded classes - <code>AsmRefs.scala</code> - ASM type references - <code>ReflectionRefs.scala</code> - Reflection-based types</p>"},{"location":"reference/compiler-architecture/#build-process","title":"Build Process","text":""},{"location":"reference/compiler-architecture/#sbt-configuration","title":"SBT Configuration","text":"<p>File: <code>build.sbt</code></p> <ul> <li>Version: 0.2.0-SNAPSHOT</li> <li>Scala version: 3.6.2</li> <li>Main class: <code>onion.tools.CompilerFrontend</code></li> </ul>"},{"location":"reference/compiler-architecture/#parser-generation","title":"Parser Generation","text":"<p>Automatically regenerates parser when grammar changes:</p> <pre><code>sourceGenerators in Compile += Def.task {\n  val grammar = file(\"grammar/JJOnionParser.jj\")\n  val parser = sourceManaged.value / \"java\" / \"onion\" / \"compiler\" / \"parser\" / \"JJOnionParser.java\"\n\n  if (grammar.lastModified() &gt; parser.lastModified()) {\n    javacc(classpath.value, sourceManaged.value / \"java\", streams.value.log)\n  }\n}\n</code></pre>"},{"location":"reference/compiler-architecture/#assembly","title":"Assembly","text":"<p>Creates standalone JAR:</p> <pre><code>sbt assembly\n# Creates onion.jar\n</code></pre>"},{"location":"reference/compiler-architecture/#distribution","title":"Distribution","text":"<p>Creates distribution ZIP:</p> <pre><code>sbt dist\n# Creates target/onion-dist.zip with:\n#   - onion.jar\n#   - lib/ (dependencies)\n#   - bin/ (scripts)\n#   - run/ (examples)\n</code></pre>"},{"location":"reference/compiler-architecture/#testing","title":"Testing","text":"<p>Framework: ScalaTest 3.2.19</p> <p>Location: <code>src/test/scala/onion/compiler/tools/</code></p> <p>Base Class: <code>AbstractShellSpec</code> - Runs Onion code - Captures output - Verifies results</p> <p>Example Tests: - <code>HelloWorldSpec</code> - Basic output - <code>FactorialSpec</code> - Recursion - <code>StringInterpolationSpec</code> - String features</p>"},{"location":"reference/compiler-architecture/#development-workflow","title":"Development Workflow","text":"<ol> <li>Modify Grammar: Edit <code>grammar/JJOnionParser.jj</code></li> <li>Compile: Run <code>sbt compile</code> (regenerates parser)</li> <li>Test: Run <code>sbt test</code></li> <li>Iterate: Repeat</li> </ol>"},{"location":"reference/compiler-architecture/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Parsing: O(n) where n = source size</li> <li>Type Checking: O(n \u00d7 m) where n = nodes, m = symbols</li> <li>Code Generation: O(n) where n = typed AST nodes</li> </ul>"},{"location":"reference/compiler-architecture/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements: - Incremental compilation - Better error messages - Type inference improvements - Optimization passes - Debugging support</p>"},{"location":"reference/compiler-architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Language Specification - Language details</li> <li>Building from Source - Developer guide</li> <li>Contributing - How to contribute</li> </ul>"},{"location":"reference/specification/","title":"Language Specification","text":"<p>Formal specification of the Onion programming language.</p>"},{"location":"reference/specification/#lexical-structure","title":"Lexical Structure","text":""},{"location":"reference/specification/#keywords","title":"Keywords","text":"<p>Reserved words in Onion:</p> <pre><code>break       case        catch       class       continue\ndef         else        false       finally     for\nforeach     forward     if          import      interface\nmodule      new         null        private     protected\npublic      record      return      select      self\nstatic      super       this        throw       true\ntry         val         var         while\n</code></pre>"},{"location":"reference/specification/#identifiers","title":"Identifiers","text":"<ul> <li>Start with a letter or underscore</li> <li>Followed by letters, digits, or underscores</li> <li>Case-sensitive</li> </ul> <p>Valid identifiers: - <code>name</code>, <code>value</code>, <code>_temp</code>, <code>count123</code>, <code>myVariable</code></p> <p>Invalid identifiers: - <code>123abc</code> (starts with digit) - <code>my-variable</code> (contains hyphen) - <code>class</code> (reserved keyword)</p>"},{"location":"reference/specification/#literals","title":"Literals","text":"<p>Integer Literals: - Decimal: <code>42</code>, <code>0</code>, <code>123</code> - Hexadecimal: <code>0xFF</code>, <code>0x1A2B</code> - Octal: <code>077</code>, <code>0123</code></p> <p>Long Literals: - <code>42L</code>, <code>1234567890L</code></p> <p>Floating Point: - <code>3.14</code>, <code>0.5</code>, <code>1.23e10</code></p> <p>Float Literals: - <code>3.14f</code>, <code>0.5f</code></p> <p>String Literals: - Double quotes: <code>\"Hello, World!\"</code> - Escape sequences: <code>\\n</code>, <code>\\t</code>, <code>\\\\</code>, <code>\\\"</code></p> <p>Character Literals: - Single quotes: <code>'A'</code>, <code>'1'</code>, <code>'\\n'</code></p> <p>Boolean Literals: - <code>true</code>, <code>false</code></p> <p>Null Literal: - <code>null</code></p>"},{"location":"reference/specification/#type-system","title":"Type System","text":""},{"location":"reference/specification/#primitive-types","title":"Primitive Types","text":"Type Size Range <code>Byte</code> 8-bit -128 to 127 <code>Short</code> 16-bit -32768 to 32767 <code>Int</code> 32-bit -2\u00b3\u00b9 to 2\u00b3\u00b9-1 <code>Long</code> 64-bit -2\u2076\u00b3 to 2\u2076\u00b3-1 <code>Float</code> 32-bit IEEE 754 <code>Double</code> 64-bit IEEE 754 <code>Char</code> 16-bit Unicode character <code>Boolean</code> N/A <code>true</code> or <code>false</code>"},{"location":"reference/specification/#reference-types","title":"Reference Types","text":"<ul> <li>Class types: <code>String</code>, <code>Object</code>, user-defined classes</li> <li>Interface types: Java interfaces</li> <li>Array types: <code>Type[]</code></li> <li>Null type: Type of <code>null</code> literal</li> <li>Bottom type: <code>Nothing</code> for non-returning expressions</li> </ul>"},{"location":"reference/specification/#type-annotations","title":"Type Annotations","text":"<p>Types are written after a colon in declarations (e.g., <code>val name: String</code>). Local <code>val</code> / <code>var</code> declarations can omit the type when an initializer is present.</p> <pre><code>val name: String\nval age: Int\nval scores: Int[]\nval inferred = \"Alice\"\n</code></pre>"},{"location":"reference/specification/#declarations","title":"Declarations","text":""},{"location":"reference/specification/#variable-declaration","title":"Variable Declaration","text":"<pre><code>val identifier: Type = expression\nvar identifier: Type = expression\nval identifier = expression       // local only\nvar identifier = expression       // local only\n</code></pre>"},{"location":"reference/specification/#function-declaration","title":"Function Declaration","text":"<pre><code>def identifier(param :Type, ...) :ReturnType {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#class-declaration","title":"Class Declaration","text":"<pre><code>class ClassName {\n  members\n}\n\nclass ClassName : ParentClass {\n  members\n}\n\nclass ClassName &lt;: Interface {\n  members\n}\n\nclass ClassName : ParentClass &lt;: Interface1, Interface2 {\n  members\n}\n</code></pre>"},{"location":"reference/specification/#member-variables","title":"Member Variables","text":"<pre><code>class Example {\n  val memberName: Type\n\n  public:\n    var publicMember: Type\n}\n</code></pre>"},{"location":"reference/specification/#constructors","title":"Constructors","text":"<pre><code>def this(params) {\n  body\n}\n\ndef this(params): (superArgs) {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#methods","title":"Methods","text":"<pre><code>def methodName(params) :ReturnType {\n  body\n}\n\nstatic def staticMethod(params) :ReturnType {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#statements","title":"Statements","text":"<p>Control-flow forms are expressions. Blocks evaluate to the last expression, <code>if</code>/<code>select</code>/<code>try</code> can appear where an expression is expected, and loops evaluate to <code>void</code>. <code>return</code>/<code>throw</code>/<code>break</code>/<code>continue</code> are bottom-typed (they never produce a value).</p>"},{"location":"reference/specification/#expression-statement","title":"Expression Statement","text":"<pre><code>expression;\n</code></pre>"},{"location":"reference/specification/#block-statement","title":"Block Statement","text":"<pre><code>{\n  statements\n}\n</code></pre>"},{"location":"reference/specification/#if-statement","title":"If Statement","text":"<pre><code>if condition {\n  body\n} else if condition {\n  body\n} else {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#while-loop","title":"While Loop","text":"<pre><code>while condition {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#for-loop","title":"For Loop","text":"<pre><code>for init; condition; update {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#foreach-loop","title":"Foreach Loop","text":"<pre><code>foreach variable :Type in collection {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#select-statement","title":"Select Statement","text":"<pre><code>select expression {\n  case value1, value2:\n    body\n  case value3:\n    body\n  else:\n    body\n}\n</code></pre>"},{"location":"reference/specification/#try-catch-statement","title":"Try-Catch Statement","text":"<pre><code>try {\n  body\n} catch variable :ExceptionType {\n  handler\n}\n</code></pre>"},{"location":"reference/specification/#return-statement","title":"Return Statement","text":"<pre><code>return\nreturn expression\n</code></pre>"},{"location":"reference/specification/#break-and-continue","title":"Break and Continue","text":"<pre><code>break\ncontinue\n</code></pre>"},{"location":"reference/specification/#expressions","title":"Expressions","text":""},{"location":"reference/specification/#operators","title":"Operators","text":"<p>Precedence (highest to lowest):</p> <ol> <li>Member access: <code>.</code>, <code>::</code></li> <li>Postfix: <code>++</code>, <code>--</code></li> <li>Unary: <code>!</code>, <code>-</code>, <code>+</code></li> <li>Type cast: <code>$</code></li> <li>Multiplicative: <code>*</code>, <code>/</code>, <code>%</code></li> <li>Additive: <code>+</code>, <code>-</code></li> <li>Relational: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Equality: <code>==</code>, <code>!=</code></li> <li>Logical AND: <code>&amp;&amp;</code></li> <li>Logical OR: <code>||</code></li> <li>Assignment: <code>=</code></li> <li>List append: <code>&lt;&lt;</code></li> </ol>"},{"location":"reference/specification/#lambda-expressions","title":"Lambda Expressions","text":"<pre><code>(param :Type, ...) -&gt; { body }\n</code></pre>"},{"location":"reference/specification/#type-casting","title":"Type Casting","text":"<pre><code>expression$TargetType\n</code></pre>"},{"location":"reference/specification/#object-creation","title":"Object Creation","text":"<pre><code>new ClassName(args)\nnew Type[size]\n</code></pre>"},{"location":"reference/specification/#method-calls","title":"Method Calls","text":"<pre><code>object.method(args)\nClass::staticMethod(args)\n</code></pre>"},{"location":"reference/specification/#array-access","title":"Array Access","text":"<pre><code>array[index]\n</code></pre>"},{"location":"reference/specification/#import-system","title":"Import System","text":"<pre><code>import {\n  package.ClassName;\n  package.OtherClass;\n}\n</code></pre>"},{"location":"reference/specification/#module-system","title":"Module System","text":"<pre><code>module package.name\n\n// Class definitions\n</code></pre>"},{"location":"reference/specification/#visibility-modifiers","title":"Visibility Modifiers","text":"<ul> <li>Private (default): Members are private unless marked public</li> <li>Public: Declared in <code>public:</code> section</li> </ul> <pre><code>class Example {\n  var privateMember: Int\n\n  public:\n    var publicMember: Int\n\n    def publicMethod {\n      // ...\n    }\n}\n</code></pre>"},{"location":"reference/specification/#delegation","title":"Delegation","text":"<pre><code>class MyClass &lt;: Interface {\n  forward val member: Interface;\n\n  public:\n    def this {\n      this.member = new Implementation;\n    }\n}\n</code></pre> <p>The <code>forward</code> directive automatically delegates interface methods to the specified member.</p>"},{"location":"reference/specification/#type-conversions","title":"Type Conversions","text":""},{"location":"reference/specification/#widening-conversions-automatic","title":"Widening Conversions (Automatic)","text":"<ul> <li><code>Byte</code> \u2192 <code>Short</code> \u2192 <code>Int</code> \u2192 <code>Long</code> \u2192 <code>Float</code> \u2192 <code>Double</code></li> <li><code>Char</code> \u2192 <code>Int</code></li> </ul>"},{"location":"reference/specification/#narrowing-conversions-explicit","title":"Narrowing Conversions (Explicit)","text":"<p>Require explicit cast using <code>$</code> operator:</p> <pre><code>val d: Double = 3.14\nval i: Int = d$Int\n</code></pre>"},{"location":"reference/specification/#current-limitations","title":"Current Limitations","text":"<p>As documented in the README:</p> <ol> <li>Abstract methods: Not fully validated at compile time</li> <li>Final methods: Override checking not complete</li> <li>Finally clause: Not yet supported in try-catch</li> <li>Edge cases: Compiler may crash on certain patterns</li> </ol>"},{"location":"reference/specification/#grammar-reference","title":"Grammar Reference","text":"<p>The complete grammar is defined in <code>grammar/JJOnionParser.jj</code> using JavaCC syntax.</p>"},{"location":"reference/specification/#next-steps","title":"Next Steps","text":"<ul> <li>Standard Library - Built-in functions and classes</li> <li>Compiler Architecture - How the compiler works</li> <li>Examples - Code examples</li> </ul>"},{"location":"reference/stdlib/","title":"Standard Library","text":"<p>Onion's standard library consists of built-in modules and interfaces for common functionality.</p>"},{"location":"reference/stdlib/#io-module","title":"IO Module","text":"<p>Console input and output operations.</p>"},{"location":"reference/stdlib/#ioprintln","title":"IO::println","text":"<p>Print a line to standard output:</p> <pre><code>IO::println(\"Hello, World!\")\nIO::println(\"Value: \" + value)\n</code></pre>"},{"location":"reference/stdlib/#ioprint","title":"IO::print","text":"<p>Print without newline:</p> <pre><code>IO::print(\"Enter name: \")\nval name: String = IO::readln()\n</code></pre>"},{"location":"reference/stdlib/#ioreadln","title":"IO::readln","text":"<p>Read a line of input from the user:</p> <pre><code>val name: String = IO::readln(\"What's your name? \")\nIO::println(\"Hello, \" + name)\n</code></pre>"},{"location":"reference/stdlib/#system-module","title":"System Module","text":"<p>Access to system-level operations via Java's <code>System</code> class.</p>"},{"location":"reference/stdlib/#systemout","title":"System::out","text":"<p>Standard output stream:</p> <pre><code>System::out.println(\"Direct system output\")\nSystem::out.print(\"No newline\")\n</code></pre>"},{"location":"reference/stdlib/#systemin","title":"System::in","text":"<p>Standard input stream:</p> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.InputStreamReader;\n}\n\nval reader: BufferedReader = new BufferedReader(\n  new InputStreamReader(System::in)\n)\n</code></pre>"},{"location":"reference/stdlib/#systemcurrenttimemillis","title":"System::currentTimeMillis","text":"<p>Get current time in milliseconds:</p> <pre><code>val time: Long = System::currentTimeMillis()\nIO::println(\"Current time: \" + time)\n</code></pre>"},{"location":"reference/stdlib/#systemgetproperty","title":"System::getProperty","text":"<p>Get system properties:</p> <pre><code>val os: String = System::getProperty(\"os.name\")\nval user: String = System::getProperty(\"user.name\")\nval home: String = System::getProperty(\"user.home\")\n</code></pre>"},{"location":"reference/stdlib/#systemexit","title":"System::exit","text":"<p>Exit the program:</p> <pre><code>System::exit(0)  // Success\nSystem::exit(1)  // Error\n</code></pre>"},{"location":"reference/stdlib/#math-module","title":"Math Module","text":"<p>Mathematical operations via Java's <code>Math</code> class.</p>"},{"location":"reference/stdlib/#mathrandom","title":"Math::random","text":"<p>Generate random number between 0.0 and 1.0:</p> <pre><code>val r: Double = Math::random()\nval randomInt: Int = (Math::random() * 100)$Int\n</code></pre>"},{"location":"reference/stdlib/#mathsqrt","title":"Math::sqrt","text":"<p>Square root:</p> <pre><code>val result: Double = Math::sqrt(16.0)  // 4.0\n</code></pre>"},{"location":"reference/stdlib/#mathpow","title":"Math::pow","text":"<p>Exponentiation:</p> <pre><code>val result: Double = Math::pow(2.0, 3.0)  // 8.0\n</code></pre>"},{"location":"reference/stdlib/#mathabs","title":"Math::abs","text":"<p>Absolute value:</p> <pre><code>val abs1: Int = Math::abs(-10)     // 10\nval abs2: Double = Math::abs(-3.14)  // 3.14\n</code></pre>"},{"location":"reference/stdlib/#mathmax-mathmin","title":"Math::max / Math::min","text":"<p>Maximum and minimum:</p> <pre><code>val max: Int = Math::max(10, 20)    // 20\nval min: Int = Math::min(10, 20)    // 10\n</code></pre>"},{"location":"reference/stdlib/#mathfloor-mathceil-mathround","title":"Math::floor / Math::ceil / Math::round","text":"<p>Rounding functions:</p> <pre><code>val floor: Double = Math::floor(3.7)  // 3.0\nval ceil: Double = Math::ceil(3.2)    // 4.0\nval round: Long = Math::round(3.5)    // 4\n</code></pre>"},{"location":"reference/stdlib/#mathsin-mathcos-mathtan","title":"Math::sin / Math::cos / Math::tan","text":"<p>Trigonometric functions (radians):</p> <pre><code>val sine: Double = Math::sin(Math::PI / 2)    // 1.0\nval cosine: Double = Math::cos(0.0)           // 1.0\nval tangent: Double = Math::tan(Math::PI / 4) // 1.0\n</code></pre>"},{"location":"reference/stdlib/#math-constants","title":"Math Constants","text":"<pre><code>val pi: Double = Math::PI       // 3.14159...\nval e: Double = Math::E         // 2.71828...\n</code></pre>"},{"location":"reference/stdlib/#function-interfaces","title":"Function Interfaces","text":"<p>Built-in function types for lambdas and closures.</p>"},{"location":"reference/stdlib/#function0","title":"Function0","text":"<p>Function with no parameters:</p> <pre><code>val func: Function0[Int] = () -&gt; { return 42; }\nval result: Int = func.call()\n</code></pre>"},{"location":"reference/stdlib/#function1","title":"Function1","text":"<p>Function with one parameter:</p> <pre><code>val double: Function1[Int, Int] = (x: Int) -&gt; { return x * 2; }\nval result: Int = double.call(5)\n</code></pre>"},{"location":"reference/stdlib/#function2","title":"Function2","text":"<p>Function with two parameters:</p> <pre><code>val add: Function2[Int, Int, Int] = (x: Int, y: Int) -&gt; { return x + y; }\nval result: Int = add.call(3, 7)\n</code></pre>"},{"location":"reference/stdlib/#function3-through-function10","title":"Function3 through Function10","text":"<p>Functions with 3 to 10 parameters follow the same pattern.</p>"},{"location":"reference/stdlib/#wrapper-classes","title":"Wrapper Classes","text":"<p>Java wrapper classes for primitives (accessed with <code>J</code> prefix in some contexts).</p>"},{"location":"reference/stdlib/#jinteger","title":"JInteger","text":"<p>Integer operations:</p> <pre><code>val i: Int = JInteger::parseInt(\"42\")\nval s: String = JInteger::toString(42)\nval max: Int = JInteger::MAX_VALUE\nval min: Int = JInteger::MIN_VALUE\n</code></pre>"},{"location":"reference/stdlib/#jlong","title":"JLong","text":"<p>Long operations:</p> <pre><code>val l: Long = JLong::parseLong(\"1234567890\")\nval s: String = JLong::toString(1234567890L)\n</code></pre>"},{"location":"reference/stdlib/#jdouble","title":"JDouble","text":"<p>Double operations:</p> <pre><code>val d: Double = JDouble::parseDouble(\"3.14\")\nval s: String = JDouble::toString(3.14)\n</code></pre>"},{"location":"reference/stdlib/#jboolean","title":"JBoolean","text":"<p>Boolean operations:</p> <pre><code>val b: Boolean = JBoolean::parseBoolean(\"true\")\nval s: String = JBoolean::toString(true)\n</code></pre>"},{"location":"reference/stdlib/#common-java-classes","title":"Common Java Classes","text":"<p>Frequently used Java standard library classes.</p>"},{"location":"reference/stdlib/#string","title":"String","text":"<p>String operations (automatically available):</p> <pre><code>val text: String = \"Hello, World!\"\nval upper: String = text.toUpperCase()\nval lower: String = text.toLowerCase()\nval length: Int = text.length()\nval sub: String = text.substring(0, 5)\nval contains: Boolean = text.contains(\"World\")\nval starts: Boolean = text.startsWith(\"Hello\")\nval ends: Boolean = text.endsWith(\"!\")\n</code></pre>"},{"location":"reference/stdlib/#stringbuilder","title":"StringBuilder","text":"<p>Efficient string building:</p> <pre><code>import { java.lang.StringBuilder; }\n\nval builder: StringBuilder = new StringBuilder()\nbuilder.append(\"Hello\")\nbuilder.append(\" \")\nbuilder.append(\"World\")\nval result: String = builder.toString()\n</code></pre>"},{"location":"reference/stdlib/#arraylist","title":"ArrayList","text":"<p>Dynamic arrays:</p> <pre><code>import { java.util.ArrayList; }\n\nval list: ArrayList = new ArrayList\nlist.add(\"First\")\nlist &lt;&lt; \"Second\"  // Using &lt;&lt; operator\nval size: Int = list.size()\nval item: Object = list.get(0)\nlist.remove(0)\nval empty: Boolean = list.isEmpty()\n</code></pre>"},{"location":"reference/stdlib/#hashmap","title":"HashMap","text":"<p>Key-value maps:</p> <pre><code>import { java.util.HashMap; }\n\nval map: HashMap = new HashMap\nmap.put(\"key1\", \"value1\")\nmap.put(\"key2\", \"value2\")\nval value: Object = map.get(\"key1\")\nval has: Boolean = map.containsKey(\"key1\")\nval size: Int = map.size()\n</code></pre>"},{"location":"reference/stdlib/#file","title":"File","text":"<p>File operations:</p> <pre><code>import { java.io.File; }\n\nval file: File = new File(\"data.txt\")\nval exists: Boolean = file.exists()\nval isFile: Boolean = file.isFile()\nval isDir: Boolean = file.isDirectory()\nval name: String = file.getName()\nval path: String = file.getPath()\nval length: Long = file.length()\n</code></pre>"},{"location":"reference/stdlib/#bufferedreader","title":"BufferedReader","text":"<p>Reading text:</p> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.FileReader;\n}\n\nval reader: BufferedReader = new BufferedReader(\n  new FileReader(\"file.txt\")\n)\n\nvar line: String = null\nwhile (line = reader.readLine()) != null {\n  IO::println(line)\n}\n\nreader.close()\n</code></pre>"},{"location":"reference/stdlib/#bufferedwriter","title":"BufferedWriter","text":"<p>Writing text:</p> <pre><code>import {\n  java.io.BufferedWriter;\n  java.io.FileWriter;\n}\n\nval writer: BufferedWriter = new BufferedWriter(\n  new FileWriter(\"output.txt\")\n)\n\nwriter.write(\"Hello, World!\")\nwriter.newLine()\nwriter.close()\n</code></pre>"},{"location":"reference/stdlib/#iterables-module","title":"Iterables Module","text":"<p>Provided via <code>onion.Iterables</code> (Java interface).</p> <p>Access iteration utilities for collections and arrays.</p>"},{"location":"reference/stdlib/#next-steps","title":"Next Steps","text":"<ul> <li>Language Specification - Formal language spec</li> <li>Compiler Architecture - Compiler internals</li> <li>Java Interoperability - Using Java libraries</li> </ul>"},{"location":"tools/compiler/","title":"Compiler (onionc)","text":"<p>The <code>onionc</code> command compiles Onion source files into JVM class files.</p>"},{"location":"tools/compiler/#usage","title":"Usage","text":"<pre><code>onionc [options] source files...\n</code></pre>"},{"location":"tools/compiler/#options","title":"Options","text":""},{"location":"tools/compiler/#-classpath-classpath","title":"<code>-classpath &lt;classpath&gt;</code>","text":"<p>Set the classpath for compilation. Used when your code references external Java libraries or other compiled Onion classes.</p> <pre><code>onionc -classpath lib/mylib.jar:lib/other.jar MyProgram.on\n</code></pre>"},{"location":"tools/compiler/#-encoding-encoding","title":"<code>-encoding &lt;encoding&gt;</code>","text":"<p>Specify the character encoding of source files. Default is platform-dependent.</p> <pre><code>onionc -encoding UTF-8 MyProgram.on\n</code></pre>"},{"location":"tools/compiler/#-d-output-directory","title":"<code>-d &lt;output directory&gt;</code>","text":"<p>Set the output directory for generated class files. If not specified, classes are written to the current directory.</p> <pre><code>onionc -d build/classes MyProgram.on\n</code></pre> <p>Class files are organized by module name: - Unix-like: <code>org/onion_lang/MyClass.class</code> - Windows: <code>org\\onion_lang\\MyClass.class</code></p>"},{"location":"tools/compiler/#-maxerrorreports-count","title":"<code>-maxErrorReports &lt;count&gt;</code>","text":"<p>Limit the number of compilation errors reported. Useful for large projects with many errors.</p> <pre><code>onionc -maxErrorReports 10 MyProgram.on\n</code></pre>"},{"location":"tools/compiler/#examples","title":"Examples","text":""},{"location":"tools/compiler/#basic-compilation","title":"Basic Compilation","text":"<p>Compile a single file:</p> <pre><code>onionc Hello.on\n</code></pre> <p>This creates <code>Hello.class</code> in the current directory.</p>"},{"location":"tools/compiler/#multiple-files","title":"Multiple Files","text":"<p>Compile multiple source files:</p> <pre><code>onionc Person.on Employee.on Manager.on\n</code></pre>"},{"location":"tools/compiler/#with-output-directory","title":"With Output Directory","text":"<p>Organize output:</p> <pre><code>onionc -d out/classes src/Main.on src/Utils.on\n</code></pre> <p>Class files appear in <code>out/classes/</code>.</p>"},{"location":"tools/compiler/#with-classpath","title":"With Classpath","text":"<p>Reference external libraries:</p> <pre><code>onionc -classpath lib/gson-2.8.jar:lib/commons-lang.jar \\\n       src/JsonParser.on\n</code></pre>"},{"location":"tools/compiler/#complete-example","title":"Complete Example","text":"<pre><code>onionc \\\n  -d build/classes \\\n  -classpath lib/external.jar \\\n  -encoding UTF-8 \\\n  -maxErrorReports 20 \\\n  src/*.on\n</code></pre>"},{"location":"tools/compiler/#running-compiled-programs","title":"Running Compiled Programs","text":"<p>After compilation, run with Java:</p> <pre><code># Compile\nonionc -d build Main.on\n\n# Run with Java\njava -cp build Main\n</code></pre> <p>Or with a JAR:</p> <pre><code># Compile\nonionc -d build Main.on Helper.on\n\n# Create JAR\njar cvfe program.jar Main -C build .\n\n# Run JAR\njava -jar program.jar\n</code></pre>"},{"location":"tools/compiler/#module-organization","title":"Module Organization","text":"<p>Onion uses module names (packages) similar to Java:</p> <p>MyClass.on: <pre><code>module com.example.myapp\n\nclass MyClass {\n  public:\n    static def main(args :String[]) {\n      IO::println(\"Hello\")\n    }\n}\n</code></pre></p> <p>Compile: <pre><code>onionc -d build MyClass.on\n</code></pre></p> <p>Output: <pre><code>build/com/example/myapp/MyClass.class\n</code></pre></p> <p>Run: <pre><code>java -cp build com.example.myapp.MyClass\n</code></pre></p>"},{"location":"tools/compiler/#compilation-errors","title":"Compilation Errors","text":""},{"location":"tools/compiler/#common-errors","title":"Common Errors","text":"<p>Type mismatch: <pre><code>Error: Type mismatch\n  Expected: Int\n  Found: String\n  at MyProgram.on:10\n</code></pre></p> <p>Undefined variable: <pre><code>Error: Undefined variable 'count'\n  at MyProgram.on:15\n</code></pre></p> <p>Method not found: <pre><code>Error: Method 'getValue()' not found in class Person\n  at MyProgram.on:23\n</code></pre></p>"},{"location":"tools/compiler/#incremental-compilation","title":"Incremental Compilation","text":"<p><code>onionc</code> compiles all specified files each time. For large projects, consider:</p> <ol> <li>Compile only changed files</li> <li>Use a build tool (Make, SBT, Gradle)</li> <li>Organize code into modules</li> </ol>"},{"location":"tools/compiler/#build-integration","title":"Build Integration","text":""},{"location":"tools/compiler/#makefile-example","title":"Makefile Example","text":"<pre><code>SRC_DIR = src\nOUT_DIR = build/classes\nSOURCES = $(wildcard $(SRC_DIR)/*.on)\n\nall: compile\n\ncompile:\n    mkdir -p $(OUT_DIR)\n    onionc -d $(OUT_DIR) $(SOURCES)\n\nclean:\n    rm -rf $(OUT_DIR)\n\nrun: compile\n    java -cp $(OUT_DIR) Main\n</code></pre>"},{"location":"tools/compiler/#shell-script-example","title":"Shell Script Example","text":"<pre><code>#!/bin/bash\n\nSRC_DIR=\"src\"\nOUT_DIR=\"build/classes\"\nCLASSPATH=\"lib/*\"\n\nmkdir -p \"$OUT_DIR\"\n\necho \"Compiling Onion sources...\"\nonionc -d \"$OUT_DIR\" -classpath \"$CLASSPATH\" \"$SRC_DIR\"/*.on\n\nif [ $? -eq 0 ]; then\n    echo \"Compilation successful\"\n    echo \"Running program...\"\n    java -cp \"$OUT_DIR:$CLASSPATH\" Main\nelse\n    echo \"Compilation failed\"\n    exit 1\nfi\n</code></pre>"},{"location":"tools/compiler/#compiler-output","title":"Compiler Output","text":""},{"location":"tools/compiler/#successful-compilation","title":"Successful Compilation","text":"<p>No output typically means success:</p> <pre><code>$ onionc Hello.on\n$ ls\nHello.class  Hello.on\n</code></pre>"},{"location":"tools/compiler/#compilation-errors_1","title":"Compilation Errors","text":"<p>Errors are written to standard error:</p> <pre><code>$ onionc BadProgram.on\nError: Type mismatch at BadProgram.on:5\nError: Undefined variable at BadProgram.on:10\nCompilation failed with 2 errors\n</code></pre>"},{"location":"tools/compiler/#next-steps","title":"Next Steps","text":"<ul> <li>Script Runner - Run Onion scripts directly</li> <li>REPL Shell - Interactive programming</li> <li>Building from Source - Build the compiler</li> </ul>"},{"location":"tools/repl/","title":"REPL Shell","text":"<p>The Onion REPL (Read-Eval-Print Loop) provides an interactive environment for experimenting with Onion code.</p>"},{"location":"tools/repl/#starting-the-repl","title":"Starting the REPL","text":"<p>Launch the interactive shell:</p> <pre><code># Using SBT (for development)\nsbt\n&gt; runMain onion.tools.Shell\n\n# Or if you have the onion-shell command\nonion-shell\n</code></pre>"},{"location":"tools/repl/#basic-usage","title":"Basic Usage","text":""},{"location":"tools/repl/#simple-expressions","title":"Simple Expressions","text":"<pre><code>onion&gt; 2 + 2\n4\n\nonion&gt; \"Hello\" + \" \" + \"World\"\nHello World\n\nonion&gt; 10 * 5\n50\n</code></pre>"},{"location":"tools/repl/#variable-definitions","title":"Variable Definitions","text":"<pre><code>onion&gt; val x: Int = 42\nx: Int = 42\n\nonion&gt; val name: String = \"Alice\"\nname: String = Alice\n\nonion&gt; IO::println(name)\nAlice\n</code></pre>"},{"location":"tools/repl/#function-calls","title":"Function Calls","text":"<pre><code>onion&gt; Math::sqrt(16.0)\n4.0\n\nonion&gt; \"hello\".toUpperCase()\nHELLO\n\nonion&gt; Math::max(10, 20)\n20\n</code></pre>"},{"location":"tools/repl/#defining-functions","title":"Defining Functions","text":"<pre><code>onion&gt; def square(x: Int): Int = x * x\nsquare: (Int) -&gt; Int\n\nonion&gt; square(5)\n25\n\nonion&gt; def greet(name: String): String = \"Hello, \" + name\ngreet: (String) -&gt; String\n\nonion&gt; greet(\"World\")\nHello, World\n</code></pre>"},{"location":"tools/repl/#working-with-classes","title":"Working with Classes","text":""},{"location":"tools/repl/#import-classes","title":"Import Classes","text":"<pre><code>onion&gt; import { java.util.ArrayList; }\n\nonion&gt; val list: ArrayList = new ArrayList\nlist: ArrayList = []\n\nonion&gt; list.add(\"First\")\ntrue\n\nonion&gt; list.add(\"Second\")\ntrue\n\nonion&gt; list.size()\n2\n</code></pre>"},{"location":"tools/repl/#define-classes","title":"Define Classes","text":"<pre><code>onion&gt; class Point {\n         val x: Int\n         val y: Int\n         public:\n           def this(x: Int, y: Int) {\n             this.x = x\n             this.y = y\n           }\n           def distance: Double = Math::sqrt(this.x * this.x + this.y * this.y)\n       }\n\nonion&gt; val p: Point = new Point(3, 4)\np: Point = Point@1a2b3c4d\n\nonion&gt; p.distance()\n5.0\n</code></pre>"},{"location":"tools/repl/#lambda-expressions","title":"Lambda Expressions","text":"<pre><code>onion&gt; val double: (Int) -&gt; Int = (x: Int) -&gt; { return x * 2; }\ndouble: (Int) -&gt; Int\n\nonion&gt; double.call(5)\n10\n\nonion&gt; val add: (Int, Int) -&gt; Int = (a: Int, b: Int) -&gt; { return a + b; }\nadd: (Int, Int) -&gt; Int\n\nonion&gt; add.call(3, 7)\n10\n</code></pre>"},{"location":"tools/repl/#multi-line-input","title":"Multi-line Input","text":"<p>For complex expressions, use multiple lines:</p> <pre><code>onion&gt; def factorial(n :Int) :Int {\n         if n &lt;= 1 {\n           return 1;\n         } else {\n           return n * factorial(n - 1);\n         }\n       }\n\nonion&gt; factorial(5)\n120\n</code></pre>"},{"location":"tools/repl/#viewing-previous-results","title":"Viewing Previous Results","text":"<p>The REPL stores results for quick reference:</p> <pre><code>onion&gt; 2 + 2\nres0: Int = 4\n\nonion&gt; res0 * 10\nres1: Int = 40\n\nonion&gt; res1 + res0\n44\n</code></pre>"},{"location":"tools/repl/#helpful-commands","title":"Helpful Commands","text":""},{"location":"tools/repl/#get-help","title":"Get Help","text":"<pre><code>onion&gt; :help\nAvailable commands:\n  :help    - Show this help message\n  :quit    - Exit the REPL\n  :reset   - Reset the session\n  :imports - Show current imports\n</code></pre>"},{"location":"tools/repl/#show-imports","title":"Show Imports","text":"<pre><code>onion&gt; :imports\nCurrent imports:\n  java.util.ArrayList\n  java.io.File\n</code></pre>"},{"location":"tools/repl/#exit-the-repl","title":"Exit the REPL","text":"<pre><code>onion&gt; :quit\nGoodbye!\n</code></pre> <p>Or use <code>Ctrl+D</code> (Unix) / <code>Ctrl+Z</code> (Windows).</p>"},{"location":"tools/repl/#practical-examples","title":"Practical Examples","text":""},{"location":"tools/repl/#quick-math","title":"Quick Math","text":"<pre><code>onion&gt; def hypotenuse(a: Double, b: Double): Double = Math::sqrt(a * a + b * b)\n\nonion&gt; hypotenuse(3.0, 4.0)\n5.0\n\nonion&gt; hypotenuse(5.0, 12.0)\n13.0\n</code></pre>"},{"location":"tools/repl/#string-manipulation","title":"String Manipulation","text":"<pre><code>onion&gt; val text: String = \"Hello, World!\"\nonion&gt; text.length()\n13\n\nonion&gt; text.toUpperCase()\nHELLO, WORLD!\n\nonion&gt; text.substring(0, 5)\nHello\n</code></pre>"},{"location":"tools/repl/#collections","title":"Collections","text":"<pre><code>onion&gt; import { java.util.ArrayList; }\n\nonion&gt; val numbers: ArrayList = new ArrayList\nonion&gt; numbers &lt;&lt; 10\nonion&gt; numbers &lt;&lt; 20\nonion&gt; numbers &lt;&lt; 30\n\nonion&gt; numbers.size()\n3\n\nonion&gt; numbers.get(1)\n20\n</code></pre>"},{"location":"tools/repl/#testing-code-snippets","title":"Testing Code Snippets","text":"<pre><code>onion&gt; def isPrime(n :Int) :Boolean {\n         if n &lt;= 1 {\n           return false\n         }\n         for var i: Int = 2; i * i &lt;= n; i = i + 1 {\n           if n % i == 0 {\n             return false\n           }\n         }\n         return true\n       }\n\nonion&gt; isPrime(7)\ntrue\n\nonion&gt; isPrime(10)\nfalse\n\nonion&gt; isPrime(17)\ntrue\n</code></pre>"},{"location":"tools/repl/#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"tools/repl/#quick-prototyping","title":"Quick Prototyping","text":"<p>Use the REPL to test ideas before writing full programs:</p> <pre><code>onion&gt; // Test string formatting\nonion&gt; def format(name: String, age: Int): String = name + \" is \" + age + \" years old\"\n\nonion&gt; format(\"Alice\", 30)\nAlice is 30 years old\n</code></pre>"},{"location":"tools/repl/#debugging","title":"Debugging","text":"<p>Test individual functions:</p> <pre><code>onion&gt; def calculate(x :Int) :Int {\n         val temp: Int = x * 2\n         IO::println(\"temp = \" + temp)\n         return temp + 10\n       }\n\nonion&gt; calculate(5)\ntemp = 10\n20\n</code></pre>"},{"location":"tools/repl/#learning","title":"Learning","text":"<p>Experiment with language features:</p> <pre><code>onion&gt; // Test type casting\nonion&gt; val x: Double = 3.14\nonion&gt; val y: Int = x$Int\nonion&gt; IO::println(y)\n3\n\nonion&gt; // Test closures\nonion&gt; def makeAdder(n: Int): (Int) -&gt; Int = (x: Int) -&gt; { return x + n; }\nonion&gt; val add5: (Int) -&gt; Int = makeAdder(5)\nonion&gt; add5.call(10)\n15\n</code></pre>"},{"location":"tools/repl/#limitations","title":"Limitations","text":"<ul> <li>Session state is lost when you exit</li> <li>No command history persistence (use arrow keys during session)</li> <li>Limited debugging capabilities</li> <li>Performance not optimized for large computations</li> </ul>"},{"location":"tools/repl/#use-cases","title":"Use Cases","text":"<p>Perfect for: - Learning Onion syntax - Testing code snippets - Quick calculations - Prototyping functions - Exploring Java libraries</p> <p>Not ideal for: - Large programs - File I/O heavy tasks - Long-running processes - Production code</p>"},{"location":"tools/repl/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn more syntax</li> <li>Examples - See example programs</li> <li>Language Guide - Deep dive into features</li> </ul>"},{"location":"tools/script-runner/","title":"Script Runner (onion)","text":"<p>The <code>onion</code> command compiles and executes Onion source files directly in memory, without creating <code>.class</code> files.</p>"},{"location":"tools/script-runner/#usage","title":"Usage","text":"<pre><code>onion [options] source files... [program arguments]\n</code></pre>"},{"location":"tools/script-runner/#options","title":"Options","text":""},{"location":"tools/script-runner/#-classpath-classpath","title":"<code>-classpath &lt;classpath&gt;</code>","text":"<p>Set the classpath for compilation and execution.</p> <pre><code>onion -classpath lib/mylib.jar MyScript.on\n</code></pre>"},{"location":"tools/script-runner/#-encoding-encoding","title":"<code>-encoding &lt;encoding&gt;</code>","text":"<p>Specify the character encoding of source files.</p> <pre><code>onion -encoding UTF-8 MyScript.on\n</code></pre>"},{"location":"tools/script-runner/#-maxerrorreports-count","title":"<code>-maxErrorReports &lt;count&gt;</code>","text":"<p>Limit the number of compilation errors reported.</p> <pre><code>onion -maxErrorReports 10 MyScript.on\n</code></pre>"},{"location":"tools/script-runner/#program-arguments","title":"Program Arguments","text":"<p>Arguments after the source file(s) are passed to your program:</p> <pre><code>onion MyScript.on arg1 arg2 arg3\n</code></pre> <p>Access them in your code:</p> <pre><code>class MyScript {\n  public:\n    static def main(args :String[]) {\n      foreach arg :String in args {\n        IO::println(\"Argument: \" + arg)\n      }\n    }\n}\n</code></pre>"},{"location":"tools/script-runner/#entry-point","title":"Entry Point","text":"<p>The script runner determines the entry point automatically:</p>"},{"location":"tools/script-runner/#1-explicit-main-method","title":"1. Explicit Main Method","text":"<p>If a class has a <code>main</code> method, it's used as the entry point:</p> <pre><code>class MyProgram {\n  public:\n    static def main(args :String[]) {\n      IO::println(\"Hello from main method\")\n    }\n}\n</code></pre>"},{"location":"tools/script-runner/#2-first-class-with-main","title":"2. First Class with Main","text":"<p>If multiple classes have <code>main</code> methods, the first one is used:</p> <pre><code>class First {\n  public:\n    static def main(args :String[]) {\n      IO::println(\"This will run\")\n    }\n}\n\nclass Second {\n  public:\n    static def main(args :String[]) {\n      IO::println(\"This won't run\")\n    }\n}\n</code></pre>"},{"location":"tools/script-runner/#3-top-level-statements","title":"3. Top-Level Statements","text":"<p>If there's no explicit <code>main</code> method, the first top-level statement is the entry point:</p> <pre><code>IO::println(\"Hello, World!\")\n\nval x: Int = 10\nIO::println(\"x = \" + x)\n\n// These statements execute immediately\n</code></pre>"},{"location":"tools/script-runner/#examples","title":"Examples","text":""},{"location":"tools/script-runner/#simple-script","title":"Simple Script","text":"<p>hello.on: <pre><code>IO::println(\"Hello, World!\")\n</code></pre></p> <p>Run: <pre><code>$ onion hello.on\nHello, World!\n</code></pre></p>"},{"location":"tools/script-runner/#with-arguments","title":"With Arguments","text":"<p>greet.on: <pre><code>class Greeter {\n  public:\n    static def main(args :String[]) {\n      if args.length &gt; 0 {\n        IO::println(\"Hello, \" + args[0] + \"!\")\n      } else {\n        IO::println(\"Hello, stranger!\")\n      }\n    }\n}\n</code></pre></p> <p>Run: <pre><code>$ onion greet.on Alice\nHello, Alice!\n\n$ onion greet.on\nHello, stranger!\n</code></pre></p>"},{"location":"tools/script-runner/#quick-calculations","title":"Quick Calculations","text":"<p>calc.on: <pre><code>val a: Int = 10\nval b: Int = 20\nIO::println(\"Sum: \" + (a + b))\nIO::println(\"Product: \" + (a * b))\n</code></pre></p> <p>Run: <pre><code>$ onion calc.on\nSum: 30\nProduct: 200\n</code></pre></p>"},{"location":"tools/script-runner/#file-processing","title":"File Processing","text":"<p>count_lines.on: <pre><code>import {\n  java.io.BufferedReader;\n  java.io.FileReader;\n}\n\nclass LineCounter {\n  public:\n    static def main(args :String[]) {\n      if args.length == 0 {\n        IO::println(\"Usage: onion count_lines.on &lt;filename&gt;\")\n        return\n      }\n\n      val filename: String = args[0]\n      val reader: BufferedReader = new BufferedReader(\n        new FileReader(filename)\n      )\n\n      var count: Int = 0\n      var line: String = null\n      while (line = reader.readLine()) != null {\n        count = count + 1\n      }\n\n      reader.close()\n      IO::println(\"Lines: \" + count)\n    }\n}\n</code></pre></p> <p>Run: <pre><code>$ onion count_lines.on data.txt\nLines: 42\n</code></pre></p>"},{"location":"tools/script-runner/#in-memory-compilation","title":"In-Memory Compilation","text":"<p>The <code>onion</code> command:</p> <ol> <li>Compiles source files to bytecode</li> <li>Loads classes into memory</li> <li>Executes the entry point</li> <li>No <code>.class</code> files are created</li> </ol> <p>This is ideal for: - Quick scripts - Testing code snippets - Automation tasks - One-off programs</p>"},{"location":"tools/script-runner/#multiple-source-files","title":"Multiple Source Files","text":"<p>Compile and run multiple files:</p> <pre><code>onion Main.on Utils.on Helper.on\n</code></pre> <p>All files are compiled together, and the entry point is determined from the first file.</p>"},{"location":"tools/script-runner/#error-handling","title":"Error Handling","text":""},{"location":"tools/script-runner/#compilation-errors","title":"Compilation Errors","text":"<pre><code>$ onion bad_syntax.on\nError: Type mismatch at bad_syntax.on:5\nCompilation failed\n</code></pre>"},{"location":"tools/script-runner/#runtime-errors","title":"Runtime Errors","text":"<pre><code>$ onion runtime_error.on\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n    at RuntimeError.main(runtime_error.on:10)\n</code></pre>"},{"location":"tools/script-runner/#comparison-with-onionc","title":"Comparison with onionc","text":"Feature onion onionc Creates .class files No Yes Execution Immediate Requires <code>java</code> command Use case Scripts, testing Production, libraries Speed Fast for small programs Better for repeated runs Distribution Requires source Can distribute .class/.jar"},{"location":"tools/script-runner/#scripting-best-practices","title":"Scripting Best Practices","text":""},{"location":"tools/script-runner/#shebang-line-unix-like-systems","title":"Shebang Line (Unix-like systems)","text":"<p>Make scripts executable:</p> <p>hello.on: <pre><code>#!/usr/bin/env onion\nIO::println(\"Hello from script!\")\n</code></pre></p> <p>Make executable: <pre><code>chmod +x hello.on\n./hello.on\n</code></pre></p>"},{"location":"tools/script-runner/#error-messages","title":"Error Messages","text":"<p>Provide helpful error messages:</p> <pre><code>class Script {\n  public:\n    static def main(args :String[]) {\n      if args.length &lt; 2 {\n        IO::println(\"Error: Missing arguments\")\n        IO::println(\"Usage: onion script.on &lt;input&gt; &lt;output&gt;\")\n        return\n      }\n\n      // Process arguments...\n    }\n}\n</code></pre>"},{"location":"tools/script-runner/#exit-codes","title":"Exit Codes","text":"<p>Return appropriate exit codes:</p> <pre><code>class Script {\n  public:\n    static def main(args :String[]) {\n      if args.length == 0 {\n        System::exit(1)  // Error\n      }\n\n      // Success\n      System::exit(0)\n    }\n}\n</code></pre>"},{"location":"tools/script-runner/#next-steps","title":"Next Steps","text":"<ul> <li>Compiler (onionc) - Compile to class files</li> <li>REPL Shell - Interactive programming</li> <li>Examples - Example scripts</li> </ul>"}]}