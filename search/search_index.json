{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Onion Programming Language","text":"<p>Onion is a statically-typed, object-oriented programming language that compiles to JVM bytecode. It combines the power of static typing with a concise, expressive syntax and seamless Java interoperability.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Statically Typed - Catch errors at compile time with full type inference</li> <li>Object-Oriented - Classes, inheritance, interfaces, and method overloading</li> <li>Functional Elements - Lambda expressions, closures, and first-class functions</li> <li>Java Interoperability - Direct access to Java libraries and frameworks</li> <li>JVM Target - Compiles to efficient JVM bytecode</li> <li>Concise Syntax - Clean, readable code with minimal boilerplate</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>// Hello World\nIO::println(\"Hello, World!\")\n\n// Class definition with inheritance\nclass Calculator : JFrame &lt;: ActionListener {\n  @result :Long\n\n  public:\n    def new {\n      // Constructor logic\n    }\n\n    def calculate(x :Long, y :Long) :Long {\n      x + y\n    }\n}\n\n// Lambda expressions\ndef filter = #(line :String) {\n  line.startsWith(\"ERROR\")\n}\n\n// Pattern matching with select\nselect value {\n  case 0, 1, 2:\n    IO::println(\"Low\")\n  case 3, 4, 5:\n    IO::println(\"Medium\")\n  else:\n    IO::println(\"High\")\n}\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide - Set up Onion on your system</li> <li>Hello World Tutorial - Your first Onion program</li> <li>Quick Start - Essential language features</li> </ul>"},{"location":"#language-guide","title":"Language Guide","text":"<ul> <li>Overview - Language philosophy and design</li> <li>Basic Syntax - Variables, operators, and expressions</li> <li>Control Flow - if, while, for, foreach, and select</li> <li>Functions - Function definitions and lambda expressions</li> <li>Classes and Objects - Object-oriented programming</li> <li>Java Interoperability - Using Java libraries</li> </ul>"},{"location":"#tools","title":"Tools","text":"<ul> <li>onionc - Compile Onion source files to .class files</li> <li>onion - Run Onion scripts directly (compile and execute)</li> <li>Shell - Interactive REPL for experimentation</li> </ul>"},{"location":"#project-history","title":"Project History","text":"<p>Originally written in Java in 2005, Onion has been completely rewritten in Scala 3.6.2, with only the parser using JavaCC. The compiler follows a classic multi-phase architecture:</p> <ol> <li>Parsing - JavaCC-generated parser produces untyped AST</li> <li>Rewriting - AST normalization and transformation</li> <li>Type Checking - Type inference and validation</li> <li>Code Generation - ASM-based bytecode generation</li> </ol>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>Onion is open source software. See LICENSE for details.</p> <p>This software includes software developed by Apache Software Foundation.</p>"},{"location":"GENERICS_DESIGN/","title":"Generics (Erasure-Based) \u2013 Design &amp; TODO","text":"<p>Goal: Add basic generics with Scala-style erasure (upper bounds, generic classes/methods, bridge emission for overriding). Deliver in small PR-sized steps.</p>"},{"location":"GENERICS_DESIGN/#scope","title":"Scope","text":"<ul> <li>Type params on classes/methods with optional upper bounds using <code>extends</code> (e.g., <code>T extends Foo</code>). No variance for now. Syntax uses brackets <code>[]</code> for both definitions and applications: <code>class Box[T extends Foo]</code>, <code>def id[T extends Foo](x: T): T</code>.</li> <li>Type applications on types/expressions: <code>Box[Int]</code>, <code>foo[String](x)</code> (brackets only).</li> <li>Erasure: map type params to <code>Object</code> or bound\u2019s erasure in JVM signatures. Emit bridges when overriding causes erased signature collisions.</li> </ul> <p>Out of scope (for later): variance, wildcards, lower bounds, reified generics, generic fields with runtime type info, constraints beyond single upper bound.</p>"},{"location":"GENERICS_DESIGN/#incremental-plan","title":"Incremental Plan","text":""},{"location":"GENERICS_DESIGN/#1-grammar-ast","title":"1) Grammar &amp; AST","text":"<ul> <li>Extend grammar (JavaCC) to parse:</li> <li>Type parameter lists on classes/methods: <code>[T]</code> / <code>[T &lt;: Bound]</code> (brackets unified with applications).</li> <li>Type applications on types and expressions: <code>Foo[Bar]</code>.</li> <li>AST changes (parser-level <code>AST</code>):</li> <li>Add <code>TypeParameter(name, upperBound: Option[TypeNode])</code>.</li> <li>Add <code>TypeApplication(target: TypeNode, args: List[TypeNode])</code>.</li> <li>Thread type params into <code>ClassDeclaration</code>, <code>MethodDeclaration</code>, <code>FunctionDeclaration</code>, <code>ClosureExpression</code> if applicable.</li> <li>Thread type args into <code>NewObject</code>, <code>StaticMethodCall</code>, <code>MethodCall</code>, <code>StaticMemberSelection</code> when present.</li> <li>Regenerate parser sources (JavaCC) after grammar updates.</li> </ul> <p>Checkpoint: Parser builds; AST nodes produced for simple examples like <code>class Box[T] { def get(x: T): T = x }</code> and <code>new Box[Int]()</code>.</p>"},{"location":"GENERICS_DESIGN/#2-typed-ast-typing","title":"2) Typed AST &amp; Typing","text":"<ul> <li>Typed model additions:</li> <li><code>TypedAST.TypeParameter(name, upperBound: IRT.Type)</code> and <code>TypeApplication</code> nodes.</li> <li>Include type params on <code>ClassDefinition</code>, <code>MethodDefinition</code>.</li> <li>Environment/bindings:</li> <li>Track type param scopes (class-level + method-level) with bounds.</li> <li>Validate type argument arity at use sites.</li> <li>Bound checking: substitute type args into bounds, ensure conformity (erased to bound when unknown).</li> <li>Erasure semantics in typing:</li> <li>Compute erased type for type params: <code>erasure(T) = erasure(bound)</code> else <code>Object</code>.</li> <li>Erase generic method/class types for codegen signatures.</li> <li>Type inference: initially not implemented; require explicit type arguments at calls.</li> </ul> <p>Checkpoint: Typing accepts generic class/method definitions and applications, rejects arity/bound errors, produces TypedAST with erased info attached.</p>"},{"location":"GENERICS_DESIGN/#3-code-generation-asm","title":"3) Code Generation (ASM)","text":"<ul> <li>Signature computation: use erased types for descriptors.</li> <li>Bridge methods:</li> <li>When a subclass overrides a generic parent method where the erased signature would differ, emit a bridge that delegates to the typed implementation.</li> <li>Detect collisions during method table assembly (compare erased names+descs).</li> <li>Class/method naming: no mangling beyond erasure; rely on bridges for dispatch correctness.</li> </ul> <p>Checkpoint: Bytecode for generic hierarchies loads and runs; overridden generic methods dispatch correctly via bridges.</p>"},{"location":"GENERICS_DESIGN/#testing-plan","title":"Testing Plan","text":"<ul> <li>Parser round-trips: generic class/method definitions and instantiations.</li> <li>Typing: arity/bound errors; correct acceptance of <code>Box[Int]</code>, rejection of <code>Box[Int, String]</code>.</li> <li>Runtime: execute small programs with generic collections/identity methods; override scenarios that require bridges.</li> <li>Non-generic regressions: full existing test suite.</li> </ul>"},{"location":"GENERICS_DESIGN/#notes","title":"Notes","text":"<ul> <li>Keep resource strings (errors) consistent; add new keys for arity/bound errors.</li> <li>Maintain backward compatibility: existing non-generic code should compile unchanged.</li> <li>Consider feature flags if rollout needs to be staged; otherwise, ship as a single feature branch with checkpoints.</li> </ul>"},{"location":"parser-refactoring/","title":"Parser Refactoring: Separating Grammar from AST Building","text":""},{"location":"parser-refactoring/#overview","title":"Overview","text":"<p>This refactoring introduces the Builder pattern to separate parsing concerns from AST construction in the Onion compiler. This separation provides several benefits:</p> <ol> <li>Testability: AST construction can be tested independently of parsing</li> <li>Flexibility: Different AST builders can be used for different purposes</li> <li>Maintainability: Grammar changes don't require AST construction changes and vice versa</li> <li>Extensibility: New behaviors can be added without modifying the parser</li> </ol>"},{"location":"parser-refactoring/#architecture","title":"Architecture","text":""},{"location":"parser-refactoring/#before-refactoring","title":"Before Refactoring","text":"<p>The original parser (<code>JJOnionParser.jj</code>) directly constructs AST nodes within the grammar rules:</p> <pre><code>AST.ClassDeclaration class_decl(int mset) : {\n  // ... variable declarations ...\n}{\n  t1=\"class\" t2=&lt;ID&gt; /* ... parsing ... */ {\n    return new AST.ClassDeclaration(  // Direct AST construction\n      p(t1), mset, t2.image, ty1, toList(ty2s), sec3, toList(sec2s)\n    );\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#after-refactoring","title":"After Refactoring","text":"<p>The refactored parser uses an <code>ASTBuilder</code> interface:</p> <pre><code>AST.ClassDeclaration class_decl(int mset) : {\n  // ... variable declarations ...\n}{\n  t1=\"class\" t2=&lt;ID&gt; /* ... parsing ... */ {\n    return builder.createClassDeclaration(  // Delegated to builder\n      p(t1), mset, t2.image, ty1, toList(ty2s), sec3, toList(sec2s)\n    );\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#components","title":"Components","text":""},{"location":"parser-refactoring/#1-astbuilder-trait-astbuilderscala","title":"1. ASTBuilder Trait (<code>ASTBuilder.scala</code>)","text":"<p>Defines the interface for AST construction:</p> <pre><code>trait ASTBuilder {\n  def createCompilationUnit(...): AST.CompilationUnit\n  def createClassDeclaration(...): AST.ClassDeclaration\n  def createMethodDeclaration(...): AST.MethodDeclaration\n  // ... other AST node creation methods\n}\n</code></pre>"},{"location":"parser-refactoring/#2-defaultastbuilder-astbuilderscala","title":"2. DefaultASTBuilder (<code>ASTBuilder.scala</code>)","text":"<p>Provides the default implementation that simply constructs AST nodes:</p> <pre><code>class DefaultASTBuilder extends ASTBuilder {\n  def createClassDeclaration(...) = {\n    AST.ClassDeclaration(location, modifiers, name, ...)\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#3-astbuilderadapter-astbuilderadapterjava","title":"3. ASTBuilderAdapter (<code>ASTBuilderAdapter.java</code>)","text":"<p>Java adapter for seamless integration with JavaCC:</p> <pre><code>public class ASTBuilderAdapter {\n  private final ASTBuilder builder;\n\n  // Handles Java-Scala interop complexities\n  public AST.ClassDeclaration createClassDeclaration(...) {\n    return builder.createClassDeclaration(...);\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#4-jjonionparserrefactored-jjonionparserrefactoredjj","title":"4. JJOnionParserRefactored (<code>JJOnionParserRefactored.jj</code>)","text":"<p>Modified JavaCC grammar that uses the builder pattern instead of direct AST construction.</p>"},{"location":"parser-refactoring/#use-cases","title":"Use Cases","text":""},{"location":"parser-refactoring/#1-custom-analysis","title":"1. Custom Analysis","text":"<pre><code>class AnalyzingASTBuilder extends DefaultASTBuilder {\n  var methodCount = 0\n\n  override def createMethodDeclaration(...) = {\n    methodCount += 1\n    super.createMethodDeclaration(...)\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#2-validation","title":"2. Validation","text":"<pre><code>class ValidatingASTBuilder extends DefaultASTBuilder {\n  override def createMethodDeclaration(...) = {\n    if (args.length &gt; 10) {\n      throw new IllegalArgumentException(\"Too many parameters\")\n    }\n    super.createMethodDeclaration(...)\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#3-transformation","title":"3. Transformation","text":"<pre><code>class TransformingASTBuilder extends DefaultASTBuilder {\n  override def createMethodDeclaration(...) = {\n    val modifiedBody = addLogging(body)\n    super.createMethodDeclaration(..., modifiedBody)\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#4-debugging","title":"4. Debugging","text":"<pre><code>class LoggingASTBuilder extends DefaultASTBuilder {\n  override def createClassDeclaration(...) = {\n    println(s\"Creating class: $name at $location\")\n    super.createClassDeclaration(...)\n  }\n}\n</code></pre>"},{"location":"parser-refactoring/#migration-strategy","title":"Migration Strategy","text":"<ol> <li>Phase 1: Create builder infrastructure (completed)</li> <li>ASTBuilder trait</li> <li>DefaultASTBuilder implementation</li> <li> <p>ASTBuilderAdapter for Java interop</p> </li> <li> <p>Phase 2: Refactor parser gradually</p> </li> <li>Start with simple constructs (literals, identifiers)</li> <li>Move to complex constructs (classes, methods)</li> <li> <p>Maintain backward compatibility</p> </li> <li> <p>Phase 3: Update existing code</p> </li> <li>Modify Parsing.scala to use new parser</li> <li> <p>Update tests to use refactored components</p> </li> <li> <p>Phase 4: Leverage new capabilities</p> </li> <li>Add validation builders</li> <li>Implement transformation builders</li> <li>Create specialized builders for different compilation modes</li> </ol>"},{"location":"parser-refactoring/#benefits-realized","title":"Benefits Realized","text":"<ol> <li>Separation of Concerns: Grammar rules focus on syntax; builders focus on semantics</li> <li>Testability: AST construction logic can be unit tested without parsing</li> <li>Extensibility: New compilation features can be added via custom builders</li> <li>Maintainability: Changes to AST structure don't require grammar modifications</li> <li>Debugging: Logging/tracing can be added without touching the parser</li> </ol>"},{"location":"parser-refactoring/#future-enhancements","title":"Future Enhancements","text":"<ol> <li>Builder Composition: Chain multiple builders for complex transformations</li> <li>Context-Aware Building: Builders that maintain compilation context</li> <li>Error Recovery: Builders that can construct partial ASTs for better error messages</li> <li>Optimization: Builders that perform early optimizations during parsing</li> </ol>"},{"location":"contributing/building/","title":"Building from Source","text":"<p>Complete guide to building the Onion compiler from source.</p>"},{"location":"contributing/building/#prerequisites","title":"Prerequisites","text":""},{"location":"contributing/building/#required-software","title":"Required Software","text":"<ol> <li>Java Development Kit (JDK) 17 or later</li> </ol> <p>Check version:    <pre><code>java -version\njavac -version\n</code></pre></p> <p>Install:    - macOS: <code>brew install openjdk@17</code>    - Ubuntu/Debian: <code>sudo apt install openjdk-17-jdk</code>    - Windows: Download from Adoptium</p> <ol> <li>SBT (Scala Build Tool)</li> </ol> <p>Check version:    <pre><code>sbt version\n</code></pre></p> <p>Install:    - macOS: <code>brew install sbt</code>    - Ubuntu/Debian: Follow official guide    - Windows: Download MSI installer</p> <ol> <li>Git</li> </ol> <pre><code>git --version\n</code></pre>"},{"location":"contributing/building/#cloning-the-repository","title":"Cloning the Repository","text":"<pre><code>git clone https://github.com/onion-lang/onion.git\ncd onion\n</code></pre>"},{"location":"contributing/building/#building","title":"Building","text":""},{"location":"contributing/building/#basic-compilation","title":"Basic Compilation","text":"<p>Compile the entire project:</p> <pre><code>sbt compile\n</code></pre> <p>This will: 1. Download dependencies (first time only) 2. Generate parser from JavaCC grammar 3. Compile Scala and Java source files</p> <p>Expected output: <pre><code>[info] compiling 70 Scala sources and 15 Java sources to target/scala-3.6.2/classes ...\n[success] Total time: 45 s\n</code></pre></p>"},{"location":"contributing/building/#clean-build","title":"Clean Build","text":"<p>Remove all generated files and rebuild:</p> <pre><code>sbt clean compile\n</code></pre>"},{"location":"contributing/building/#incremental-compilation","title":"Incremental Compilation","text":"<p>SBT automatically performs incremental compilation. Only changed files are recompiled:</p> <pre><code># Edit a file\nvim src/main/scala/onion/compiler/Typing.scala\n\n# Fast recompilation\nsbt compile\n</code></pre>"},{"location":"contributing/building/#testing","title":"Testing","text":""},{"location":"contributing/building/#run-all-tests","title":"Run All Tests","text":"<pre><code>sbt test\n</code></pre>"},{"location":"contributing/building/#run-specific-test-suite","title":"Run Specific Test Suite","text":"<pre><code>sbt 'testOnly *HelloWorldSpec'\nsbt 'testOnly *FactorialSpec'\n</code></pre>"},{"location":"contributing/building/#run-tests-matching-pattern","title":"Run Tests Matching Pattern","text":"<pre><code>sbt 'testOnly *String*'\n</code></pre>"},{"location":"contributing/building/#creating-distributions","title":"Creating Distributions","text":""},{"location":"contributing/building/#standalone-jar","title":"Standalone JAR","text":"<p>Create a fat JAR with all dependencies:</p> <pre><code>sbt assembly\n</code></pre> <p>Output: <code>target/scala-3.6.2/onion.jar</code></p> <p>Run it: <pre><code>java -jar target/scala-3.6.2/onion.jar Hello.on\n</code></pre></p>"},{"location":"contributing/building/#distribution-package","title":"Distribution Package","text":"<p>Create a complete distribution ZIP:</p> <pre><code>sbt dist\n</code></pre> <p>Output: <code>target/onion-dist.zip</code></p> <p>Contents: <pre><code>onion-dist/\n\u251c\u2500\u2500 onion.jar          # Main compiler JAR\n\u251c\u2500\u2500 lib/               # Dependencies\n\u2502   \u251c\u2500\u2500 asm-9.8.jar\n\u2502   \u251c\u2500\u2500 scala-library-3.6.2.jar\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 bin/               # Executables\n\u2502   \u251c\u2500\u2500 onionc\n\u2502   \u2514\u2500\u2500 onion\n\u251c\u2500\u2500 run/               # Example programs\n\u2502   \u251c\u2500\u2500 Hello.on\n\u2502   \u251c\u2500\u2500 Array.on\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 README.md\n</code></pre></p> <p>Extract and use: <pre><code>unzip target/onion-dist.zip\ncd onion-dist\nexport PATH=$PATH:$PWD/bin\nonionc run/Hello.on\n</code></pre></p>"},{"location":"contributing/building/#development-build","title":"Development Build","text":""},{"location":"contributing/building/#continuous-compilation","title":"Continuous Compilation","text":"<p>Watch for changes and recompile automatically:</p> <pre><code>sbt ~compile\n</code></pre>"},{"location":"contributing/building/#run-from-sbt","title":"Run from SBT","text":"<p>Execute without creating a JAR:</p> <pre><code>sbt 'run Hello.on'\n</code></pre> <p>Run script runner:</p> <pre><code>sbt 'runScript run/Hello.on'\n</code></pre>"},{"location":"contributing/building/#interactive-sbt","title":"Interactive SBT","text":"<p>Start SBT shell:</p> <pre><code>sbt\n</code></pre> <p>Then run commands: <pre><code>&gt; compile\n&gt; test\n&gt; run Hello.on\n&gt; ~compile  # Continuous compilation\n&gt; exit\n</code></pre></p>"},{"location":"contributing/building/#parser-development","title":"Parser Development","text":""},{"location":"contributing/building/#modifying-the-grammar","title":"Modifying the Grammar","text":"<ol> <li> <p>Edit the JavaCC grammar:    <pre><code>vim grammar/JJOnionParser.jj\n</code></pre></p> </li> <li> <p>Regenerate parser:    <pre><code>sbt clean compile\n</code></pre></p> </li> </ol> <p>The parser is automatically regenerated when: - Grammar file is newer than generated parser - Running <code>sbt clean</code></p>"},{"location":"contributing/building/#parser-location","title":"Parser Location","text":"<p>Generated parser: <pre><code>target/scala-3.6.2/src_managed/main/java/onion/compiler/parser/\n\u251c\u2500\u2500 JJOnionParser.java\n\u251c\u2500\u2500 Token.java\n\u251c\u2500\u2500 TokenManager.java\n\u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"contributing/building/#ide-setup","title":"IDE Setup","text":""},{"location":"contributing/building/#intellij-idea","title":"IntelliJ IDEA","text":"<ol> <li>Install Scala plugin</li> <li>Open project: <code>File &gt; Open &gt; select build.sbt</code></li> <li>Wait for indexing to complete</li> <li>Build: <code>Build &gt; Build Project</code></li> </ol> <p>Run configuration: - Main class: <code>onion.tools.CompilerFrontend</code> - Program arguments: <code>path/to/source.on</code> - Working directory: <code>$PROJECT_DIR$</code></p>"},{"location":"contributing/building/#visual-studio-code","title":"Visual Studio Code","text":"<ol> <li>Install Metals extension</li> <li>Open project folder</li> <li>Wait for import to complete</li> <li>Build via command palette: <code>Metals: Compile workspace</code></li> </ol>"},{"location":"contributing/building/#troubleshooting","title":"Troubleshooting","text":""},{"location":"contributing/building/#parser-generation-fails","title":"Parser Generation Fails","text":"<pre><code># Clean and rebuild\nsbt clean\nrm -rf target\nsbt compile\n</code></pre>"},{"location":"contributing/building/#out-of-memory","title":"Out of Memory","text":"<p>Increase SBT memory: <pre><code>export SBT_OPTS=\"-Xmx2G\"\nsbt compile\n</code></pre></p> <p>Or edit <code>.sbtopts</code>: <pre><code>-Xmx2G\n-Xss2M\n</code></pre></p>"},{"location":"contributing/building/#dependency-issues","title":"Dependency Issues","text":"<p>Clear Ivy cache: <pre><code>rm -rf ~/.ivy2/cache\nsbt update\nsbt compile\n</code></pre></p>"},{"location":"contributing/building/#compilation-errors","title":"Compilation Errors","text":"<p>Check Scala and Java versions: <pre><code>sbt scalaVersion\njava -version\n</code></pre></p> <p>Ensure they match requirements: - Scala 3.6.2 - Java 17+</p>"},{"location":"contributing/building/#build-configuration","title":"Build Configuration","text":""},{"location":"contributing/building/#buildsbt","title":"build.sbt","text":"<p>Key settings:</p> <pre><code>version := \"0.2.0-SNAPSHOT\"\nscalaVersion := \"3.6.2\"\nname := \"onion\"\norganization := \"org.onion_lang\"\n\n// Dependencies\nlibraryDependencies ++= Seq(\n  \"org.ow2.asm\" % \"asm\" % \"9.8\",\n  \"net.java.dev.javacc\" % \"javacc\" % \"5.0\",\n  \"org.scalatest\" %% \"scalatest\" % \"3.2.19\" % \"test\"\n)\n\n// Main class\nmainClass := Some(\"onion.tools.CompilerFrontend\")\n</code></pre>"},{"location":"contributing/building/#compiler-options","title":"Compiler Options","text":"<p>Scala compiler options: <pre><code>scalacOptions ++= Seq(\n  \"-encoding\", \"utf8\",\n  \"-unchecked\",\n  \"-deprecation\",\n  \"-feature\"\n)\n</code></pre></p> <p>Java compiler options: <pre><code>javacOptions ++= Seq(\n  \"-source\", \"17\",\n  \"-Xlint:unchecked\"\n)\n</code></pre></p>"},{"location":"contributing/building/#performance-tips","title":"Performance Tips","text":""},{"location":"contributing/building/#faster-builds","title":"Faster Builds","text":"<ol> <li>Use incremental compilation (default)</li> <li>Don't clean unless necessary</li> <li>Increase JVM memory</li> <li>Use SBT shell for multiple commands</li> </ol>"},{"location":"contributing/building/#parallel-compilation","title":"Parallel Compilation","text":"<p>SBT compiles in parallel by default. Adjust thread count:</p> <pre><code>Global / concurrentRestrictions := Seq(\n  Tags.limitAll(4)\n)\n</code></pre>"},{"location":"contributing/building/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"contributing/building/#macos","title":"macOS","text":"<p>May need to set JAVA_HOME: <pre><code>export JAVA_HOME=$(/usr/libexec/java_home -v 17)\n</code></pre></p>"},{"location":"contributing/building/#linux","title":"Linux","text":"<p>Ensure sufficient memory: <pre><code>free -h\n# Increase swap if needed\n</code></pre></p>"},{"location":"contributing/building/#windows","title":"Windows","text":"<p>Use PowerShell or Git Bash. Paths use backslashes: <pre><code>sbt compile\njava -jar target\\scala-3.6.2\\onion.jar Hello.on\n</code></pre></p>"},{"location":"contributing/building/#next-steps","title":"Next Steps","text":"<ul> <li>Development Guide - Contributing to Onion</li> <li>Compiler Architecture - Internals</li> <li>Running Tests - Testing guide</li> </ul>"},{"location":"contributing/development/","title":"Development Guide","text":"<p>Guide for contributing to the Onion programming language.</p>"},{"location":"contributing/development/#getting-started","title":"Getting Started","text":""},{"location":"contributing/development/#prerequisites","title":"Prerequisites","text":"<ul> <li>JDK 17 or later</li> <li>SBT (Scala Build Tool)</li> <li>Git</li> <li>Text editor or IDE (IntelliJ IDEA recommended)</li> </ul>"},{"location":"contributing/development/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/onion-lang/onion.git\ncd onion\n</code></pre>"},{"location":"contributing/development/#build-the-project","title":"Build the Project","text":"<pre><code>sbt compile\n</code></pre> <p>This will: - Download dependencies - Generate the parser from JavaCC grammar - Compile all Scala and Java source files</p>"},{"location":"contributing/development/#project-structure","title":"Project Structure","text":"<pre><code>onion/\n\u251c\u2500\u2500 build.sbt                 # SBT build configuration\n\u251c\u2500\u2500 grammar/\n\u2502   \u2514\u2500\u2500 JJOnionParser.jj     # JavaCC parser grammar\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main/\n\u2502   \u2502   \u251c\u2500\u2500 scala/           # Scala source code\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 onion/\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 compiler/        # Compiler phases\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 tools/           # CLI tools\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 ...\n\u2502   \u2502   \u2514\u2500\u2500 java/            # Java runtime library\n\u2502   \u2502       \u2514\u2500\u2500 onion/\n\u2502   \u2502           \u251c\u2500\u2500 Function0.java - Function10.java\n\u2502   \u2502           \u251c\u2500\u2500 IO.java\n\u2502   \u2502           \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 test/\n\u2502       \u251c\u2500\u2500 scala/           # Test suites\n\u2502       \u2514\u2500\u2500 run/             # Example programs\n\u251c\u2500\u2500 run/                     # Example Onion programs\n\u2514\u2500\u2500 docs/                    # Documentation\n</code></pre>"},{"location":"contributing/development/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/development/#1-create-a-feature-branch","title":"1. Create a Feature Branch","text":"<pre><code>git checkout -b feature/my-new-feature\n</code></pre>"},{"location":"contributing/development/#2-make-changes","title":"2. Make Changes","text":"<p>Edit source files using your preferred editor.</p>"},{"location":"contributing/development/#3-compile","title":"3. Compile","text":"<pre><code>sbt compile\n</code></pre>"},{"location":"contributing/development/#4-run-tests","title":"4. Run Tests","text":"<pre><code>sbt test\n</code></pre>"},{"location":"contributing/development/#5-test-manually","title":"5. Test Manually","text":"<pre><code># Run examples\nsbt 'runScript run/Hello.on'\n\n# Or use the compiler\nsbt compile\nsbt 'run-main onion.tools.CompilerFrontend run/Hello.on'\njava -cp . Hello\n</code></pre>"},{"location":"contributing/development/#6-format-code","title":"6. Format Code","text":"<p>Follow Scala style conventions: - 2 spaces for indentation - Line length limit: 120 characters - Use meaningful variable names</p>"},{"location":"contributing/development/#7-commit-changes","title":"7. Commit Changes","text":"<pre><code>git add .\ngit commit -m \"Add feature: description of change\"\n</code></pre>"},{"location":"contributing/development/#8-push-and-create-pr","title":"8. Push and Create PR","text":"<pre><code>git push origin feature/my-new-feature\n</code></pre> <p>Then create a Pull Request on GitHub.</p>"},{"location":"contributing/development/#common-development-tasks","title":"Common Development Tasks","text":""},{"location":"contributing/development/#modifying-the-parser","title":"Modifying the Parser","text":"<p>Edit <code>grammar/JJOnionParser.jj</code>, then:</p> <pre><code>sbt clean compile\n</code></pre> <p>The parser will be regenerated automatically.</p>"},{"location":"contributing/development/#adding-a-language-feature","title":"Adding a Language Feature","text":"<ol> <li>Update grammar in <code>JJOnionParser.jj</code></li> <li>Update AST in <code>AST.scala</code></li> <li>Update type checking in <code>Typing.scala</code></li> <li>Update code generation in <code>AsmCodeGeneration.scala</code></li> <li>Add tests</li> </ol>"},{"location":"contributing/development/#adding-a-test","title":"Adding a Test","text":"<p>Create a new test in <code>src/test/scala/onion/compiler/tools/</code>:</p> <pre><code>package onion.compiler.tools\n\nclass MyFeatureSpec extends AbstractShellSpec {\n  \"MyFeature\" should \"work correctly\" in {\n    val source = \"\"\"\n      |// Your test code here\n      |IO::println(\"Test\")\n    \"\"\".stripMargin\n\n    val result = runShell(source)\n    result should include(\"Test\")\n  }\n}\n</code></pre> <p>Run the test:</p> <pre><code>sbt 'testOnly *MyFeatureSpec'\n</code></pre>"},{"location":"contributing/development/#debugging-the-compiler","title":"Debugging the Compiler","text":"<p>Add print statements or use a debugger:</p> <pre><code>// In compiler code\nprintln(s\"Debug: AST = $ast\")\n</code></pre> <p>Or use IntelliJ IDEA's debugger: 1. Set breakpoints 2. Run tests in debug mode</p>"},{"location":"contributing/development/#code-organization","title":"Code Organization","text":""},{"location":"contributing/development/#compiler-phases","title":"Compiler Phases","text":"<p>Parsing (<code>Parsing.scala</code>): - Entry point for compilation - Uses JavaCC-generated parser - Produces untyped AST</p> <p>Rewriting (<code>Rewriting.scala</code>): - Normalizes AST - Desugars complex constructs</p> <p>Type Checking (<code>Typing.scala</code>): - Type inference and validation - Name resolution - Symbol table management</p> <p>Code Generation (<code>AsmCodeGeneration.scala</code>): - ASM-based bytecode generation - JVM instruction emission</p>"},{"location":"contributing/development/#support-modules","title":"Support Modules","text":"<p>AST (<code>AST.scala</code>, <code>TypedAST.scala</code>): - Abstract syntax tree definitions</p> <p>Symbol Tables (<code>ClassTable.scala</code>, <code>LocalContext.scala</code>): - Symbol management - Scope handling</p> <p>Error Handling (<code>SemanticError.scala</code>, <code>CompilationReporter.scala</code>): - Error collection - Error formatting</p>"},{"location":"contributing/development/#testing-strategy","title":"Testing Strategy","text":""},{"location":"contributing/development/#unit-tests","title":"Unit Tests","text":"<p>Test individual components:</p> <pre><code>class TypingSpec extends AnyFlatSpec with Matchers {\n  \"Type checker\" should \"infer Int type\" in {\n    // Test type inference\n  }\n}\n</code></pre>"},{"location":"contributing/development/#integration-tests","title":"Integration Tests","text":"<p>Test complete compilation:</p> <pre><code>class IntegrationSpec extends AbstractShellSpec {\n  \"Compiler\" should \"compile and run program\" in {\n    val source = \"\"\"IO::println(\"Hello\")\"\"\"\n    val result = runShell(source)\n    result should include(\"Hello\")\n  }\n}\n</code></pre>"},{"location":"contributing/development/#example-based-tests","title":"Example-Based Tests","text":"<p>Verify example programs compile and run:</p> <pre><code>sbt test\n# Runs all tests including example verification\n</code></pre>"},{"location":"contributing/development/#documentation","title":"Documentation","text":""},{"location":"contributing/development/#code-documentation","title":"Code Documentation","text":"<p>Use ScalaDoc for public APIs:</p> <pre><code>/**\n * Compiles Onion source code to JVM bytecode.\n *\n * @param source Source code string\n * @param config Compiler configuration\n * @return Compilation outcome\n */\ndef compile(source: String, config: CompilerConfig): CompilationOutcome = {\n  // ...\n}\n</code></pre>"},{"location":"contributing/development/#user-documentation","title":"User Documentation","text":"<p>Update docs in <code>docs/</code> directory: - Use Markdown format - Include code examples - Keep examples up-to-date</p>"},{"location":"contributing/development/#contributing-guidelines","title":"Contributing Guidelines","text":""},{"location":"contributing/development/#code-style","title":"Code Style","text":"<ul> <li>Follow Scala conventions</li> <li>Use meaningful names</li> <li>Keep functions focused</li> <li>Add comments for complex logic</li> </ul>"},{"location":"contributing/development/#commit-messages","title":"Commit Messages","text":"<p>Use clear, descriptive commit messages:</p> <pre><code>Add feature: Lambda expression support\n\n- Implement lambda syntax in parser\n- Add lambda type checking\n- Generate Function interface calls\n- Add lambda tests\n</code></pre>"},{"location":"contributing/development/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make changes with tests</li> <li>Ensure all tests pass</li> <li>Update documentation</li> <li>Create pull request</li> <li>Respond to review feedback</li> </ol>"},{"location":"contributing/development/#issues","title":"Issues","text":"<p>When creating issues: - Use descriptive titles - Provide example code - Include error messages - Specify Onion version</p>"},{"location":"contributing/development/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Parser generation is slow; avoid unnecessary recompilation</li> <li>Type checking can be expensive for large files</li> <li>Use incremental compilation when possible</li> </ul>"},{"location":"contributing/development/#debugging-tips","title":"Debugging Tips","text":""},{"location":"contributing/development/#compiler-crashes","title":"Compiler Crashes","text":"<ol> <li>Identify the failing phase</li> <li>Add debug output</li> <li>Check AST structure</li> <li>Verify type information</li> </ol>"},{"location":"contributing/development/#type-errors","title":"Type Errors","text":"<ol> <li>Check symbol table</li> <li>Verify type resolution</li> <li>Review type conversion rules</li> </ol>"},{"location":"contributing/development/#bytecode-issues","title":"Bytecode Issues","text":"<ol> <li>Use <code>javap</code> to inspect generated bytecode</li> <li>Verify stack frame correctness</li> <li>Check local variable indices</li> </ol>"},{"location":"contributing/development/#release-process","title":"Release Process","text":"<ol> <li>Update version in <code>build.sbt</code></li> <li>Run all tests: <code>sbt test</code></li> <li>Create distribution: <code>sbt dist</code></li> <li>Tag release: <code>git tag v0.2.0</code></li> <li>Push tag: <code>git push origin v0.2.0</code></li> <li>Create GitHub release</li> </ol>"},{"location":"contributing/development/#next-steps","title":"Next Steps","text":"<ul> <li>Building from Source - Detailed build instructions</li> <li>Compiler Architecture - Compiler internals</li> <li>Language Specification - Language details</li> </ul>"},{"location":"examples/basic/","title":"Basic Examples","text":"<p>Simple programs demonstrating fundamental Onion features.</p>"},{"location":"examples/basic/#hello-world","title":"Hello World","text":"<p>The simplest Onion program:</p> <p>File: <code>Hello.on</code> <pre><code>IO::println(\"Hello\")\n</code></pre></p> <p>Run: <pre><code>onion Hello.on\n</code></pre></p> <p>Output: <pre><code>Hello\n</code></pre></p>"},{"location":"examples/basic/#arrays","title":"Arrays","text":"<p>Working with arrays:</p> <p>File: <code>Array.on</code> <pre><code>def array :String[] = new String[3]\narray[0] = \"A\"\narray[1] = \"B\"\narray[2] = \"C\"\n\nfor i = 0; i &lt; array.length; i = i + 1 {\n  IO::println(array[i])\n}\n</code></pre></p> <p>Topics: - Array declaration and initialization - Index-based access - For loop with <code>.length</code> property</p>"},{"location":"examples/basic/#string-concatenation","title":"String Concatenation","text":"<p>String operations and array literals:</p> <p>File: <code>StringCat.on</code> <pre><code>def array :String[] = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n\ndef result :String = \"\"\nfor i = 0; i &lt; array.size; i = i + 1 {\n  result = result + array[i]\n}\n\nSystem::out.println(result)\n</code></pre></p> <p>Topics: - Array literals - String concatenation with <code>+</code> - <code>.size</code> property - System output</p>"},{"location":"examples/basic/#user-input","title":"User Input","text":"<p>Reading user input:</p> <p>File: <code>ReadLine.on</code> <pre><code>def name :String = IO::input(\"What's your name? \")\nIO::println(\"Hello, \" + name + \"!\")\n</code></pre></p> <p>Run: <pre><code>onion ReadLine.on\n</code></pre></p> <p>Interaction: <pre><code>What's your name? Alice\nHello, Alice!\n</code></pre></p> <p>Topics: - <code>IO::input()</code> for reading input - String concatenation - Interactive programs</p>"},{"location":"examples/basic/#dynamic-lists","title":"Dynamic Lists","text":"<p>Using ArrayList with the <code>&lt;&lt;</code> append operator:</p> <p>File: <code>List.on</code> <pre><code>import { java.util.ArrayList; }\n\ndef list :ArrayList = new ArrayList\nlist &lt;&lt; \"First\"\nlist &lt;&lt; \"Second\"\nlist &lt;&lt; \"Third\"\n\nfor i = 0; i &lt; list.size; i = i + 1 {\n  IO::println(list[i])\n}\n</code></pre></p> <p>Topics: - Importing Java classes - ArrayList creation - <code>&lt;&lt;</code> append operator - Index-based access on collections</p>"},{"location":"examples/basic/#foreach-loop","title":"Foreach Loop","text":"<p>Enhanced for loop with collections:</p> <p>File: <code>Foreach.on</code> <pre><code>import { java.util.ArrayList; }\n\ndef list :ArrayList = new ArrayList\nlist &lt;&lt; \"HELLO\"\nlist &lt;&lt; \"WORLD\"\nlist &lt;&lt; \"ONION\"\n\nforeach object :String in list {\n  IO::println(object.toLowerCase())\n}\n</code></pre></p> <p>Output: <pre><code>hello\nworld\nonion\n</code></pre></p> <p>Topics: - <code>foreach</code> loop syntax - Type annotations in loops - Method calls on loop variables</p>"},{"location":"examples/basic/#pattern-matching","title":"Pattern Matching","text":"<p>Using the <code>select</code> statement:</p> <p>File: <code>Select.on</code> <pre><code>def value :Int = (Math::random() * 10)$Int\n\nselect value {\n  case 0, 1, 2, 3:\n    IO::println(\"Low: \" + value)\n  case 4, 5, 6:\n    IO::println(\"Medium: \" + value)\n  case 7, 8, 9:\n    IO::println(\"High: \" + value)\n  else:\n    IO::println(\"Out of range: \" + value)\n}\n</code></pre></p> <p>Topics: - <code>select</code> statement - Multiple values per case - <code>else</code> default clause - Type casting with <code>$</code> - <code>Math::random()</code> function</p>"},{"location":"examples/basic/#complete-example-array-processing","title":"Complete Example: Array Processing","text":"<p>Combining multiple concepts:</p> <pre><code>import { java.util.ArrayList; }\n\n// Create array\ndef numbers :Int[] = [10, 20, 30, 40, 50]\n\n// Filter even numbers\ndef evens :ArrayList = new ArrayList\nforeach num :Int in numbers {\n  if num % 2 == 0 {\n    evens &lt;&lt; num\n  }\n}\n\n// Print results\nIO::println(\"Even numbers:\")\nforeach even :Object in evens {\n  IO::println(even$Int)\n}\n</code></pre> <p>Output: <pre><code>Even numbers:\n10\n20\n30\n40\n50\n</code></pre></p>"},{"location":"examples/basic/#complete-example-simple-calculator","title":"Complete Example: Simple Calculator","text":"<pre><code>def x :Int = 10\ndef y :Int = 3\n\nIO::println(\"Addition: \" + (x + y))\nIO::println(\"Subtraction: \" + (x - y))\nIO::println(\"Multiplication: \" + (x * y))\nIO::println(\"Division: \" + (x / y))\nIO::println(\"Modulo: \" + (x % y))\n</code></pre> <p>Output: <pre><code>Addition: 13\nSubtraction: 7\nMultiplication: 30\nDivision: 3\nModulo: 1\n</code></pre></p>"},{"location":"examples/basic/#next-steps","title":"Next Steps","text":"<ul> <li>OOP Examples - Object-oriented programs</li> <li>Functional Examples - Lambdas and higher-order functions</li> <li>Language Guide - Deep dive into features</li> </ul>"},{"location":"examples/functional/","title":"Functional Programming Examples","text":"<p>Examples demonstrating functional programming features in Onion.</p>"},{"location":"examples/functional/#lambda-expressions","title":"Lambda Expressions","text":"<p>Basic lambda syntax:</p> <pre><code>// Simple lambda\ndef double = #(x :Int) { x * 2 }\nIO::println(double.call(5))  // 10\n\n// Lambda with multiple parameters\ndef add = #(x :Int, y :Int) { x + y }\nIO::println(add.call(3, 7))  // 10\n\n// Lambda with no parameters\ndef greet = #() { IO::println(\"Hello!\") }\ngreet.call()\n</code></pre>"},{"location":"examples/functional/#closures","title":"Closures","text":"<p>Lambdas that capture variables:</p> <p>File: <code>LineFilter.on</code> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.FileReader;\n  java.io.StringReader;\n}\n\ndef i :Int = 0\ndef filter = #(line :String) {\n  i = i + 1\n  line + \" (\" + i + \")\"\n}\n\ndef reader :BufferedReader = new BufferedReader(\n  new StringReader(\"First\\nSecond\\nThird\")\n)\n\ndef line :String = null\nwhile (line = reader.readLine()) != null {\n  IO::println(filter.call(line)$String)\n}\n</code></pre></p> <p>Output: <pre><code>First (1)\nSecond (2)\nThird (3)\n</code></pre></p> <p>Topics: - Closure capturing variable <code>i</code> - Lambda returning modified string - Post-increment in closure</p>"},{"location":"examples/functional/#counter-factory","title":"Counter Factory","text":"<p>Creating multiple independent counters:</p> <pre><code>def makeCounter {\n  def count :Int = 0\n  #() {\n    count = count + 1\n    count\n  }\n}\n\ndef counter1 = makeCounter()\ndef counter2 = makeCounter()\n\nIO::println(counter1.call())  // 1\nIO::println(counter1.call())  // 2\nIO::println(counter2.call())  // 1\nIO::println(counter1.call())  // 3\nIO::println(counter2.call())  // 2\n</code></pre> <p>Each counter maintains its own <code>count</code> variable.</p>"},{"location":"examples/functional/#recursion","title":"Recursion","text":"<p>File: <code>Factorial.on</code> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.InputStreamReader;\n  java.lang.NumberFormatException;\n}\n\ndef fact(n :Int) :Int {\n  if n &lt; 0 {\n    IO::println(\"Illegal argument\")\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  n * fact(n - 1)\n}\n\ndef reader :BufferedReader = new BufferedReader(\n  new InputStreamReader(System::in)\n)\n\ndef line :String = null\nwhile (line = IO::input(\"Enter number: \")) != null {\n  try {\n    def value :Int = JInteger::parseInt(line)\n    def result :Int = fact(value)\n    IO::println(\"Factorial: \" + result)\n  } catch e :NumberFormatException {\n    IO::println(\"Invalid number\")\n  }\n}\n</code></pre></p> <p>Topics: - Recursive function calls - Base case handling - Try-catch for error handling</p>"},{"location":"examples/functional/#file-line-counter-with-recursion","title":"File Line Counter with Recursion","text":"<p>File: <code>LineCounter.on</code> (simplified) <pre><code>import {\n  java.io.File;\n  java.io.FileReader;\n  java.io.BufferedReader;\n}\n\ndef countLines(file :File) :Int {\n  if file == null {\n    return 0\n  }\n\n  if file.isDirectory() {\n    def total :Int = 0\n    def files :File[] = file.listFiles()\n\n    if files != null {\n      foreach f :File in files {\n        total = total + countLines(f$File)\n      }\n    }\n\n    return total\n  }\n\n  if !file.name.endsWith(\".on\") {\n    return 0\n  }\n\n  def reader :BufferedReader = new BufferedReader(\n    new FileReader(file)\n  )\n\n  def count :Int = 0\n  def line :String = null\n  while (line = reader.readLine()) != null {\n    count = count + 1\n  }\n\n  reader.close()\n  IO::println(file.name + \": \" + count)\n  count\n}\n\n// Usage\ndef dir :File = new File(\"src\")\ndef total :Int = countLines(dir)\nIO::println(\"Total lines: \" + total)\n</code></pre></p> <p>Topics: - Recursive directory traversal - File operations - Conditional logic</p>"},{"location":"examples/functional/#filter-function","title":"Filter Function","text":"<p>Higher-order function that filters a list:</p> <pre><code>import { java.util.ArrayList; }\n\ndef filter(items :String[], predicate :Function1) :ArrayList {\n  def result :ArrayList = new ArrayList\n\n  foreach item :String in items {\n    def keep :Boolean = predicate.call(item)$Boolean\n    if keep {\n      result &lt;&lt; item\n    }\n  }\n\n  result\n}\n\n// Usage\ndef logs :String[] = [\n  \"INFO: Started\",\n  \"ERROR: Failed\",\n  \"INFO: Processing\",\n  \"ERROR: Timeout\",\n  \"INFO: Complete\"\n]\n\ndef isError = #(line :String) {\n  line.startsWith(\"ERROR\")\n}\n\ndef errors :ArrayList = filter(logs, isError)\n\nforeach error :Object in errors {\n  IO::println(error$String)\n}\n</code></pre> <p>Output: <pre><code>ERROR: Failed\nERROR: Timeout\n</code></pre></p>"},{"location":"examples/functional/#map-function","title":"Map Function","text":"<p>Transform each element in a collection:</p> <pre><code>import { java.util.ArrayList; }\n\ndef map(items :String[], transform :Function1) :ArrayList {\n  def result :ArrayList = new ArrayList\n\n  foreach item :String in items {\n    def transformed :String = transform.call(item)$String\n    result &lt;&lt; transformed\n  }\n\n  result\n}\n\n// Usage\ndef words :String[] = [\"hello\", \"world\", \"onion\"]\ndef toUpper = #(s :String) { s.toUpperCase() }\n\ndef upper :ArrayList = map(words, toUpper)\n\nforeach word :Object in upper {\n  IO::println(word$String)\n}\n</code></pre> <p>Output: <pre><code>HELLO\nWORLD\nONION\n</code></pre></p>"},{"location":"examples/functional/#reduce-function","title":"Reduce Function","text":"<p>Accumulate values:</p> <pre><code>def reduce(items :Int[], operation :Function2, initial :Int) :Int {\n  def accumulator :Int = initial\n\n  foreach item :Int in items {\n    accumulator = operation.call(accumulator, item)$Int\n  }\n\n  accumulator\n}\n\n// Sum\ndef numbers :Int[] = [1, 2, 3, 4, 5]\ndef sum = #(acc :Int, n :Int) { acc + n }\ndef total :Int = reduce(numbers, sum, 0)\nIO::println(\"Sum: \" + total)  // 15\n\n// Product\ndef product = #(acc :Int, n :Int) { acc * n }\ndef result :Int = reduce(numbers, product, 1)\nIO::println(\"Product: \" + result)  // 120\n</code></pre>"},{"location":"examples/functional/#composing-functions","title":"Composing Functions","text":"<p>Combine multiple operations:</p> <pre><code>def compose(f :Function1, g :Function1) :Function1 {\n  #(x :Object) {\n    f.call(g.call(x))\n  }\n}\n\n// Define functions\ndef addTen = #(x :Int) { x + 10 }\ndef double = #(x :Int) { x * 2 }\n\n// Compose: double then add 10\ndef composed = compose(addTen, double)\n\nIO::println(composed.call(5)$Int)  // (5 * 2) + 10 = 20\n</code></pre>"},{"location":"examples/functional/#currying","title":"Currying","text":"<p>Transform multi-parameter functions:</p> <pre><code>def add(x :Int) :Function1 {\n  #(y :Int) { x + y }\n}\n\ndef add5 = add(5)\ndef add10 = add(10)\n\nIO::println(add5.call(3)$Int)   // 8\nIO::println(add10.call(3)$Int)  // 13\n</code></pre>"},{"location":"examples/functional/#practical-log-analyzer","title":"Practical: Log Analyzer","text":"<p>Complete example combining functional concepts:</p> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.FileReader;\n  java.util.ArrayList;\n}\n\ndef analyzeLog(filename :String) {\n  def reader :BufferedReader = new BufferedReader(\n    new FileReader(filename)\n  )\n\n  def errorCount :Int = 0\n  def warningCount :Int = 0\n  def infoCount :Int = 0\n\n  def isError = #(line :String) { line.startsWith(\"ERROR\") }\n  def isWarning = #(line :String) { line.startsWith(\"WARNING\") }\n  def isInfo = #(line :String) { line.startsWith(\"INFO\") }\n\n  def line :String = null\n  while (line = reader.readLine()) != null {\n    if isError.call(line)$Boolean {\n      errorCount = errorCount + 1\n    } else if isWarning.call(line)$Boolean {\n      warningCount = warningCount + 1\n    } else if isInfo.call(line)$Boolean {\n      infoCount = infoCount + 1\n    }\n  }\n\n  reader.close()\n\n  IO::println(\"Errors: \" + errorCount)\n  IO::println(\"Warnings: \" + warningCount)\n  IO::println(\"Info: \" + infoCount)\n}\n\nanalyzeLog(\"app.log\")\n</code></pre>"},{"location":"examples/functional/#next-steps","title":"Next Steps","text":"<ul> <li>Lambda Expressions Guide - Detailed lambda documentation</li> <li>Functions Guide - Function definitions</li> <li>Basic Examples - Simpler programs</li> </ul>"},{"location":"examples/oop/","title":"Object-Oriented Examples","text":"<p>Examples demonstrating object-oriented programming in Onion.</p>"},{"location":"examples/oop/#classes-and-objects","title":"Classes and Objects","text":"<p>Basic class definition:</p> <pre><code>class Person {\n  @name :String\n  @age :Int\n\n  public:\n    def new(n :String, a :Int) {\n      @name = n\n      @age = a\n    }\n\n    def greet :String {\n      \"Hello, I'm \" + @name + \" and I'm \" + @age + \" years old\"\n    }\n\n    def haveBirthday {\n      @age = @age + 1\n      IO::println(\"Happy birthday! Now \" + @age)\n    }\n}\n\ndef person :Person = new Person(\"Alice\", 30)\nIO::println(person.greet())\nperson.haveBirthday()\n</code></pre> <p>Output: <pre><code>Hello, I'm Alice and I'm 30 years old\nHappy birthday! Now 31\n</code></pre></p>"},{"location":"examples/oop/#inheritance","title":"Inheritance","text":"<p>Extending classes:</p> <pre><code>class Animal {\n  @name :String\n\n  public:\n    def new(n :String) {\n      @name = n\n    }\n\n    def speak :String {\n      @name + \" makes a sound\"\n    }\n}\n\nclass Dog : Animal {\n  @breed :String\n\n  public:\n    def new(n :String, b :String) {\n      super.new(n)\n      @breed = b\n    }\n\n    def speak :String {\n      @name + \" barks: Woof!\"\n    }\n\n    def getBreed :String {\n      @breed\n    }\n}\n\ndef dog :Dog = new Dog(\"Buddy\", \"Golden Retriever\")\nIO::println(dog.speak())\nIO::println(\"Breed: \" + dog.getBreed())\n</code></pre> <p>Output: <pre><code>Buddy barks: Woof!\nBreed: Golden Retriever\n</code></pre></p>"},{"location":"examples/oop/#interfaces","title":"Interfaces","text":"<p>Implementing Java interfaces:</p> <pre><code>import { java.lang.Comparable; }\n\nclass Student &lt;: Comparable {\n  @name :String\n  @grade :Int\n\n  public:\n    def new(n :String, g :Int) {\n      @name = n\n      @grade = g\n    }\n\n    def compareTo(other :Object) :Int {\n      def otherStudent :Student = other$Student\n      @grade - otherStudent.@grade\n    }\n\n    def toString :String {\n      @name + \": \" + @grade\n    }\n}\n\ndef students :Student[] = new Student[3]\nstudents[0] = new Student(\"Alice\", 85)\nstudents[1] = new Student(\"Bob\", 92)\nstudents[2] = new Student(\"Charlie\", 78)\n\n// Sort students by grade\nimport { java.util.Arrays; }\nArrays::sort(students)\n\nforeach s :Student in students {\n  IO::println(s.toString())\n}\n</code></pre> <p>Output: <pre><code>Charlie: 78\nAlice: 85\nBob: 92\n</code></pre></p>"},{"location":"examples/oop/#delegation-pattern","title":"Delegation Pattern","text":"<p>Using <code>forward</code> for delegation:</p> <p>File: <code>Delegation.on</code> <pre><code>import {\n  java.util.List;\n  java.util.ArrayList;\n}\n\nclass Delegation &lt;: List {\n  forward @n :List\n\n  @n :ArrayList\n\n  public:\n    def new {\n      @n = new ArrayList\n    }\n\n    static def main(args :String[]) {\n      def delegation :Delegation = new Delegation\n      delegation &lt;&lt; \"a\"\n      delegation &lt;&lt; \"b\"\n      delegation &lt;&lt; \"c\"\n\n      for i = 0; i &lt; delegation.size(); i = i + 1 {\n        IO::println(delegation.get(i))\n      }\n    }\n}\n</code></pre></p> <p>Topics: - <code>forward</code> directive delegates interface methods - <code>&lt;&lt;</code> operator for adding elements - Implementing interfaces via delegation</p>"},{"location":"examples/oop/#javabean-pattern","title":"JavaBean Pattern","text":"<p>File: <code>Bean.on</code> <pre><code>import {\n  java.io.Serializable;\n  java.beans.XMLEncoder;\n  java.beans.XMLDecoder;\n  java.io.ByteArrayOutputStream;\n  java.io.ByteArrayInputStream;\n}\n\nclass ExampleBean &lt;: Serializable {\n  @name :String\n  @value :Int\n\n  public:\n    def new {\n      // Default constructor required for beans\n    }\n\n    def this(name :String, value :Int) {\n      @name = name\n      @value = value\n    }\n\n    // Getters\n    def getName :String {\n      @name\n    }\n\n    def getValue :Int {\n      @value\n    }\n\n    // Setters\n    def setName(name :String) {\n      @name = name\n    }\n\n    def setValue(value :Int) {\n      @value = value\n    }\n\n    static def main(args :String[]) {\n      // Create bean\n      def bean :ExampleBean = new ExampleBean(\"Test\", 42)\n\n      // Serialize to XML\n      def out :ByteArrayOutputStream = new ByteArrayOutputStream\n      def encoder :XMLEncoder = new XMLEncoder(out)\n      encoder.writeObject(bean)\n      encoder.close()\n\n      IO::println(\"Serialized bean\")\n\n      // Deserialize from XML\n      def in :ByteArrayInputStream = new ByteArrayInputStream(\n        out.toByteArray()\n      )\n      def decoder :XMLDecoder = new XMLDecoder(in)\n      def restored :ExampleBean = decoder.readObject()$ExampleBean\n      decoder.close()\n\n      IO::println(\"Name: \" + restored.getName())\n      IO::println(\"Value: \" + restored.getValue())\n    }\n}\n</code></pre></p> <p>Topics: - JavaBean conventions - Getter and setter methods - Serialization with XMLEncoder/XMLDecoder - Multiple constructors</p>"},{"location":"examples/oop/#gui-application","title":"GUI Application","text":"<p>File: <code>Calculator.on</code> (simplified) <pre><code>import {\n  javax.swing.JFrame;\n  javax.swing.JButton;\n  javax.swing.JTextField;\n  javax.swing.JPanel;\n  java.awt.event.ActionListener;\n  java.awt.event.ActionEvent;\n  java.awt.GridLayout;\n  java.awt.BorderLayout;\n}\n\nclass Calculator : JFrame &lt;: ActionListener {\n  @text :JTextField\n  @currentValue :Long\n  @operator :String\n\n  public:\n    def new {\n      setTitle(\"Simple Calculator\")\n      setSize(300, 400)\n      setLayout(new BorderLayout())\n\n      @text = new JTextField(\"0\")\n      add(@text, BorderLayout::NORTH)\n\n      def panel :JPanel = new JPanel()\n      panel.setLayout(new GridLayout(4, 4))\n\n      def buttons :String[] = [\n        \"7\", \"8\", \"9\", \"/\",\n        \"4\", \"5\", \"6\", \"*\",\n        \"1\", \"2\", \"3\", \"-\",\n        \"0\", \"C\", \"=\", \"+\"\n      ]\n\n      foreach label :String in buttons {\n        def button :JButton = new JButton(label)\n        button.addActionListener(self)\n        panel.add(button)\n      }\n\n      add(panel, BorderLayout::CENTER)\n\n      @currentValue = 0L\n      @operator = null\n\n      setDefaultCloseOperation(JFrame::EXIT_ON_CLOSE)\n      setVisible(true)\n    }\n\n    def actionPerformed(event :ActionEvent) {\n      def button :JButton = event.getSource()$JButton\n      def label :String = button.getText()\n\n      // Handle button click\n      if label == \"C\" {\n        @text.setText(\"0\")\n        @currentValue = 0L\n        @operator = null\n      } else if label == \"=\" {\n        calculate()\n      } else if label == \"+\" || label == \"-\" ||\n                label == \"*\" || label == \"/\" {\n        @operator = label\n        @currentValue = JLong::parseLong(@text.getText())\n        @text.setText(\"0\")\n      } else {\n        // Number button\n        def current :String = @text.getText()\n        if current == \"0\" {\n          @text.setText(label)\n        } else {\n          @text.setText(current + label)\n        }\n      }\n    }\n\n    def calculate {\n      if @operator != null {\n        def value :Long = JLong::parseLong(@text.getText())\n        def result :Long = 0L\n\n        select @operator {\n          case \"+\":\n            result = @currentValue + value\n          case \"-\":\n            result = @currentValue - value\n          case \"*\":\n            result = @currentValue * value\n          case \"/\":\n            result = @currentValue / value\n        }\n\n        @text.setText(JLong::toString(result))\n        @operator = null\n      }\n    }\n\n    static def main(args :String[]) {\n      def calc :Calculator = new Calculator\n    }\n}\n</code></pre></p> <p>Topics: - Multiple inheritance (extends JFrame, implements ActionListener) - Swing GUI components - Event handling - <code>self</code> reference - <code>select</code> statement for operations</p>"},{"location":"examples/oop/#next-steps","title":"Next Steps","text":"<ul> <li>Functional Examples - Lambdas and closures</li> <li>Basic Examples - Simpler programs</li> <li>Inheritance Guide - Learn more about OOP</li> </ul>"},{"location":"examples/overview/","title":"Examples Overview","text":"<p>This section provides practical examples of Onion programs, demonstrating various language features and programming patterns.</p>"},{"location":"examples/overview/#example-programs","title":"Example Programs","text":"<p>All examples can be found in the <code>run/</code> directory of the Onion repository.</p>"},{"location":"examples/overview/#basic-programs","title":"Basic Programs","text":"<ul> <li>Hello World - Simple output</li> <li>Arrays - Array manipulation</li> <li>User Input - Reading input</li> </ul>"},{"location":"examples/overview/#object-oriented-examples","title":"Object-Oriented Examples","text":"<ul> <li>Classes and Objects - Basic OOP</li> <li>Inheritance - Extending classes</li> <li>Interfaces - Interface implementation</li> </ul>"},{"location":"examples/overview/#functional-programming","title":"Functional Programming","text":"<ul> <li>Lambda Expressions - Anonymous functions</li> <li>Closures - Capturing variables</li> <li>Recursion - Recursive algorithms</li> </ul>"},{"location":"examples/overview/#running-examples","title":"Running Examples","text":""},{"location":"examples/overview/#using-the-script-runner","title":"Using the Script Runner","text":"<pre><code>cd run\nonion Hello.on\n</code></pre>"},{"location":"examples/overview/#compiling-and-running","title":"Compiling and Running","text":"<pre><code>onionc Hello.on\njava Hello\n</code></pre>"},{"location":"examples/overview/#example-index","title":"Example Index","text":"File Description Topics Covered <code>Hello.on</code> Hello World Basic I/O <code>Array.on</code> Array operations Arrays, loops <code>StringCat.on</code> String concatenation Strings, arrays <code>ReadLine.on</code> User input I/O, strings <code>List.on</code> Dynamic lists ArrayList, <code>&lt;&lt;</code> operator <code>Foreach.on</code> Foreach loop Iteration, collections <code>Select.on</code> Pattern matching Select statement <code>LineFilter.on</code> Lambda filtering Lambdas, closures <code>LineCounter.on</code> File processing Recursion, I/O <code>Factorial.on</code> Recursion Recursive functions <code>Delegation.on</code> Delegation pattern Interfaces, forward <code>Calculator.on</code> GUI calculator Swing, event handling <code>Bean.on</code> JavaBean pattern Serialization, getters/setters"},{"location":"examples/overview/#learning-path","title":"Learning Path","text":""},{"location":"examples/overview/#beginner","title":"Beginner","text":"<ol> <li>Start with <code>Hello.on</code> - Basic syntax</li> <li>Try <code>Array.on</code> - Data structures</li> <li>Explore <code>Foreach.on</code> - Iteration</li> </ol>"},{"location":"examples/overview/#intermediate","title":"Intermediate","text":"<ol> <li>Study <code>Factorial.on</code> - Recursion</li> <li>Learn <code>LineFilter.on</code> - Lambdas</li> <li>Review <code>Bean.on</code> - OOP patterns</li> </ol>"},{"location":"examples/overview/#advanced","title":"Advanced","text":"<ol> <li>Analyze <code>Calculator.on</code> - GUI programming</li> <li>Understand <code>Delegation.on</code> - Design patterns</li> <li>Examine <code>LineCounter.on</code> - File processing</li> </ol>"},{"location":"examples/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Examples - Simple programs</li> <li>OOP Examples - Object-oriented code</li> <li>Functional Examples - Functional programming</li> </ul>"},{"location":"getting-started/hello-world/","title":"Hello World","text":"<p>Let's write and run your first Onion program!</p>"},{"location":"getting-started/hello-world/#the-classic-hello-world","title":"The Classic Hello World","text":"<p>Create a file named <code>Hello.on</code>:</p> <pre><code>IO::println(\"Hello, World!\")\n</code></pre> <p>That's it! This single line is a complete Onion program.</p>"},{"location":"getting-started/hello-world/#running-your-program","title":"Running Your Program","text":"<p>There are two ways to run Onion programs:</p>"},{"location":"getting-started/hello-world/#method-1-direct-execution-with-onion","title":"Method 1: Direct Execution with <code>onion</code>","text":"<p>The <code>onion</code> command compiles and runs your program in memory:</p> <pre><code>onion Hello.on\n</code></pre> <p>Output: <pre><code>Hello, World!\n</code></pre></p>"},{"location":"getting-started/hello-world/#method-2-compilation-with-onionc","title":"Method 2: Compilation with <code>onionc</code>","text":"<p>Compile to <code>.class</code> files and run with Java:</p> <pre><code># Compile\nonionc Hello.on\n\n# Run with Java\njava Hello\n</code></pre>"},{"location":"getting-started/hello-world/#understanding-the-code","title":"Understanding the Code","text":"<pre><code>IO::println(\"Hello, World!\")\n</code></pre> <ul> <li><code>IO</code> - The built-in I/O module</li> <li><code>::</code> - Static method access operator (similar to Java's <code>.</code>)</li> <li><code>println()</code> - Print with newline function</li> <li><code>\"Hello, World!\"</code> - String literal</li> </ul>"},{"location":"getting-started/hello-world/#more-examples","title":"More Examples","text":""},{"location":"getting-started/hello-world/#using-variables","title":"Using Variables","text":"<pre><code>def message :String = \"Hello, Onion!\"\nIO::println(message)\n</code></pre>"},{"location":"getting-started/hello-world/#getting-user-input","title":"Getting User Input","text":"<pre><code>def name :String = IO::input(\"What's your name? \")\nIO::println(\"Hello, \" + name + \"!\")\n</code></pre> <p>Run it: <pre><code>onion greeting.on\n</code></pre></p> <p>Output: <pre><code>What's your name? Alice\nHello, Alice!\n</code></pre></p>"},{"location":"getting-started/hello-world/#with-a-main-class","title":"With a Main Class","text":"<p>You can also write programs with explicit class definitions:</p> <pre><code>class HelloWorld {\n  public:\n    static def main(args: String[]) {\n      IO::println(\"Hello, World!\")\n    }\n}\n</code></pre> <p>This follows the traditional Java main method pattern.</p>"},{"location":"getting-started/hello-world/#command-line-arguments","title":"Command-Line Arguments","text":"<p>Access command-line arguments through the <code>main</code> method:</p> <pre><code>class ArgsDemo {\n  public:\n    static def main(args: String[]) {\n      IO::println(\"Number of arguments: \" + args.length)\n      for i = 0; i &lt; args.length; i = i + 1 {\n        IO::println(\"Arg \" + i + \": \" + args[i])\n      }\n    }\n}\n</code></pre> <p>Run with arguments: <pre><code>onion ArgsDemo.on hello world 123\n</code></pre></p> <p>Output: <pre><code>Number of arguments: 3\nArg 0: hello\nArg 1: world\nArg 2: 123\n</code></pre></p>"},{"location":"getting-started/hello-world/#next-steps","title":"Next Steps","text":"<p>Now that you've written your first Onion program, continue with:</p> <ul> <li>Quick Start Guide - Learn essential language features</li> <li>Basic Syntax - Variables, types, and operators</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install and set up the Onion programming language on your system.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Onion runs on the JVM and requires:</p> <ul> <li>Java Development Kit (JDK) 17 or later</li> <li>SBT (Scala Build Tool) - for building from source</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#method-1-download-pre-built-binary-recommended","title":"Method 1: Download Pre-built Binary (Recommended)","text":"<ol> <li>Download the latest release from the GitHub Releases page</li> <li>Extract the archive:    <pre><code>unzip onion-dist.zip\ncd onion-dist\n</code></pre></li> <li>Add the <code>bin</code> directory to your PATH:    <pre><code>export PATH=$PATH:/path/to/onion-dist/bin\n</code></pre></li> </ol>"},{"location":"getting-started/installation/#method-2-build-from-source","title":"Method 2: Build from Source","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/onion-lang/onion.git\ncd onion\n</code></pre></p> </li> <li> <p>Build the project with SBT:    <pre><code>sbt compile\n</code></pre></p> </li> <li> <p>Create the distribution package:    <pre><code>sbt dist\n</code></pre></p> </li> </ol> <p>This creates a distribution ZIP in <code>target/onion-dist.zip</code></p> <ol> <li>Or build a standalone JAR:    <pre><code>sbt assembly\n</code></pre></li> </ol> <p>This creates <code>onion.jar</code> in the <code>target/scala-3.6.2/</code> directory</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Check that Onion is installed correctly:</p> <pre><code># If using the distribution\nonionc --help\n\n# If using the JAR directly\njava -jar onion.jar --help\n</code></pre>"},{"location":"getting-started/installation/#ide-setup","title":"IDE Setup","text":""},{"location":"getting-started/installation/#visual-studio-code","title":"Visual Studio Code","text":"<p>While there's no official Onion extension yet, you can use:</p> <ul> <li>Generic syntax highlighting for similar languages</li> <li>Java/Scala extensions for dependency management</li> </ul>"},{"location":"getting-started/installation/#intellij-idea","title":"IntelliJ IDEA","text":"<p>For developing the Onion compiler itself:</p> <ol> <li>Install the Scala plugin</li> <li>Import the project as an SBT project</li> <li>The IDE will automatically download dependencies</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Hello World Tutorial - Write your first Onion program</li> <li>Quick Start Guide - Learn the essential features</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide covers the essential features of Onion to get you productive quickly.</p>"},{"location":"getting-started/quick-start/#variables-and-types","title":"Variables and Types","text":"<p>Onion is statically typed with type inference:</p> <pre><code>// Type annotation\ndef name :String = \"Alice\"\ndef age :Int = 30\ndef price :Double = 19.99\n\n// Type inference (coming in future versions)\ndef count = 42  // Inferred as Int\n</code></pre>"},{"location":"getting-started/quick-start/#control-flow","title":"Control Flow","text":""},{"location":"getting-started/quick-start/#if-else","title":"If-Else","text":"<pre><code>def x :Int = 10\n\nif x &gt; 5 {\n  IO::println(\"x is greater than 5\")\n} else {\n  IO::println(\"x is 5 or less\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#while-loop","title":"While Loop","text":"<pre><code>def i :Int = 0\nwhile i &lt; 5 {\n  IO::println(i)\n  i = i + 1\n}\n</code></pre>"},{"location":"getting-started/quick-start/#for-loop","title":"For Loop","text":"<pre><code>for i = 0; i &lt; 10; i = i + 1 {\n  IO::println(\"Count: \" + i)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#foreach-loop","title":"Foreach Loop","text":"<pre><code>def names :String[] = [\"Alice\", \"Bob\", \"Charlie\"]\nforeach name :String in names {\n  IO::println(\"Hello, \" + name)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#select-statement-pattern-matching","title":"Select Statement (Pattern Matching)","text":"<pre><code>def score :Int = 85\n\nselect score {\n  case 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100:\n    IO::println(\"Grade: A\")\n  case 80, 81, 82, 83, 84, 85, 86, 87, 88, 89:\n    IO::println(\"Grade: B\")\n  case 70, 71, 72, 73, 74, 75, 76, 77, 78, 79:\n    IO::println(\"Grade: C\")\n  else:\n    IO::println(\"Grade: F\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#functions","title":"Functions","text":""},{"location":"getting-started/quick-start/#basic-function","title":"Basic Function","text":"<pre><code>def greet(name :String) :String {\n  \"Hello, \" + name + \"!\"\n}\n\ndef message :String = greet(\"World\")\nIO::println(message)\n</code></pre>"},{"location":"getting-started/quick-start/#lambda-expressions","title":"Lambda Expressions","text":"<pre><code>// Lambda syntax: #(params) { body }\ndef add = #(x :Int, y :Int) { x + y }\n\ndef result :Int = add.call(5, 3)  // 8\nIO::println(result)\n</code></pre>"},{"location":"getting-started/quick-start/#function-with-multiple-parameters","title":"Function with Multiple Parameters","text":"<pre><code>def multiply(a :Int, b :Int) :Int {\n  a * b\n}\n\nIO::println(multiply(6, 7))  // 42\n</code></pre>"},{"location":"getting-started/quick-start/#arrays-and-collections","title":"Arrays and Collections","text":""},{"location":"getting-started/quick-start/#arrays","title":"Arrays","text":"<pre><code>// Fixed-size array\ndef numbers :Int[] = new Int[5]\nnumbers[0] = 10\nnumbers[1] = 20\n\n// Array literal\ndef colors :String[] = [\"red\", \"green\", \"blue\"]\n\n// Iterate over array\nforeach color :String in colors {\n  IO::println(color)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#lists-arraylist","title":"Lists (ArrayList)","text":"<pre><code>import {\n  java.util.ArrayList;\n}\n\ndef list :ArrayList = new ArrayList\nlist &lt;&lt; \"First\"   // &lt;&lt; is the append operator\nlist &lt;&lt; \"Second\"\nlist &lt;&lt; \"Third\"\n\nIO::println(list.size)  // 3\nIO::println(list[0])     // \"First\"\n</code></pre>"},{"location":"getting-started/quick-start/#classes-and-objects","title":"Classes and Objects","text":""},{"location":"getting-started/quick-start/#basic-class","title":"Basic Class","text":"<pre><code>class Person {\n  @name :String\n  @age :Int\n\n  public:\n    def new(n :String, a :Int) {\n      @name = n\n      @age = a\n    }\n\n    def greet :String {\n      \"Hello, I'm \" + @name\n    }\n}\n\ndef person :Person = new Person(\"Alice\", 30)\nIO::println(person.greet)\n</code></pre> <p>Key points: - <code>@name</code> denotes instance variables (members) - Members are private by default - Use <code>public:</code> to mark public members - <code>def new</code> is the constructor</p>"},{"location":"getting-started/quick-start/#inheritance","title":"Inheritance","text":"<pre><code>import {\n  java.util.List;\n  java.util.ArrayList;\n}\n\nclass MyList &lt;: List {\n  @internal :ArrayList\n\n  public:\n    def new {\n      @internal = new ArrayList\n    }\n\n    def add(item :Object) :Boolean {\n      @internal.add(item)\n    }\n\n    def size :Int {\n      @internal.size\n    }\n}\n</code></pre> <p>Syntax: - <code>class Child : Parent</code> - extends a class - <code>class Impl &lt;: Interface</code> - implements an interface - <code>class Multi : Parent &lt;: Interface</code> - both</p>"},{"location":"getting-started/quick-start/#java-interoperability","title":"Java Interoperability","text":"<p>Onion has seamless access to Java libraries:</p> <pre><code>import {\n  java.io.File;\n  javax.swing.JFrame;\n  javax.swing.JButton;\n}\n\ndef frame :JFrame = new JFrame(\"My Window\")\nframe.setSize(400, 300)\nframe.setVisible(true)\n\ndef file :File = new File(\"data.txt\")\nif file.exists {\n  IO::println(\"File exists!\")\n}\n</code></pre>"},{"location":"getting-started/quick-start/#common-java-classes","title":"Common Java Classes","text":"<pre><code>// Math operations\ndef random :Double = Math::random()\ndef sqrt :Double = Math::sqrt(16.0)\n\n// String operations\ndef upper :String = \"hello\".toUpperCase()\ndef length :Int = \"hello\".length\n\n// Parsing\ndef num :Int = JInteger::parseInt(\"42\")\n</code></pre>"},{"location":"getting-started/quick-start/#exception-handling","title":"Exception Handling","text":"<pre><code>try {\n  def value :Int = JInteger::parseInt(\"not a number\")\n  IO::println(value)\n} catch e :NumberFormatException {\n  IO::println(\"Invalid number format: \" + e.getMessage)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#type-casting","title":"Type Casting","text":"<p>Use the <code>$</code> operator for type casting:</p> <pre><code>def random :Double = Math::random()\ndef randomInt :Int = (random * 100)$Int\n\ndef obj :Object = \"Hello\"\ndef str :String = obj$String\n</code></pre>"},{"location":"getting-started/quick-start/#module-system","title":"Module System","text":"<pre><code>// Import Java classes\nimport {\n  java.util.ArrayList;\n  java.util.HashMap;\n  java.io.File;\n}\n\n// Use fully qualified names without import\ndef list :java.util.ArrayList = new java.util.ArrayList\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Language Guide - Deep dive into language features</li> <li>Examples - More complete program examples</li> <li>Tools Reference - Learn about compiler options</li> </ul>"},{"location":"guide/basic-syntax/","title":"Basic Syntax","text":"<p>This guide covers the fundamental syntax elements of the Onion programming language.</p>"},{"location":"guide/basic-syntax/#comments","title":"Comments","text":"<p>Currently, Onion supports C-style comments:</p> <pre><code>// Single-line comment\n\n/*\n * Multi-line comment\n * Spans multiple lines\n */\n</code></pre>"},{"location":"guide/basic-syntax/#variables","title":"Variables","text":""},{"location":"guide/basic-syntax/#variable-declaration","title":"Variable Declaration","text":"<p>Variables are declared with the <code>def</code> keyword and type annotations:</p> <pre><code>def name :String = \"Alice\"\ndef age :Int = 30\ndef price :Double = 19.99\ndef isActive :Boolean = true\n</code></pre>"},{"location":"guide/basic-syntax/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Variable names use camelCase: <code>firstName</code>, <code>totalCount</code></li> <li>Class names use PascalCase: <code>Person</code>, <code>Calculator</code></li> <li>Member variables are prefixed with <code>@</code>: <code>@name</code>, <code>@balance</code></li> </ul>"},{"location":"guide/basic-syntax/#primitive-types","title":"Primitive Types","text":"<p>Onion supports the standard JVM primitive types:</p> Type Description Example <code>Int</code> 32-bit integer <code>42</code> <code>Long</code> 64-bit integer <code>42L</code> <code>Double</code> 64-bit floating point <code>3.14</code> <code>Float</code> 32-bit floating point <code>3.14f</code> <code>Boolean</code> true or false <code>true</code>, <code>false</code> <code>Char</code> Single character <code>'A'</code> <code>Byte</code> 8-bit integer <code>127</code> <code>Short</code> 16-bit integer <code>1000</code>"},{"location":"guide/basic-syntax/#literals","title":"Literals","text":""},{"location":"guide/basic-syntax/#string-literals","title":"String Literals","text":"<pre><code>def greeting :String = \"Hello, World!\"\ndef multiline :String = \"Line 1\\nLine 2\\nLine 3\"\ndef withQuotes :String = \"She said \\\"Hello\\\"\"\n</code></pre>"},{"location":"guide/basic-syntax/#numeric-literals","title":"Numeric Literals","text":"<pre><code>def decimal :Int = 42\ndef hex :Int = 0xFF\ndef octal :Int = 077\ndef longValue :Long = 100L\ndef doubleValue :Double = 3.14\ndef scientific :Double = 1.23e10\n</code></pre>"},{"location":"guide/basic-syntax/#character-literals","title":"Character Literals","text":"<pre><code>def letter :Char = 'A'\ndef newline :Char = '\\n'\ndef tab :Char = '\\t'\n</code></pre>"},{"location":"guide/basic-syntax/#boolean-literals","title":"Boolean Literals","text":"<pre><code>def isTrue :Boolean = true\ndef isFalse :Boolean = false\n</code></pre>"},{"location":"guide/basic-syntax/#null-literal","title":"Null Literal","text":"<pre><code>def nullable :String = null\n</code></pre>"},{"location":"guide/basic-syntax/#operators","title":"Operators","text":""},{"location":"guide/basic-syntax/#arithmetic-operators","title":"Arithmetic Operators","text":"<pre><code>def a :Int = 10\ndef b :Int = 3\n\ndef sum :Int = a + b        // 13\ndef diff :Int = a - b       // 7\ndef product :Int = a * b    // 30\ndef quotient :Int = a / b   // 3\ndef remainder :Int = a % b  // 1\n</code></pre>"},{"location":"guide/basic-syntax/#comparison-operators","title":"Comparison Operators","text":"<pre><code>def x :Int = 5\ndef y :Int = 10\n\nx == y  // false (equal)\nx != y  // true  (not equal)\nx &lt; y   // true  (less than)\nx &gt; y   // false (greater than)\nx &lt;= y  // true  (less than or equal)\nx &gt;= y  // false (greater than or equal)\n</code></pre>"},{"location":"guide/basic-syntax/#logical-operators","title":"Logical Operators","text":"<pre><code>def a :Boolean = true\ndef b :Boolean = false\n\na &amp;&amp; b  // false (logical AND)\na || b  // true  (logical OR)\n!a      // false (logical NOT)\n</code></pre>"},{"location":"guide/basic-syntax/#assignment-operators","title":"Assignment Operators","text":"<pre><code>def x :Int = 10\n\nx = 20       // Simple assignment\nx = x + 5    // Add and assign (no += syntax yet)\nx = x - 3    // Subtract and assign\nx = x * 2    // Multiply and assign\n</code></pre>"},{"location":"guide/basic-syntax/#incrementdecrement","title":"Increment/Decrement","text":"<pre><code>def count :Int = 0\ncount = count + 1  // Increment\n// Or use post-increment (in some contexts)\ncount++\ncount--\n</code></pre>"},{"location":"guide/basic-syntax/#type-casting-operator","title":"Type Casting Operator","text":"<p>The <code>$</code> operator performs type casting:</p> <pre><code>def x :Double = 3.14\ndef y :Int = x$Int  // Cast to Int (3)\n\ndef random :Double = Math::random()\ndef randomInt :Int = (random * 100)$Int\n</code></pre>"},{"location":"guide/basic-syntax/#list-append-operator","title":"List Append Operator","text":"<p>The <code>&lt;&lt;</code> operator appends to lists:</p> <pre><code>import { java.util.ArrayList; }\n\ndef list :ArrayList = new ArrayList\nlist &lt;&lt; \"First\"\nlist &lt;&lt; \"Second\"\nlist &lt;&lt; \"Third\"\n</code></pre>"},{"location":"guide/basic-syntax/#arrays","title":"Arrays","text":""},{"location":"guide/basic-syntax/#array-declaration","title":"Array Declaration","text":"<pre><code>// Create array with size\ndef numbers :Int[] = new Int[10]\n\n// Array literal\ndef colors :String[] = [\"red\", \"green\", \"blue\"]\n\n// Mixed approach\ndef scores :Double[] = new Double[5]\nscores[0] = 95.5\nscores[1] = 87.3\n</code></pre>"},{"location":"guide/basic-syntax/#array-access","title":"Array Access","text":"<pre><code>def fruits :String[] = [\"apple\", \"banana\", \"orange\"]\n\ndef first :String = fruits[0]     // \"apple\"\ndef second :String = fruits[1]    // \"banana\"\n\nfruits[2] = \"grape\"  // Modify element\n\ndef length :Int = fruits.length  // Array length\n</code></pre>"},{"location":"guide/basic-syntax/#expressions","title":"Expressions","text":""},{"location":"guide/basic-syntax/#arithmetic-expressions","title":"Arithmetic Expressions","text":"<pre><code>def result :Int = (10 + 5) * 2 - 3  // 27\ndef average :Double = (a + b + c) / 3.0\n</code></pre>"},{"location":"guide/basic-syntax/#string-concatenation","title":"String Concatenation","text":"<pre><code>def firstName :String = \"Alice\"\ndef lastName :String = \"Smith\"\ndef fullName :String = firstName + \" \" + lastName\n\ndef age :Int = 30\ndef message :String = \"I am \" + age + \" years old\"\n</code></pre>"},{"location":"guide/basic-syntax/#method-calls","title":"Method Calls","text":"<pre><code>// Static method call\nIO::println(\"Hello\")\n\n// Instance method call\ndef text :String = \"hello\"\ndef upper :String = text.toUpperCase()\ndef len :Int = text.length\n</code></pre>"},{"location":"guide/basic-syntax/#object-creation","title":"Object Creation","text":"<pre><code>import { java.util.ArrayList; }\n\ndef list :ArrayList = new ArrayList\ndef array :String[] = new String[10]\n</code></pre>"},{"location":"guide/basic-syntax/#statements","title":"Statements","text":""},{"location":"guide/basic-syntax/#expression-statements","title":"Expression Statements","text":"<p>Any expression can be a statement:</p> <pre><code>IO::println(\"Hello\")\ndef x :Int = 10\nx = x + 1\n</code></pre>"},{"location":"guide/basic-syntax/#block-statements","title":"Block Statements","text":"<p>Blocks are enclosed in curly braces:</p> <pre><code>{\n  def temp :Int = 5\n  IO::println(temp)\n  // temp is only visible in this block\n}\n</code></pre>"},{"location":"guide/basic-syntax/#scope-and-visibility","title":"Scope and Visibility","text":""},{"location":"guide/basic-syntax/#local-variables","title":"Local Variables","text":"<p>Variables declared in a method or block are local to that scope:</p> <pre><code>def method {\n  def local :Int = 10\n  // local is only visible here\n}\n</code></pre>"},{"location":"guide/basic-syntax/#member-variables","title":"Member Variables","text":"<p>Member variables are prefixed with <code>@</code> and belong to the class instance:</p> <pre><code>class Example {\n  @count :Int\n  @name :String\n\n  public:\n    def increment {\n      @count = @count + 1\n    }\n}\n</code></pre>"},{"location":"guide/basic-syntax/#access-modifiers","title":"Access Modifiers","text":"<p>By default, members are private. Use <code>public:</code> to mark public members:</p> <pre><code>class Person {\n  @ssn :String  // Private by default\n\n  public:\n    @name :String  // Public\n\n    def getName :String {  // Public method\n      @name\n    }\n}\n</code></pre>"},{"location":"guide/basic-syntax/#module-system","title":"Module System","text":""},{"location":"guide/basic-syntax/#import-statements","title":"Import Statements","text":"<p>Import Java classes for use in your Onion code:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.HashMap;\n  java.io.File;\n}\n\ndef list :ArrayList = new ArrayList\ndef map :HashMap = new HashMap\ndef file :File = new File(\"data.txt\")\n</code></pre>"},{"location":"guide/basic-syntax/#fully-qualified-names","title":"Fully Qualified Names","text":"<p>You can also use fully qualified names without importing:</p> <pre><code>def list :java.util.ArrayList = new java.util.ArrayList\n</code></pre>"},{"location":"guide/basic-syntax/#next-steps","title":"Next Steps","text":"<ul> <li>Variables and Types - Deep dive into the type system</li> <li>Control Flow - Conditionals and loops</li> <li>Functions - Function definitions and lambdas</li> </ul>"},{"location":"guide/classes-and-objects/","title":"Classes and Objects","text":"<p>Onion is an object-oriented language with full support for classes, inheritance, and interfaces.</p>"},{"location":"guide/classes-and-objects/#class-definition","title":"Class Definition","text":""},{"location":"guide/classes-and-objects/#basic-class","title":"Basic Class","text":"<p>Define a class with the <code>class</code> keyword:</p> <pre><code>class Person {\n  @name :String\n  @age :Int\n\n  public:\n    def new(n :String, a :Int) {\n      @name = n\n      @age = a\n    }\n\n    def greet :String {\n      \"Hello, I'm \" + @name\n    }\n}\n</code></pre>"},{"location":"guide/classes-and-objects/#creating-objects","title":"Creating Objects","text":"<p>Instantiate objects with the <code>new</code> keyword:</p> <pre><code>def person :Person = new Person(\"Alice\", 30)\nIO::println(person.greet())  // \"Hello, I'm Alice\"\n</code></pre>"},{"location":"guide/classes-and-objects/#member-variables","title":"Member Variables","text":""},{"location":"guide/classes-and-objects/#instance-variables","title":"Instance Variables","text":"<p>Instance variables are prefixed with <code>@</code>:</p> <pre><code>class Counter {\n  @count :Int\n\n  public:\n    def new {\n      @count = 0\n    }\n\n    def increment {\n      @count = @count + 1\n    }\n\n    def getCount :Int {\n      @count\n    }\n}\n</code></pre>"},{"location":"guide/classes-and-objects/#access-modifiers","title":"Access Modifiers","text":"<p>Members are private by default. Use <code>public:</code> to mark public members:</p> <pre><code>class BankAccount {\n  @balance :Double  // Private (default)\n  @accountNumber :String  // Private\n\n  public:\n    @owner :String  // Public\n\n    def new(owner :String, initial :Double) {\n      @owner = owner\n      @balance = initial\n    }\n\n    def deposit(amount :Double) {  // Public method\n      @balance = @balance + amount\n    }\n\n    def getBalance :Double {  // Public method\n      @balance\n    }\n}\n</code></pre>"},{"location":"guide/classes-and-objects/#static-members","title":"Static Members","text":"<p>Static members belong to the class, not instances:</p> <pre><code>class MathUtils {\n  static @PI :Double = 3.14159\n\n  public:\n    static def square(x :Double) :Double {\n      x * x\n    }\n\n    static def circleArea(radius :Double) :Double {\n      MathUtils::PI * radius * radius\n    }\n}\n\n// Access static members with ::\ndef pi :Double = MathUtils::PI\ndef area :Double = MathUtils::circleArea(5.0)\n</code></pre>"},{"location":"guide/classes-and-objects/#constructors","title":"Constructors","text":""},{"location":"guide/classes-and-objects/#default-constructor","title":"Default Constructor","text":"<p>Define constructors with <code>def new</code>:</p> <pre><code>class Point {\n  @x :Int\n  @y :Int\n\n  public:\n    def new(x :Int, y :Int) {\n      @x = x\n      @y = y\n    }\n}\n\ndef point :Point = new Point(10, 20)\n</code></pre>"},{"location":"guide/classes-and-objects/#multiple-constructors","title":"Multiple Constructors","text":"<p>Overload constructors for different initialization patterns:</p> <pre><code>class Rectangle {\n  @width :Int\n  @height :Int\n\n  public:\n    def new {\n      @width = 0\n      @height = 0\n    }\n\n    def new(size :Int) {\n      @width = size\n      @height = size\n    }\n\n    def new(w :Int, h :Int) {\n      @width = w\n      @height = h\n    }\n}\n\ndef rect1 :Rectangle = new Rectangle()\ndef rect2 :Rectangle = new Rectangle(10)\ndef rect3 :Rectangle = new Rectangle(10, 20)\n</code></pre>"},{"location":"guide/classes-and-objects/#named-constructors","title":"Named Constructors","text":"<p>Use special syntax for named constructors:</p> <pre><code>class Window {\n  @title :String\n\n  public:\n    def this:(title :String) {\n      @title = title\n    }\n}\n\ndef window :Window = new Window(\"My Window\")\n</code></pre>"},{"location":"guide/classes-and-objects/#methods","title":"Methods","text":""},{"location":"guide/classes-and-objects/#instance-methods","title":"Instance Methods","text":"<p>Methods that operate on instance data:</p> <pre><code>class Circle {\n  @radius :Double\n\n  public:\n    def new(r :Double) {\n      @radius = r\n    }\n\n    def area :Double {\n      3.14159 * @radius * @radius\n    }\n\n    def circumference :Double {\n      2.0 * 3.14159 * @radius\n    }\n}\n\ndef circle :Circle = new Circle(5.0)\nIO::println(\"Area: \" + circle.area())\n</code></pre>"},{"location":"guide/classes-and-objects/#method-overloading","title":"Method Overloading","text":"<p>Multiple methods with the same name but different parameters:</p> <pre><code>class Printer {\n  public:\n    def print(value :Int) {\n      IO::println(\"Int: \" + value)\n    }\n\n    def print(value :String) {\n      IO::println(\"String: \" + value)\n    }\n\n    def print(value :Double) {\n      IO::println(\"Double: \" + value)\n    }\n}\n\ndef printer :Printer = new Printer\nprinter.print(42)\nprinter.print(\"Hello\")\nprinter.print(3.14)\n</code></pre>"},{"location":"guide/classes-and-objects/#getter-and-setter-methods","title":"Getter and Setter Methods","text":"<pre><code>class Person {\n  @name :String\n  @age :Int\n\n  public:\n    def getName :String {\n      @name\n    }\n\n    def setName(name :String) {\n      @name = name\n    }\n\n    def getAge :Int {\n      @age\n    }\n\n    def setAge(age :Int) {\n      if age &gt;= 0 {\n        @age = age\n      }\n    }\n}\n</code></pre>"},{"location":"guide/classes-and-objects/#the-self-reference","title":"The <code>self</code> Reference","text":"<p>Access the current instance with <code>self</code>:</p> <pre><code>import {\n  javax.swing.JButton;\n  java.awt.event.ActionListener;\n}\n\nclass ButtonHandler &lt;: ActionListener {\n  public:\n    def actionPerformed(event :ActionEvent) {\n      def button :JButton = event.getSource()$JButton\n      button.addActionListener(self)  // Reference to this instance\n    }\n}\n</code></pre>"},{"location":"guide/classes-and-objects/#next-steps","title":"Next Steps","text":"<ul> <li>Inheritance - Extending classes and implementing interfaces</li> <li>Java Interoperability - Working with Java classes</li> <li>Examples - Object-oriented examples</li> </ul>"},{"location":"guide/control-flow/","title":"Control Flow","text":"<p>Onion provides several control flow constructs for conditionals, loops, and pattern matching.</p>"},{"location":"guide/control-flow/#conditional-statements","title":"Conditional Statements","text":""},{"location":"guide/control-flow/#if-else","title":"If-Else","text":"<p>Basic conditional execution:</p> <pre><code>def age :Int = 18\n\nif age &gt;= 18 {\n  IO::println(\"Adult\")\n} else {\n  IO::println(\"Minor\")\n}\n</code></pre>"},{"location":"guide/control-flow/#if-else-if-else","title":"If-Else If-Else","text":"<p>Multiple conditions:</p> <pre><code>def score :Int = 85\n\nif score &gt;= 90 {\n  IO::println(\"Grade: A\")\n} else if score &gt;= 80 {\n  IO::println(\"Grade: B\")\n} else if score &gt;= 70 {\n  IO::println(\"Grade: C\")\n} else if score &gt;= 60 {\n  IO::println(\"Grade: D\")\n} else {\n  IO::println(\"Grade: F\")\n}\n</code></pre>"},{"location":"guide/control-flow/#assignment-in-conditions","title":"Assignment in Conditions","text":"<p>You can assign and test in one expression:</p> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.InputStreamReader;\n}\n\ndef reader :BufferedReader = new BufferedReader(\n  new InputStreamReader(System::in)\n)\n\ndef line :String = null\nwhile (line = reader.readLine()) != null {\n  IO::println(\"Read: \" + line)\n}\n</code></pre>"},{"location":"guide/control-flow/#loops","title":"Loops","text":""},{"location":"guide/control-flow/#while-loop","title":"While Loop","text":"<p>Execute while a condition is true:</p> <pre><code>def count :Int = 0\nwhile count &lt; 5 {\n  IO::println(\"Count: \" + count)\n  count = count + 1\n}\n</code></pre> <p>Output: <pre><code>Count: 0\nCount: 1\nCount: 2\nCount: 3\nCount: 4\n</code></pre></p>"},{"location":"guide/control-flow/#for-loop","title":"For Loop","text":"<p>Traditional C-style for loop:</p> <pre><code>for i = 0; i &lt; 10; i = i + 1 {\n  IO::println(i)\n}\n</code></pre> <p>Syntax: <code>for init; condition; update { body }</code></p>"},{"location":"guide/control-flow/#foreach-loop","title":"Foreach Loop","text":"<p>Iterate over arrays and collections:</p> <pre><code>def fruits :String[] = [\"apple\", \"banana\", \"cherry\"]\n\nforeach fruit :String in fruits {\n  IO::println(\"Fruit: \" + fruit)\n}\n</code></pre> <p>With collections:</p> <pre><code>import { java.util.ArrayList; }\n\ndef list :ArrayList = new ArrayList\nlist &lt;&lt; \"First\"\nlist &lt;&lt; \"Second\"\nlist &lt;&lt; \"Third\"\n\nforeach item :Object in list {\n  IO::println(item$String)\n}\n</code></pre>"},{"location":"guide/control-flow/#pattern-matching","title":"Pattern Matching","text":""},{"location":"guide/control-flow/#select-statement","title":"Select Statement","text":"<p>Switch-style pattern matching with multiple values per case:</p> <pre><code>def day :Int = 3\n\nselect day {\n  case 1:\n    IO::println(\"Monday\")\n  case 2:\n    IO::println(\"Tuesday\")\n  case 3:\n    IO::println(\"Wednesday\")\n  case 4:\n    IO::println(\"Thursday\")\n  case 5:\n    IO::println(\"Friday\")\n  case 6, 7:\n    IO::println(\"Weekend\")\n  else:\n    IO::println(\"Invalid day\")\n}\n</code></pre>"},{"location":"guide/control-flow/#multiple-values-per-case","title":"Multiple Values Per Case","text":"<p>Group multiple values in a single case:</p> <pre><code>def num :Int = (Math::random() * 10)$Int\n\nselect num {\n  case 0, 1, 2, 3:\n    IO::println(\"Low\")\n  case 4, 5, 6:\n    IO::println(\"Medium\")\n  case 7, 8, 9:\n    IO::println(\"High\")\n  else:\n    IO::println(\"Other\")\n}\n</code></pre>"},{"location":"guide/control-flow/#select-with-expressions","title":"Select with Expressions","text":"<pre><code>def score :Int = 85\ndef grade :String = null\n\nselect score {\n  case 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100:\n    grade = \"A\"\n  case 80, 81, 82, 83, 84, 85, 86, 87, 88, 89:\n    grade = \"B\"\n  case 70, 71, 72, 73, 74, 75, 76, 77, 78, 79:\n    grade = \"C\"\n  else:\n    grade = \"F\"\n}\n\nIO::println(\"Grade: \" + grade)\n</code></pre>"},{"location":"guide/control-flow/#break-and-continue","title":"Break and Continue","text":""},{"location":"guide/control-flow/#break-statement","title":"Break Statement","text":"<p>Exit a loop early:</p> <pre><code>def i :Int = 0\nwhile true {\n  if i &gt;= 5 {\n    break\n  }\n  IO::println(i)\n  i = i + 1\n}\n</code></pre>"},{"location":"guide/control-flow/#continue-statement","title":"Continue Statement","text":"<p>Skip to the next iteration:</p> <pre><code>for i = 0; i &lt; 10; i = i + 1 {\n  if i % 2 == 0 {\n    continue  // Skip even numbers\n  }\n  IO::println(i)  // Print odd numbers only\n}\n</code></pre> <p>Output: <code>1 3 5 7 9</code></p>"},{"location":"guide/control-flow/#exception-handling","title":"Exception Handling","text":""},{"location":"guide/control-flow/#try-catch","title":"Try-Catch","text":"<p>Handle exceptions with try-catch blocks:</p> <pre><code>import { java.lang.NumberFormatException; }\n\ndef input :String = \"not a number\"\n\ntry {\n  def number :Int = JInteger::parseInt(input)\n  IO::println(\"Parsed: \" + number)\n} catch e :NumberFormatException {\n  IO::println(\"Invalid number: \" + e.getMessage())\n}\n</code></pre>"},{"location":"guide/control-flow/#multiple-catch-blocks","title":"Multiple Catch Blocks","text":"<pre><code>import {\n  java.io.FileReader;\n  java.io.FileNotFoundException;\n  java.io.IOException;\n}\n\ntry {\n  def reader :FileReader = new FileReader(\"file.txt\")\n  // Use reader...\n} catch e :FileNotFoundException {\n  IO::println(\"File not found: \" + e.getMessage())\n} catch e :IOException {\n  IO::println(\"IO error: \" + e.getMessage())\n}\n</code></pre>"},{"location":"guide/control-flow/#accessing-exception-information","title":"Accessing Exception Information","text":"<pre><code>try {\n  def result :Int = 10 / 0\n} catch e :ArithmeticException {\n  IO::println(\"Error: \" + e.getMessage())\n  IO::println(\"Type: \" + e.getClass().getName())\n}\n</code></pre>"},{"location":"guide/control-flow/#control-flow-best-practices","title":"Control Flow Best Practices","text":""},{"location":"guide/control-flow/#early-return","title":"Early Return","text":"<p>Use early returns to reduce nesting:</p> <pre><code>def processData(data :String) :Int {\n  if data == null {\n    return 0\n  }\n\n  if data.length() == 0 {\n    return 0\n  }\n\n  // Process data...\n  data.length()\n}\n</code></pre>"},{"location":"guide/control-flow/#guard-clauses","title":"Guard Clauses","text":"<p>Validate preconditions early:</p> <pre><code>def divide(a :Int, b :Int) :Int {\n  if b == 0 {\n    IO::println(\"Error: Division by zero\")\n    return 0\n  }\n\n  a / b\n}\n</code></pre>"},{"location":"guide/control-flow/#avoid-deep-nesting","title":"Avoid Deep Nesting","text":"<p>Prefer flat code over deeply nested conditions:</p> <pre><code>// Bad: Deep nesting\nif condition1 {\n  if condition2 {\n    if condition3 {\n      // Code here\n    }\n  }\n}\n\n// Good: Early returns or guard clauses\nif !condition1 { return }\nif !condition2 { return }\nif !condition3 { return }\n// Code here\n</code></pre>"},{"location":"guide/control-flow/#next-steps","title":"Next Steps","text":"<ul> <li>Functions - Function definitions and lambdas</li> <li>Classes and Objects - OOP in Onion</li> <li>Examples - See control flow in action</li> </ul>"},{"location":"guide/functions/","title":"Functions","text":"<p>Functions in Onion allow you to encapsulate reusable code. Onion supports both named functions (methods) and anonymous functions (lambdas).</p>"},{"location":"guide/functions/#function-definitions","title":"Function Definitions","text":""},{"location":"guide/functions/#basic-function","title":"Basic Function","text":"<p>Define functions with the <code>def</code> keyword:</p> <pre><code>def greet(name :String) :String {\n  \"Hello, \" + name + \"!\"\n}\n\ndef message :String = greet(\"Alice\")\nIO::println(message)  // \"Hello, Alice!\"\n</code></pre>"},{"location":"guide/functions/#function-with-multiple-parameters","title":"Function with Multiple Parameters","text":"<pre><code>def add(a :Int, b :Int) :Int {\n  a + b\n}\n\ndef sum :Int = add(5, 3)\nIO::println(sum)  // 8\n</code></pre>"},{"location":"guide/functions/#function-with-no-parameters","title":"Function with No Parameters","text":"<pre><code>def getCurrentTime :String {\n  System::currentTimeMillis()$String\n}\n\nIO::println(getCurrentTime())\n</code></pre>"},{"location":"guide/functions/#function-with-no-return-value","title":"Function with No Return Value","text":"<p>Functions that don't return a value implicitly return nothing:</p> <pre><code>def printMessage(msg :String) {\n  IO::println(\"Message: \" + msg)\n}\n\nprintMessage(\"Hello\")\n</code></pre>"},{"location":"guide/functions/#return-statements","title":"Return Statements","text":""},{"location":"guide/functions/#explicit-return","title":"Explicit Return","text":"<p>Use <code>return</code> to exit a function early:</p> <pre><code>def max(a :Int, b :Int) :Int {\n  if a &gt; b {\n    return a\n  }\n  return b\n}\n</code></pre>"},{"location":"guide/functions/#implicit-return","title":"Implicit Return","text":"<p>The last expression in a function is implicitly returned:</p> <pre><code>def square(x :Int) :Int {\n  x * x  // Implicitly returned\n}\n</code></pre>"},{"location":"guide/functions/#lambda-expressions","title":"Lambda Expressions","text":""},{"location":"guide/functions/#lambda-syntax","title":"Lambda Syntax","text":"<p>Anonymous functions use the <code>#(params) { body }</code> syntax:</p> <pre><code>def double = #(x :Int) { x * 2 }\n\ndef result :Int = double.call(5)$Int  // 10\n</code></pre>"},{"location":"guide/functions/#lambda-with-multiple-parameters","title":"Lambda with Multiple Parameters","text":"<pre><code>def add = #(x :Int, y :Int) { x + y }\n\ndef sum :Int = add.call(3, 7)$Int  // 10\n</code></pre>"},{"location":"guide/functions/#lambda-with-no-parameters","title":"Lambda with No Parameters","text":"<pre><code>def sayHello = #() { IO::println(\"Hello!\") }\n\nsayHello.call()\n</code></pre>"},{"location":"guide/functions/#closures","title":"Closures","text":"<p>Lambdas can capture variables from their enclosing scope:</p> <pre><code>def makeCounter {\n  def count :Int = 0\n  #() {\n    count = count + 1\n    count\n  }\n}\n\ndef counter = makeCounter()\nIO::println(counter.call())  // 1\nIO::println(counter.call())  // 2\nIO::println(counter.call())  // 3\n</code></pre>"},{"location":"guide/functions/#capturing-loop-variables","title":"Capturing Loop Variables","text":"<pre><code>def i :Int = 0\ndef filter = #(line :String) {\n  i = i + 1\n  line + \" (line \" + i + \")\"\n}\n\nIO::println(filter.call(\"First\"))   // \"First (line 1)\"\nIO::println(filter.call(\"Second\"))  // \"Second (line 2)\"\n</code></pre>"},{"location":"guide/functions/#function-types","title":"Function Types","text":"<p>Functions are typed using <code>Function0</code> through <code>Function10</code> interfaces:</p> <pre><code>// Function with 1 parameter\ndef func1 :Function1 = #(x :Int) { x * 2 }\n\n// Function with 2 parameters\ndef func2 :Function2 = #(x :Int, y :Int) { x + y }\n\n// Function with no parameters\ndef func0 :Function0 = #() { 42 }\n</code></pre> <p>The number indicates the parameter count: - <code>Function0</code> - No parameters - <code>Function1</code> - One parameter - <code>Function2</code> - Two parameters - ... up to <code>Function10</code> - Ten parameters</p>"},{"location":"guide/functions/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Functions that accept or return other functions:</p> <pre><code>def applyTwice(f :Function1, value :Int) :Int {\n  def temp :Int = f.call(value)$Int\n  f.call(temp)$Int\n}\n\ndef increment = #(x :Int) { x + 1 }\ndef result :Int = applyTwice(increment, 5)  // 7\n</code></pre>"},{"location":"guide/functions/#recursive-functions","title":"Recursive Functions","text":"<p>Functions can call themselves:</p> <pre><code>def factorial(n :Int) :Int {\n  if n &lt;= 1 {\n    return 1\n  }\n  n * factorial(n - 1)\n}\n\nIO::println(factorial(5))  // 120\n</code></pre>"},{"location":"guide/functions/#tail-recursion","title":"Tail Recursion","text":"<p>While Onion doesn't optimize tail calls, you can write tail-recursive functions:</p> <pre><code>def factorialTail(n :Int, acc :Int) :Int {\n  if n &lt;= 1 {\n    return acc\n  }\n  factorialTail(n - 1, n * acc)\n}\n\ndef factorial(n :Int) :Int {\n  factorialTail(n, 1)\n}\n\nIO::println(factorial(5))  // 120\n</code></pre>"},{"location":"guide/functions/#method-overloading","title":"Method Overloading","text":"<p>Classes can have multiple methods with the same name but different parameter types:</p> <pre><code>class Calculator {\n  public:\n    def add(a :Int, b :Int) :Int {\n      a + b\n    }\n\n    def add(a :Double, b :Double) :Double {\n      a + b\n    }\n\n    def add(a :String, b :String) :String {\n      a + b\n    }\n}\n\ndef calc :Calculator = new Calculator\nIO::println(calc.add(5, 3))           // 8\nIO::println(calc.add(2.5, 3.7))       // 6.2\nIO::println(calc.add(\"Hello\", \"!\"))   // \"Hello!\"\n</code></pre>"},{"location":"guide/functions/#static-methods","title":"Static Methods","text":"<p>Methods can be static (class-level) rather than instance-level:</p> <pre><code>class MathUtils {\n  public:\n    static def square(x :Int) :Int {\n      x * x\n    }\n\n    static def cube(x :Int) :Int {\n      x * x * x\n    }\n}\n\n// Call static methods with ::\nIO::println(MathUtils::square(5))  // 25\nIO::println(MathUtils::cube(3))    // 27\n</code></pre>"},{"location":"guide/functions/#function-examples","title":"Function Examples","text":""},{"location":"guide/functions/#filter-function","title":"Filter Function","text":"<pre><code>def filterLines(lines :String[], predicate :Function1) :String[] {\n  def result :ArrayList = new ArrayList\n\n  foreach line :String in lines {\n    def keep :Boolean = predicate.call(line)$Boolean\n    if keep {\n      result &lt;&lt; line\n    }\n  }\n\n  // Convert to array (simplified)\n  result.toArray(new String[result.size()])\n}\n\ndef startsWithError = #(line :String) {\n  line.startsWith(\"ERROR\")\n}\n\ndef lines :String[] = [\"INFO: OK\", \"ERROR: Failed\", \"ERROR: Timeout\"]\ndef errors :String[] = filterLines(lines, startsWithError)\n</code></pre>"},{"location":"guide/functions/#map-function","title":"Map Function","text":"<pre><code>def mapLines(lines :String[], transform :Function1) :String[] {\n  def result :ArrayList = new ArrayList\n\n  foreach line :String in lines {\n    def transformed :String = transform.call(line)$String\n    result &lt;&lt; transformed\n  }\n\n  result.toArray(new String[result.size()])\n}\n\ndef toUpper = #(s :String) { s.toUpperCase() }\n\ndef lines :String[] = [\"hello\", \"world\"]\ndef upper :String[] = mapLines(lines, toUpper)\n// [\"HELLO\", \"WORLD\"]\n</code></pre>"},{"location":"guide/functions/#best-practices","title":"Best Practices","text":""},{"location":"guide/functions/#single-responsibility","title":"Single Responsibility","text":"<p>Each function should do one thing well:</p> <pre><code>// Good: Each function has a single purpose\ndef readFile(path :String) :String { ... }\ndef parseData(content :String) :Data { ... }\ndef validateData(data :Data) :Boolean { ... }\n\n// Bad: Function does too much\ndef processFile(path :String) :Boolean {\n  // Reads, parses, validates, and saves\n  ...\n}\n</code></pre>"},{"location":"guide/functions/#descriptive-names","title":"Descriptive Names","text":"<p>Use clear, descriptive function names:</p> <pre><code>// Good\ndef calculateTotalPrice(items :Item[]) :Double { ... }\ndef isValidEmail(email :String) :Boolean { ... }\n\n// Bad\ndef calc(arr :Item[]) :Double { ... }\ndef check(s :String) :Boolean { ... }\n</code></pre>"},{"location":"guide/functions/#keep-functions-short","title":"Keep Functions Short","text":"<p>Aim for functions that fit on one screen:</p> <pre><code>def processOrder(order :Order) :Boolean {\n  if !validateOrder(order) {\n    return false\n  }\n\n  if !chargePayment(order) {\n    return false\n  }\n\n  if !shipOrder(order) {\n    return false\n  }\n\n  true\n}\n</code></pre>"},{"location":"guide/functions/#next-steps","title":"Next Steps","text":"<ul> <li>Classes and Objects - Methods in classes</li> <li>Lambda Expressions - Deep dive into lambdas</li> <li>Examples - Functional programming examples</li> </ul>"},{"location":"guide/inheritance/","title":"Inheritance","text":"<p>Onion supports both class inheritance and interface implementation, allowing you to build hierarchical type systems.</p>"},{"location":"guide/inheritance/#extending-classes","title":"Extending Classes","text":""},{"location":"guide/inheritance/#basic-inheritance","title":"Basic Inheritance","text":"<p>Use <code>:</code> to extend a parent class:</p> <pre><code>class Animal {\n  @name :String\n\n  public:\n    def new(n :String) {\n      @name = n\n    }\n\n    def speak :String {\n      \"Some sound\"\n    }\n}\n\nclass Dog : Animal {\n  public:\n    def new(n :String) {\n      super.new(n)\n    }\n\n    def speak :String {\n      \"Woof!\"\n    }\n}\n\ndef dog :Dog = new Dog(\"Buddy\")\nIO::println(dog.speak())  // \"Woof!\"\n</code></pre>"},{"location":"guide/inheritance/#calling-parent-constructor","title":"Calling Parent Constructor","text":"<p>Use <code>super.new()</code> to call the parent constructor:</p> <pre><code>class Vehicle {\n  @brand :String\n\n  public:\n    def new(b :String) {\n      @brand = b\n    }\n}\n\nclass Car : Vehicle {\n  @model :String\n\n  public:\n    def new(b :String, m :String) {\n      super.new(b)  // Call parent constructor\n      @model = m\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#method-overriding","title":"Method Overriding","text":"<p>Child classes can override parent methods:</p> <pre><code>class Shape {\n  public:\n    def area :Double {\n      0.0\n    }\n\n    def describe :String {\n      \"A shape\"\n    }\n}\n\nclass Circle : Shape {\n  @radius :Double\n\n  public:\n    def new(r :Double) {\n      @radius = r\n    }\n\n    def area :Double {  // Override\n      3.14159 * @radius * @radius\n    }\n\n    def describe :String {  // Override\n      \"A circle with radius \" + @radius\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#implementing-interfaces","title":"Implementing Interfaces","text":""},{"location":"guide/inheritance/#single-interface","title":"Single Interface","text":"<p>Use <code>&lt;:</code> to implement an interface:</p> <pre><code>import { java.lang.Comparable; }\n\nclass Person &lt;: Comparable {\n  @name :String\n  @age :Int\n\n  public:\n    def new(n :String, a :Int) {\n      @name = n\n      @age = a\n    }\n\n    def compareTo(other :Object) :Int {\n      def otherPerson :Person = other$Person\n      @age - otherPerson.@age\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#multiple-interfaces","title":"Multiple Interfaces","text":"<p>Implement multiple interfaces with additional <code>&lt;:</code> declarations:</p> <pre><code>import {\n  java.io.Serializable;\n  java.lang.Comparable;\n}\n\nclass Student &lt;: Serializable &lt;: Comparable {\n  @id :Int\n  @name :String\n\n  public:\n    def new(i :Int, n :String) {\n      @id = i\n      @name = n\n    }\n\n    def compareTo(other :Object) :Int {\n      def otherStudent :Student = other$Student\n      @id - otherStudent.@id\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#combining-inheritance-and-interfaces","title":"Combining Inheritance and Interfaces","text":"<p>Use both <code>:</code> (extend class) and <code>&lt;:</code> (implement interface):</p> <pre><code>import {\n  javax.swing.JFrame;\n  java.awt.event.ActionListener;\n  java.awt.event.ActionEvent;\n}\n\nclass Calculator : JFrame &lt;: ActionListener {\n  @result :Long\n\n  public:\n    def new {\n      // JFrame constructor\n    }\n\n    def actionPerformed(event :ActionEvent) {\n      // Implement ActionListener interface\n      IO::println(\"Button clicked\")\n    }\n}\n</code></pre> <p>Syntax: <pre><code>class Child : ParentClass &lt;: Interface1 &lt;: Interface2 {\n  // ...\n}\n</code></pre></p>"},{"location":"guide/inheritance/#delegation-pattern","title":"Delegation Pattern","text":""},{"location":"guide/inheritance/#forward-directive","title":"Forward Directive","text":"<p>Use <code>forward</code> to delegate interface methods to a member:</p> <pre><code>import {\n  java.util.List;\n  java.util.ArrayList;\n}\n\nclass MyList &lt;: List {\n  forward @internal :List  // Delegate List methods to @internal\n\n  @internal :ArrayList\n\n  public:\n    def new {\n      @internal = new ArrayList\n    }\n\n    // Custom methods\n    def addAll(items :String[]) {\n      foreach item :String in items {\n        @internal.add(item)\n      }\n    }\n}\n\ndef list :MyList = new MyList\nlist &lt;&lt; \"First\"   // Uses delegated add() method\nlist &lt;&lt; \"Second\"\nIO::println(list.size())  // Uses delegated size() method\n</code></pre> <p>The <code>forward</code> directive automatically implements interface methods by forwarding calls to the specified member.</p>"},{"location":"guide/inheritance/#polymorphism","title":"Polymorphism","text":""},{"location":"guide/inheritance/#type-substitution","title":"Type Substitution","text":"<p>Child objects can be assigned to parent variables:</p> <pre><code>class Animal {\n  public:\n    def speak :String {\n      \"Generic sound\"\n    }\n}\n\nclass Dog : Animal {\n  public:\n    def speak :String {\n      \"Woof!\"\n    }\n}\n\nclass Cat : Animal {\n  public:\n    def speak :String {\n      \"Meow!\"\n    }\n}\n\ndef animals :Animal[] = new Animal[3]\nanimals[0] = new Dog\nanimals[1] = new Cat\nanimals[2] = new Animal\n\nforeach animal :Animal in animals {\n  IO::println(animal.speak())\n}\n// Output:\n// Woof!\n// Meow!\n// Generic sound\n</code></pre>"},{"location":"guide/inheritance/#interface-polymorphism","title":"Interface Polymorphism","text":"<pre><code>import {\n  java.util.List;\n  java.util.ArrayList;\n  java.util.LinkedList;\n}\n\ndef list1 :List = new ArrayList  // ArrayList implements List\ndef list2 :List = new LinkedList  // LinkedList implements List\n\ndef lists :List[] = [list1, list2]\nforeach list :List in lists {\n  list.add(\"Item\")\n  IO::println(\"Size: \" + list.size())\n}\n</code></pre>"},{"location":"guide/inheritance/#abstract-concepts","title":"Abstract Concepts","text":""},{"location":"guide/inheritance/#note-on-abstract-methods","title":"Note on Abstract Methods","text":"<p>Onion currently has limited support for abstract method validation. Abstract methods may not be enforced at compile time:</p> <pre><code>// Abstract pattern (not fully enforced)\nclass AbstractShape {\n  public:\n    def area :Double {\n      // Should be overridden by subclasses\n      0.0\n    }\n}\n\nclass Circle : AbstractShape {\n  @radius :Double\n\n  public:\n    def area :Double {\n      3.14159 * @radius * @radius\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#inheritance-best-practices","title":"Inheritance Best Practices","text":""},{"location":"guide/inheritance/#favor-composition-over-inheritance","title":"Favor Composition Over Inheritance","text":"<p>Use delegation when possible:</p> <pre><code>// Instead of inheriting from ArrayList\nclass MyList : ArrayList {\n  // ...\n}\n\n// Consider delegation\nclass MyList &lt;: List {\n  forward @internal :List\n  @internal :ArrayList\n\n  public:\n    def new {\n      @internal = new ArrayList\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#keep-hierarchies-shallow","title":"Keep Hierarchies Shallow","text":"<p>Avoid deep inheritance chains:</p> <pre><code>// Good: Shallow hierarchy\nAnimal\n  \u251c\u2500 Dog\n  \u2514\u2500 Cat\n\n// Bad: Deep hierarchy\nVehicle\n  \u2514\u2500 MotorVehicle\n      \u2514\u2500 Car\n          \u2514\u2500 Sedan\n              \u2514\u2500 LuxurySedan\n</code></pre>"},{"location":"guide/inheritance/#override-consistently","title":"Override Consistently","text":"<p>When overriding methods, maintain the parent's contract:</p> <pre><code>class Parent {\n  public:\n    def process(value :Int) :Int {\n      if value &lt; 0 {\n        return 0\n      }\n      value * 2\n    }\n}\n\nclass Child : Parent {\n  public:\n    def process(value :Int) :Int {\n      // Maintain parent's behavior\n      if value &lt; 0 {\n        return 0\n      }\n      value * 3  // Different implementation, same contract\n    }\n}\n</code></pre>"},{"location":"guide/inheritance/#next-steps","title":"Next Steps","text":"<ul> <li>Java Interoperability - Working with Java classes</li> <li>Lambda Expressions - Functional programming</li> <li>Examples - Object-oriented examples</li> </ul>"},{"location":"guide/java-interop/","title":"Java Interoperability","text":"<p>One of Onion's key strengths is seamless interoperability with Java. You can use any Java library directly in your Onion code.</p>"},{"location":"guide/java-interop/#importing-java-classes","title":"Importing Java Classes","text":""},{"location":"guide/java-interop/#import-statement","title":"Import Statement","text":"<p>Use the <code>import</code> statement to import Java classes:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.HashMap;\n  java.io.File;\n}\n\ndef list :ArrayList = new ArrayList\ndef map :HashMap = new HashMap\ndef file :File = new File(\"data.txt\")\n</code></pre>"},{"location":"guide/java-interop/#multiple-imports","title":"Multiple Imports","text":"<p>Group related imports together:</p> <pre><code>import {\n  java.io.File;\n  java.io.FileReader;\n  java.io.BufferedReader;\n  java.io.IOException;\n}\n</code></pre>"},{"location":"guide/java-interop/#fully-qualified-names","title":"Fully Qualified Names","text":"<p>You can use fully qualified names without importing:</p> <pre><code>def list :java.util.ArrayList = new java.util.ArrayList\ndef file :java.io.File = new java.io.File(\"data.txt\")\n</code></pre>"},{"location":"guide/java-interop/#creating-java-objects","title":"Creating Java Objects","text":""},{"location":"guide/java-interop/#constructor-calls","title":"Constructor Calls","text":"<p>Create Java objects with the <code>new</code> keyword:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.Date;\n  java.lang.StringBuilder;\n}\n\ndef list :ArrayList = new ArrayList\ndef date :Date = new Date\ndef builder :StringBuilder = new StringBuilder(\"Hello\")\n</code></pre>"},{"location":"guide/java-interop/#constructor-with-parameters","title":"Constructor with Parameters","text":"<pre><code>import {\n  java.io.File;\n  java.awt.Dimension;\n}\n\ndef file :File = new File(\"/path/to/file.txt\")\ndef size :Dimension = new Dimension(800, 600)\n</code></pre>"},{"location":"guide/java-interop/#calling-java-methods","title":"Calling Java Methods","text":""},{"location":"guide/java-interop/#instance-methods","title":"Instance Methods","text":"<p>Call methods on Java objects normally:</p> <pre><code>import { java.util.ArrayList; }\n\ndef list :ArrayList = new ArrayList\nlist.add(\"First\")\nlist.add(\"Second\")\nlist.add(\"Third\")\n\ndef size :Int = list.size()  // 3\ndef item :Object = list.get(0)  // \"First\"\ndef exists :Boolean = list.contains(\"Second\")  // true\n</code></pre>"},{"location":"guide/java-interop/#static-methods","title":"Static Methods","text":"<p>Use <code>::</code> to call static methods:</p> <pre><code>// Math class\ndef random :Double = Math::random()\ndef sqrt :Double = Math::sqrt(16.0)\ndef max :Int = Math::max(10, 20)\n\n// System class\ndef time :Long = System::currentTimeMillis()\ndef property :String = System::getProperty(\"os.name\")\n\n// Integer parsing\ndef number :Int = JInteger::parseInt(\"42\")\n</code></pre>"},{"location":"guide/java-interop/#method-chaining","title":"Method Chaining","text":"<pre><code>import { java.lang.StringBuilder; }\n\ndef result :String = new StringBuilder(\"Hello\")\n  .append(\" \")\n  .append(\"World\")\n  .append(\"!\")\n  .toString()\n\nIO::println(result)  // \"Hello World!\"\n</code></pre>"},{"location":"guide/java-interop/#working-with-java-collections","title":"Working with Java Collections","text":""},{"location":"guide/java-interop/#arraylist","title":"ArrayList","text":"<pre><code>import { java.util.ArrayList; }\n\ndef list :ArrayList = new ArrayList\nlist &lt;&lt; \"Apple\"     // &lt;&lt; operator for add()\nlist &lt;&lt; \"Banana\"\nlist &lt;&lt; \"Cherry\"\n\nforeach fruit :Object in list {\n  IO::println(fruit$String)\n}\n\ndef first :String = list.get(0)$String\ndef size :Int = list.size()\n</code></pre>"},{"location":"guide/java-interop/#hashmap","title":"HashMap","text":"<pre><code>import { java.util.HashMap; }\n\ndef map :HashMap = new HashMap\nmap.put(\"name\", \"Alice\")\nmap.put(\"age\", 30)\nmap.put(\"city\", \"Tokyo\")\n\ndef name :String = map.get(\"name\")$String\ndef age :Int = map.get(\"age\")$Int\n\ndef hasKey :Boolean = map.containsKey(\"name\")\n</code></pre>"},{"location":"guide/java-interop/#hashset","title":"HashSet","text":"<pre><code>import { java.util.HashSet; }\n\ndef set :HashSet = new HashSet\nset.add(\"red\")\nset.add(\"green\")\nset.add(\"blue\")\nset.add(\"red\")  // Duplicate, won't be added\n\nIO::println(set.size())  // 3\n</code></pre>"},{"location":"guide/java-interop/#implementing-java-interfaces","title":"Implementing Java Interfaces","text":""},{"location":"guide/java-interop/#actionlistener-example","title":"ActionListener Example","text":"<pre><code>import {\n  java.awt.event.ActionListener;\n  java.awt.event.ActionEvent;\n  javax.swing.JButton;\n}\n\nclass MyButtonHandler &lt;: ActionListener {\n  public:\n    def actionPerformed(event :ActionEvent) {\n      IO::println(\"Button clicked!\")\n      def source :JButton = event.getSource()$JButton\n      IO::println(\"Button text: \" + source.getText())\n    }\n}\n\ndef button :JButton = new JButton(\"Click me\")\ndef handler :MyButtonHandler = new MyButtonHandler\nbutton.addActionListener(handler)\n</code></pre>"},{"location":"guide/java-interop/#runnable-example","title":"Runnable Example","text":"<pre><code>import { java.lang.Runnable; }\n\nclass MyTask &lt;: Runnable {\n  @name :String\n\n  public:\n    def new(n :String) {\n      @name = n\n    }\n\n    def run {\n      IO::println(\"Task \" + @name + \" is running\")\n    }\n}\n\ndef task :MyTask = new MyTask(\"Background Task\")\ndef thread :Thread = new Thread(task)\nthread.start()\n</code></pre>"},{"location":"guide/java-interop/#comparable-example","title":"Comparable Example","text":"<pre><code>import { java.lang.Comparable; }\n\nclass Person &lt;: Comparable {\n  @name :String\n  @age :Int\n\n  public:\n    def new(n :String, a :Int) {\n      @name = n\n      @age = a\n    }\n\n    def compareTo(other :Object) :Int {\n      def otherPerson :Person = other$Person\n      @age - otherPerson.@age\n    }\n}\n</code></pre>"},{"location":"guide/java-interop/#extending-java-classes","title":"Extending Java Classes","text":""},{"location":"guide/java-interop/#jframe-example","title":"JFrame Example","text":"<pre><code>import {\n  javax.swing.JFrame;\n  javax.swing.JButton;\n  java.awt.FlowLayout;\n}\n\nclass MyWindow : JFrame {\n  public:\n    def new {\n      setTitle(\"My Window\")\n      setSize(400, 300)\n      setLayout(new FlowLayout())\n\n      def button :JButton = new JButton(\"Click me\")\n      add(button)\n\n      setDefaultCloseOperation(JFrame::EXIT_ON_CLOSE)\n      setVisible(true)\n    }\n}\n\ndef window :MyWindow = new MyWindow\n</code></pre>"},{"location":"guide/java-interop/#java-io","title":"Java I/O","text":""},{"location":"guide/java-interop/#file-reading","title":"File Reading","text":"<pre><code>import {\n  java.io.File;\n  java.io.FileReader;\n  java.io.BufferedReader;\n  java.io.IOException;\n}\n\ndef readFile(filename :String) {\n  try {\n    def reader :BufferedReader = new BufferedReader(\n      new FileReader(filename)\n    )\n\n    def line :String = null\n    while (line = reader.readLine()) != null {\n      IO::println(line)\n    }\n\n    reader.close()\n  } catch e :IOException {\n    IO::println(\"Error reading file: \" + e.getMessage())\n  }\n}\n\nreadFile(\"data.txt\")\n</code></pre>"},{"location":"guide/java-interop/#file-writing","title":"File Writing","text":"<pre><code>import {\n  java.io.FileWriter;\n  java.io.BufferedWriter;\n  java.io.IOException;\n}\n\ndef writeFile(filename :String, content :String) {\n  try {\n    def writer :BufferedWriter = new BufferedWriter(\n      new FileWriter(filename)\n    )\n\n    writer.write(content)\n    writer.newLine()\n    writer.close()\n\n    IO::println(\"File written successfully\")\n  } catch e :IOException {\n    IO::println(\"Error writing file: \" + e.getMessage())\n  }\n}\n\nwriteFile(\"output.txt\", \"Hello, World!\")\n</code></pre>"},{"location":"guide/java-interop/#java-swing-gui","title":"Java Swing GUI","text":""},{"location":"guide/java-interop/#complete-gui-application","title":"Complete GUI Application","text":"<pre><code>import {\n  javax.swing.JFrame;\n  javax.swing.JButton;\n  javax.swing.JTextField;\n  javax.swing.JPanel;\n  java.awt.BorderLayout;\n  java.awt.event.ActionListener;\n  java.awt.event.ActionEvent;\n}\n\nclass CalculatorApp : JFrame &lt;: ActionListener {\n  @textField :JTextField\n  @currentValue :Double\n\n  public:\n    def new {\n      setTitle(\"Simple Calculator\")\n      setSize(300, 200)\n      setLayout(new BorderLayout())\n\n      @textField = new JTextField()\n      add(@textField, BorderLayout::NORTH)\n\n      def panel :JPanel = new JPanel()\n      def button :JButton = new JButton(\"Calculate\")\n      button.addActionListener(self)\n      panel.add(button)\n\n      add(panel, BorderLayout::CENTER)\n\n      setDefaultCloseOperation(JFrame::EXIT_ON_CLOSE)\n      setVisible(true)\n    }\n\n    def actionPerformed(event :ActionEvent) {\n      def text :String = @textField.getText()\n      IO::println(\"Calculating: \" + text)\n    }\n}\n\ndef app :CalculatorApp = new CalculatorApp\n</code></pre>"},{"location":"guide/java-interop/#type-casting","title":"Type Casting","text":""},{"location":"guide/java-interop/#casting-objects","title":"Casting Objects","text":"<p>Use the <code>$</code> operator to cast Java objects:</p> <pre><code>def obj :Object = \"Hello\"\ndef str :String = obj$String\n\ndef list :ArrayList = new ArrayList\nlist.add(\"Item\")\ndef item :String = list.get(0)$String\n</code></pre>"},{"location":"guide/java-interop/#numeric-casting","title":"Numeric Casting","text":"<pre><code>def random :Double = Math::random()\ndef randomInt :Int = (random * 100)$Int\n\ndef longValue :Long = 123456789L\ndef intValue :Int = longValue$Int\n</code></pre>"},{"location":"guide/java-interop/#common-java-classes","title":"Common Java Classes","text":""},{"location":"guide/java-interop/#string-operations","title":"String Operations","text":"<pre><code>def text :String = \"Hello, World!\"\ndef upper :String = text.toUpperCase()\ndef lower :String = text.toLowerCase()\ndef length :Int = text.length()\ndef sub :String = text.substring(0, 5)\ndef contains :Boolean = text.contains(\"World\")\n</code></pre>"},{"location":"guide/java-interop/#integer-and-long","title":"Integer and Long","text":"<pre><code>// Parsing\ndef i :Int = JInteger::parseInt(\"42\")\ndef l :Long = JLong::parseLong(\"1234567890\")\n\n// Conversion\ndef iStr :String = JInteger::toString(42)\ndef lStr :String = JLong::toString(1234567890L)\n\n// Min/Max\ndef max :Int = JInteger::MAX_VALUE\ndef min :Int = JInteger::MIN_VALUE\n</code></pre>"},{"location":"guide/java-interop/#math-operations","title":"Math Operations","text":"<pre><code>def abs :Int = Math::abs(-10)        // 10\ndef ceil :Double = Math::ceil(3.14)   // 4.0\ndef floor :Double = Math::floor(3.14) // 3.0\ndef round :Long = Math::round(3.14)   // 3\ndef pow :Double = Math::pow(2.0, 3.0) // 8.0\n</code></pre>"},{"location":"guide/java-interop/#next-steps","title":"Next Steps","text":"<ul> <li>Classes and Objects - OOP in Onion</li> <li>Inheritance - Extending Java classes</li> <li>Examples - Real-world examples</li> </ul>"},{"location":"guide/lambda-expressions/","title":"Lambda Expressions","text":"<p>Lambda expressions provide a concise way to create anonymous functions in Onion.</p>"},{"location":"guide/lambda-expressions/#lambda-syntax","title":"Lambda Syntax","text":"<p>Lambdas use the <code>#(parameters) { body }</code> syntax:</p> <pre><code>// Lambda with one parameter\ndef double = #(x :Int) { x * 2 }\n\n// Lambda with multiple parameters\ndef add = #(x :Int, y :Int) { x + y }\n\n// Lambda with no parameters\ndef greet = #() { IO::println(\"Hello!\") }\n</code></pre>"},{"location":"guide/lambda-expressions/#calling-lambdas","title":"Calling Lambdas","text":"<p>Use the <code>.call()</code> method to invoke a lambda:</p> <pre><code>def square = #(x :Int) { x * x }\n\ndef result :Int = square.call(5)$Int  // 25\nIO::println(result)\n</code></pre>"},{"location":"guide/lambda-expressions/#function-types","title":"Function Types","text":"<p>Lambdas are typed using <code>Function0</code> through <code>Function10</code> interfaces:</p> <pre><code>// Function with 0 parameters\ndef func0 :Function0 = #() { 42 }\ndef value :Int = func0.call()$Int\n\n// Function with 1 parameter\ndef func1 :Function1 = #(x :Int) { x * 2 }\ndef doubled :Int = func1.call(10)$Int\n\n// Function with 2 parameters\ndef func2 :Function2 = #(x :Int, y :Int) { x + y }\ndef sum :Int = func2.call(3, 7)$Int\n</code></pre>"},{"location":"guide/lambda-expressions/#closures","title":"Closures","text":"<p>Lambdas can capture variables from their enclosing scope:</p>"},{"location":"guide/lambda-expressions/#simple-closure","title":"Simple Closure","text":"<pre><code>def multiplier :Int = 10\ndef multiply = #(x :Int) { x * multiplier }\n\nIO::println(multiply.call(5))  // 50\n</code></pre>"},{"location":"guide/lambda-expressions/#mutable-closures","title":"Mutable Closures","text":"<p>Closures can modify captured variables:</p> <pre><code>def count :Int = 0\ndef increment = #() {\n  count = count + 1\n  count\n}\n\nIO::println(increment.call())  // 1\nIO::println(increment.call())  // 2\nIO::println(increment.call())  // 3\n</code></pre>"},{"location":"guide/lambda-expressions/#counter-factory","title":"Counter Factory","text":"<pre><code>def makeCounter {\n  def count :Int = 0\n  #() {\n    count = count + 1\n    count\n  }\n}\n\ndef counter1 = makeCounter()\ndef counter2 = makeCounter()\n\nIO::println(counter1.call())  // 1\nIO::println(counter1.call())  // 2\nIO::println(counter2.call())  // 1\nIO::println(counter1.call())  // 3\n</code></pre>"},{"location":"guide/lambda-expressions/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Functions that accept lambdas as parameters:</p>"},{"location":"guide/lambda-expressions/#filter-function","title":"Filter Function","text":"<pre><code>def filter(items :String[], predicate :Function1) :String[] {\n  def result :ArrayList = new ArrayList\n\n  foreach item :String in items {\n    def keep :Boolean = predicate.call(item)$Boolean\n    if keep {\n      result &lt;&lt; item\n    }\n  }\n\n  // Convert to array\n  result.toArray(new String[result.size()])\n}\n\ndef lines :String[] = [\n  \"INFO: System started\",\n  \"ERROR: Connection failed\",\n  \"INFO: Processing data\",\n  \"ERROR: Timeout\"\n]\n\ndef isError = #(line :String) {\n  line.startsWith(\"ERROR\")\n}\n\ndef errors :String[] = filter(lines, isError)\nforeach error :String in errors {\n  IO::println(error)\n}\n// Output:\n// ERROR: Connection failed\n// ERROR: Timeout\n</code></pre>"},{"location":"guide/lambda-expressions/#map-function","title":"Map Function","text":"<pre><code>def map(items :String[], transform :Function1) :String[] {\n  def result :ArrayList = new ArrayList\n\n  foreach item :String in items {\n    def transformed :String = transform.call(item)$String\n    result &lt;&lt; transformed\n  }\n\n  result.toArray(new String[result.size()])\n}\n\ndef words :String[] = [\"hello\", \"world\", \"onion\"]\ndef toUpper = #(s :String) { s.toUpperCase() }\n\ndef upper :String[] = map(words, toUpper)\nforeach word :String in upper {\n  IO::println(word)\n}\n// Output:\n// HELLO\n// WORLD\n// ONION\n</code></pre>"},{"location":"guide/lambda-expressions/#reduce-function","title":"Reduce Function","text":"<pre><code>def reduce(items :Int[], operation :Function2, initial :Int) :Int {\n  def accumulator :Int = initial\n\n  foreach item :Int in items {\n    accumulator = operation.call(accumulator, item)$Int\n  }\n\n  accumulator\n}\n\ndef numbers :Int[] = [1, 2, 3, 4, 5]\ndef sum = #(acc :Int, n :Int) { acc + n }\n\ndef total :Int = reduce(numbers, sum, 0)\nIO::println(total)  // 15\n</code></pre>"},{"location":"guide/lambda-expressions/#practical-examples","title":"Practical Examples","text":""},{"location":"guide/lambda-expressions/#line-filtering","title":"Line Filtering","text":"<pre><code>import {\n  java.io.BufferedReader;\n  java.io.FileReader;\n}\n\ndef filterFile(filename :String, predicate :Function1) {\n  def reader :BufferedReader = new BufferedReader(\n    new FileReader(filename)\n  )\n\n  def line :String = null\n  while (line = reader.readLine()) != null {\n    def keep :Boolean = predicate.call(line)$Boolean\n    if keep {\n      IO::println(line)\n    }\n  }\n\n  reader.close()\n}\n\n// Filter lines starting with ERROR\ndef errorFilter = #(line :String) {\n  line.startsWith(\"ERROR\")\n}\n\nfilterFile(\"logfile.txt\", errorFilter)\n</code></pre>"},{"location":"guide/lambda-expressions/#custom-sort-comparator","title":"Custom Sort Comparator","text":"<pre><code>import {\n  java.util.ArrayList;\n  java.util.Collections;\n  java.util.Comparator;\n}\n\nclass LambdaComparator &lt;: Comparator {\n  @compareFunc :Function2\n\n  public:\n    def new(func :Function2) {\n      @compareFunc = func\n    }\n\n    def compare(a :Object, b :Object) :Int {\n      @compareFunc.call(a, b)$Int\n    }\n}\n\ndef list :ArrayList = new ArrayList\nlist &lt;&lt; \"banana\"\nlist &lt;&lt; \"apple\"\nlist &lt;&lt; \"cherry\"\n\ndef alphabetical = #(a :Object, b :Object) {\n  def s1 :String = a$String\n  def s2 :String = b$String\n  s1.compareTo(s2)\n}\n\ndef comparator :LambdaComparator = new LambdaComparator(alphabetical)\nCollections::sort(list, comparator)\n\nforeach item :Object in list {\n  IO::println(item$String)\n}\n// Output:\n// apple\n// banana\n// cherry\n</code></pre>"},{"location":"guide/lambda-expressions/#event-handlers","title":"Event Handlers","text":"<pre><code>import {\n  javax.swing.JButton;\n  java.awt.event.ActionListener;\n  java.awt.event.ActionEvent;\n}\n\nclass LambdaActionListener &lt;: ActionListener {\n  @handler :Function1\n\n  public:\n    def new(h :Function1) {\n      @handler = h\n    }\n\n    def actionPerformed(event :ActionEvent) {\n      @handler.call(event)\n    }\n}\n\ndef button :JButton = new JButton(\"Click me\")\n\ndef onClick = #(event :ActionEvent) {\n  IO::println(\"Button was clicked!\")\n}\n\ndef listener :LambdaActionListener = new LambdaActionListener(onClick)\nbutton.addActionListener(listener)\n</code></pre>"},{"location":"guide/lambda-expressions/#lambda-best-practices","title":"Lambda Best Practices","text":""},{"location":"guide/lambda-expressions/#keep-lambdas-short","title":"Keep Lambdas Short","text":"<pre><code>// Good: Simple, focused lambda\ndef isEven = #(n :Int) { n % 2 == 0 }\n\n// Bad: Complex lambda (use named function instead)\ndef complex = #(n :Int) {\n  def temp :Int = n * 2\n  def result :Int = temp + 10\n  if result &gt; 100 {\n    result / 2\n  } else {\n    result * 3\n  }\n}\n</code></pre>"},{"location":"guide/lambda-expressions/#use-descriptive-variable-names","title":"Use Descriptive Variable Names","text":"<pre><code>// Good\ndef filterErrors = #(logLine :String) {\n  logLine.startsWith(\"ERROR\")\n}\n\n// Bad\ndef f = #(x :String) { x.startsWith(\"ERROR\") }\n</code></pre>"},{"location":"guide/lambda-expressions/#avoid-side-effects-when-possible","title":"Avoid Side Effects When Possible","text":"<pre><code>// Good: Pure function\ndef double = #(x :Int) { x * 2 }\n\n// Less ideal: Side effect\ndef count :Int = 0\ndef incrementCounter = #() {\n  count = count + 1  // Modifies external state\n}\n</code></pre>"},{"location":"guide/lambda-expressions/#next-steps","title":"Next Steps","text":"<ul> <li>Functions - Named functions and methods</li> <li>Classes and Objects - Object-oriented programming</li> <li>Examples - Functional programming examples</li> </ul>"},{"location":"guide/overview/","title":"Language Overview","text":"<p>Onion is a statically-typed, object-oriented programming language designed for the Java Virtual Machine (JVM). This page provides an overview of the language's philosophy, design goals, and key characteristics.</p>"},{"location":"guide/overview/#design-philosophy","title":"Design Philosophy","text":"<p>Onion was created with several goals in mind:</p> <ol> <li>Static Type Safety - Catch errors at compile time while maintaining expressiveness</li> <li>Java Interoperability - Seamless integration with existing Java libraries and frameworks</li> <li>Concise Syntax - Reduce boilerplate while keeping code readable</li> <li>Familiar Concepts - Build on established OOP and functional programming patterns</li> <li>JVM Performance - Leverage the mature JVM ecosystem and runtime optimizations</li> </ol>"},{"location":"guide/overview/#language-characteristics","title":"Language Characteristics","text":""},{"location":"guide/overview/#statically-typed","title":"Statically Typed","text":"<p>Every variable and expression has a type known at compile time:</p> <pre><code>def name :String = \"Alice\"  // Type annotation\ndef age :Int = 30\ndef scores :Int[] = new Int[10]\n</code></pre> <p>The type system includes: - Primitive types: <code>Int</code>, <code>Long</code>, <code>Double</code>, <code>Float</code>, <code>Boolean</code>, <code>Byte</code>, <code>Short</code>, <code>Char</code> - Reference types: Classes and interfaces - Array types: <code>Type[]</code> - Null type: Special handling for <code>null</code> values</p>"},{"location":"guide/overview/#object-oriented","title":"Object-Oriented","text":"<p>Onion fully supports object-oriented programming:</p> <pre><code>class Animal {\n  @name :String\n\n  public:\n    def new(n :String) {\n      @name = n\n    }\n\n    def speak :String {\n      \"Some sound\"\n    }\n}\n\nclass Dog : Animal {\n  public:\n    def new(n :String) {\n      // Call parent constructor\n      super.new(n)\n    }\n\n    def speak :String {\n      \"Woof!\"\n    }\n}\n</code></pre> <p>Features: - Classes - Encapsulation of data and behavior - Inheritance - Single class inheritance, multiple interface implementation - Polymorphism - Method overriding and overloading - Access Control - Public/private visibility - Interfaces - Abstract contracts</p>"},{"location":"guide/overview/#functional-elements","title":"Functional Elements","text":"<p>While primarily object-oriented, Onion includes functional programming features:</p> <pre><code>// Lambda expressions\ndef filter = #(x :Int) { x &gt; 10 }\n\n// Closures\ndef makeCounter {\n  def count :Int = 0\n  #() { count = count + 1; count }\n}\n\ndef counter = makeCounter()\nIO::println(counter.call())  // 1\nIO::println(counter.call())  // 2\n</code></pre> <p>Features: - Lambda expressions - Anonymous functions with <code>#(params) { body }</code> syntax - Closures - Functions that capture variables from their enclosing scope - First-class functions - Functions as values via <code>Function0</code> through <code>Function10</code> interfaces</p>"},{"location":"guide/overview/#jvm-target","title":"JVM Target","text":"<p>Onion compiles directly to JVM bytecode:</p> <ul> <li>Compiled <code>.class</code> files are standard JVM classes</li> <li>Can be packaged in JARs alongside Java classes</li> <li>Inherits JVM's performance characteristics</li> <li>Access to the entire Java ecosystem</li> </ul>"},{"location":"guide/overview/#java-interoperability","title":"Java Interoperability","text":"<p>Direct, seamless access to Java:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.HashMap;\n  javax.swing.JFrame;\n}\n\ndef list :ArrayList = new ArrayList\ndef map :HashMap = new HashMap\ndef window :JFrame = new JFrame(\"Title\")\n</code></pre> <p>Key points: - Import Java classes with <code>import { }</code> - Instantiate Java objects with <code>new</code> - Call Java methods normally - Implement Java interfaces - Extend Java classes - Use <code>::</code> for static method access</p>"},{"location":"guide/overview/#compilation-model","title":"Compilation Model","text":"<p>The Onion compiler follows a multi-phase architecture:</p> <pre><code>Source Code (.on)\n    \u2193\n[Parsing] - JavaCC grammar \u2192 Untyped AST\n    \u2193\n[Rewriting] - Normalization \u2192 Transformed AST\n    \u2193\n[Type Checking] - Type inference &amp; validation \u2192 Typed AST\n    \u2193\n[Code Generation] - ASM bytecode generation \u2192 .class files\n</code></pre>"},{"location":"guide/overview/#compilation-modes","title":"Compilation Modes","text":"<ol> <li>File Compilation (<code>onionc</code>) - Produces <code>.class</code> files</li> <li>Script Execution (<code>onion</code>) - Compiles to memory and runs immediately</li> <li>Interactive REPL (<code>Shell</code>) - Evaluate expressions interactively</li> </ol>"},{"location":"guide/overview/#syntax-highlights","title":"Syntax Highlights","text":""},{"location":"guide/overview/#member-variables-with","title":"Member Variables with <code>@</code>","text":"<p>Instance variables are prefixed with <code>@</code>:</p> <pre><code>class Counter {\n  @count :Int\n\n  public:\n    def increment {\n      @count = @count + 1\n    }\n}\n</code></pre>"},{"location":"guide/overview/#type-annotations-with","title":"Type Annotations with <code>:</code>","text":"<p>Types are specified after a colon:</p> <pre><code>def variable :Type = value\ndef method(param :Type) :ReturnType { }\n</code></pre>"},{"location":"guide/overview/#static-access-with","title":"Static Access with <code>::</code>","text":"<p>Static methods and fields use <code>::</code>:</p> <pre><code>IO::println(\"Hello\")\nMath::random()\nSystem::out.println(\"Java style\")\n</code></pre>"},{"location":"guide/overview/#type-casting-with","title":"Type Casting with <code>$</code>","text":"<p>Cast expressions use the <code>$</code> operator:</p> <pre><code>def x :Double = 3.14\ndef y :Int = x$Int  // Cast to Int\n\ndef obj :Object = \"string\"\ndef str :String = obj$String  // Cast to String\n</code></pre>"},{"location":"guide/overview/#pattern-matching-with-select","title":"Pattern Matching with <code>select</code>","text":"<p>Switch-style pattern matching:</p> <pre><code>select value {\n  case 1, 2, 3:\n    IO::println(\"Small\")\n  case 4, 5, 6:\n    IO::println(\"Medium\")\n  else:\n    IO::println(\"Large\")\n}\n</code></pre>"},{"location":"guide/overview/#whats-different-from-java","title":"What's Different from Java?","text":"Feature Java Onion Instance variables <code>this.field</code> <code>@field</code> Type annotations <code>Type variable</code> <code>variable :Type</code> Static access <code>Class.method()</code> <code>Class::method()</code> Type casting <code>(Type) value</code> <code>value$Type</code> Lambda syntax <code>(x) -&gt; x + 1</code> <code>#(x) { x + 1 }</code> Pattern matching <code>switch</code> (Java 14+) <code>select</code> List append <code>list.add(x)</code> <code>list &lt;&lt; x</code>"},{"location":"guide/overview/#current-limitations","title":"Current Limitations","text":"<p>As documented in the README:</p> <ol> <li>Incomplete validation - Some compile-time checks (abstract method implementation, final method overriding) are not fully implemented</li> <li>Edge cases - The compiler may crash on certain code patterns</li> <li>Partial features - Some features like <code>finally</code> clauses are not yet supported</li> </ol> <p>The examples in the <code>run/</code> directory are verified to compile and execute correctly.</p>"},{"location":"guide/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Syntax - Learn the fundamentals</li> <li>Classes and Objects - Object-oriented programming</li> <li>Java Interoperability - Working with Java libraries</li> </ul>"},{"location":"guide/variables-and-types/","title":"Variables and Types","text":"<p>Onion is a statically-typed language, meaning every variable has a type determined at compile time.</p>"},{"location":"guide/variables-and-types/#type-annotations","title":"Type Annotations","text":"<p>Variables require explicit type annotations:</p> <pre><code>def name :String = \"Alice\"\ndef age :Int = 30\ndef height :Double = 5.8\n</code></pre>"},{"location":"guide/variables-and-types/#type-system","title":"Type System","text":""},{"location":"guide/variables-and-types/#primitive-types","title":"Primitive Types","text":"<p>Onion supports all JVM primitive types:</p> <pre><code>def byteVal :Byte = 127\ndef shortVal :Short = 32767\ndef intVal :Int = 2147483647\ndef longVal :Long = 9223372036854775807L\ndef floatVal :Float = 3.14f\ndef doubleVal :Double = 3.14159\ndef charVal :Char = 'A'\ndef boolVal :Boolean = true\n</code></pre>"},{"location":"guide/variables-and-types/#reference-types","title":"Reference Types","text":""},{"location":"guide/variables-and-types/#string-type","title":"String Type","text":"<pre><code>def message :String = \"Hello, World!\"\ndef empty :String = \"\"\ndef multiline :String = \"Line 1\\nLine 2\"\n</code></pre>"},{"location":"guide/variables-and-types/#class-types","title":"Class Types","text":"<p>Any Java or Onion class can be used as a type:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.io.File;\n}\n\ndef list :ArrayList = new ArrayList\ndef file :File = new File(\"data.txt\")\n</code></pre>"},{"location":"guide/variables-and-types/#interface-types","title":"Interface Types","text":"<pre><code>import {\n  java.util.List;\n  java.util.ArrayList;\n}\n\ndef list :List = new ArrayList  // Interface type\n</code></pre>"},{"location":"guide/variables-and-types/#array-types","title":"Array Types","text":"<p>Arrays are declared with <code>Type[]</code> syntax:</p> <pre><code>def integers :Int[] = new Int[10]\ndef strings :String[] = [\"a\", \"b\", \"c\"]\ndef objects :Object[] = new Object[5]\n</code></pre>"},{"location":"guide/variables-and-types/#null-type","title":"Null Type","text":"<p>The <code>null</code> literal has a special null type:</p> <pre><code>def maybeString :String = null\ndef maybeObject :Object = null\n</code></pre>"},{"location":"guide/variables-and-types/#type-casting","title":"Type Casting","text":""},{"location":"guide/variables-and-types/#using-the-operator","title":"Using the <code>$</code> Operator","text":"<p>Convert between types using the <code>$</code> casting operator:</p> <pre><code>// Numeric casting\ndef x :Double = 3.14\ndef y :Int = x$Int  // 3\n\n// Object casting\ndef obj :Object = \"Hello\"\ndef str :String = obj$String\n\n// Random number to Int\ndef random :Int = (Math::random() * 100)$Int\n</code></pre>"},{"location":"guide/variables-and-types/#automatic-widening","title":"Automatic Widening","text":"<p>Smaller numeric types automatically widen to larger ones:</p> <pre><code>def i :Int = 42\ndef l :Long = i  // Int \u2192 Long (automatic)\ndef d :Double = l  // Long \u2192 Double (automatic)\n</code></pre>"},{"location":"guide/variables-and-types/#explicit-narrowing","title":"Explicit Narrowing","text":"<p>Narrowing conversions require explicit casting:</p> <pre><code>def d :Double = 3.14\ndef i :Int = d$Int  // Must use $ operator\n</code></pre>"},{"location":"guide/variables-and-types/#type-compatibility","title":"Type Compatibility","text":""},{"location":"guide/variables-and-types/#assignment-compatibility","title":"Assignment Compatibility","text":"<p>A value can be assigned to a variable if:</p> <ol> <li>Types are exactly the same</li> <li>Value type is a subtype of variable type</li> <li>Automatic widening applies (for primitives)</li> </ol> <pre><code>// Same type\ndef s1 :String = \"Hello\"\ndef s2 :String = s1  // OK\n\n// Subtype\nimport { java.util.ArrayList; java.util.List; }\ndef arrayList :ArrayList = new ArrayList\ndef list :List = arrayList  // OK (ArrayList implements List)\n\n// Widening\ndef i :Int = 42\ndef l :Long = i  // OK (Int \u2192 Long)\n</code></pre>"},{"location":"guide/variables-and-types/#variable-scope","title":"Variable Scope","text":""},{"location":"guide/variables-and-types/#local-variables","title":"Local Variables","text":"<p>Variables declared in methods or blocks:</p> <pre><code>def method {\n  def local :Int = 10\n  if true {\n    def nested :Int = 20\n    IO::println(local)   // OK\n    IO::println(nested)  // OK\n  }\n  // IO::println(nested)  // ERROR: nested not in scope\n}\n</code></pre>"},{"location":"guide/variables-and-types/#member-variables","title":"Member Variables","text":"<p>Instance variables prefixed with <code>@</code>:</p> <pre><code>class Counter {\n  @count :Int\n\n  public:\n    def new {\n      @count = 0  // Initialize member\n    }\n\n    def increment {\n      @count = @count + 1  // Access member\n    }\n\n    def getCount :Int {\n      @count  // Return member value\n    }\n}\n</code></pre>"},{"location":"guide/variables-and-types/#static-variables","title":"Static Variables","text":"<p>Static members belong to the class, not instances:</p> <pre><code>class MathUtils {\n  static @PI :Double = 3.14159\n\n  public:\n    static def square(x :Double) :Double {\n      x * x\n    }\n}\n\n// Access static members\ndef pi :Double = MathUtils::PI\ndef result :Double = MathUtils::square(5.0)\n</code></pre>"},{"location":"guide/variables-and-types/#type-inference-future-feature","title":"Type Inference (Future Feature)","text":"<p>Currently, Onion requires explicit type annotations. Future versions may support type inference:</p> <pre><code>// Current (required)\ndef name :String = \"Alice\"\n\n// Future (planned)\ndef name = \"Alice\"  // Inferred as String\n</code></pre>"},{"location":"guide/variables-and-types/#generic-types-java-generics","title":"Generic Types (Java Generics)","text":"<p>When using Java generic types, specify type parameters:</p> <pre><code>import {\n  java.util.ArrayList;\n  java.util.HashMap;\n}\n\n// Note: Current Onion may not enforce type parameters\ndef list :ArrayList = new ArrayList  // Can hold any Object\n\n// In Java: ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\n// Onion: def list :ArrayList = new ArrayList\n</code></pre>"},{"location":"guide/variables-and-types/#function-types","title":"Function Types","text":"<p>Functions are represented by <code>Function0</code> through <code>Function10</code> interfaces:</p> <pre><code>def func :Function1 = #(x :Int) { x * 2 }\ndef result :Int = func.call(5)$Int  // 10\n</code></pre> <ul> <li><code>Function0</code> - No parameters</li> <li><code>Function1</code> - One parameter</li> <li><code>Function2</code> - Two parameters</li> <li>... up to <code>Function10</code></li> </ul>"},{"location":"guide/variables-and-types/#next-steps","title":"Next Steps","text":"<ul> <li>Control Flow - if, while, for, select</li> <li>Functions - Function definitions and lambdas</li> <li>Classes and Objects - Object-oriented programming</li> </ul>"},{"location":"reference/compiler-architecture/","title":"Compiler Architecture","text":"<p>The Onion compiler is a multi-phase pipeline compiler that transforms source code into JVM bytecode.</p>"},{"location":"reference/compiler-architecture/#overview","title":"Overview","text":"<pre><code>Source Code (.on files)\n    \u2193\n[1] Parsing (JavaCC) \u2192 Untyped AST\n    \u2193\n[2] Rewriting \u2192 Normalized Untyped AST\n    \u2193\n[3] Type Checking \u2192 Typed AST\n    \u2193\n[4] Code Generation (ASM) \u2192 JVM Bytecode (.class files)\n</code></pre>"},{"location":"reference/compiler-architecture/#implementation","title":"Implementation","text":"<ul> <li>Language: Scala 3.6.2</li> <li>Parser Generator: JavaCC 5.0</li> <li>Bytecode Library: ASM 9.8</li> <li>Build Tool: SBT</li> <li>JVM Target: Java 17+</li> </ul>"},{"location":"reference/compiler-architecture/#phase-1-parsing","title":"Phase 1: Parsing","text":"<p>File: <code>src/main/scala/onion/compiler/Parsing.scala</code></p>"},{"location":"reference/compiler-architecture/#grammar","title":"Grammar","text":"<p>The parser grammar is defined in <code>grammar/JJOnionParser.jj</code> using JavaCC syntax.</p>"},{"location":"reference/compiler-architecture/#process","title":"Process","text":"<ol> <li>JavaCC generates <code>JJOnionParser.java</code> from the grammar</li> <li>Source code is tokenized and parsed</li> <li><code>ASTBuilder</code> constructs an untyped Abstract Syntax Tree</li> <li>Parser errors are collected and reported</li> </ol>"},{"location":"reference/compiler-architecture/#output","title":"Output","text":"<p>Untyped AST defined in <code>src/main/scala/onion/compiler/AST.scala</code>:</p> <ul> <li><code>ClassDef</code> - Class definitions</li> <li><code>MethodDef</code> - Method definitions</li> <li><code>VarDef</code> - Variable declarations</li> <li>Expressions: <code>BinaryOp</code>, <code>MethodCall</code>, <code>Literal</code>, etc.</li> </ul>"},{"location":"reference/compiler-architecture/#phase-2-rewriting","title":"Phase 2: Rewriting","text":"<p>File: <code>src/main/scala/onion/compiler/Rewriting.scala</code></p>"},{"location":"reference/compiler-architecture/#purpose","title":"Purpose","text":"<p>Transform and normalize the untyped AST:</p> <ul> <li>Desugar complex constructs</li> <li>Normalize expressions</li> <li>Prepare for type checking</li> </ul>"},{"location":"reference/compiler-architecture/#examples","title":"Examples","text":"<ul> <li>Convert high-level constructs to simpler forms</li> <li>Expand syntactic sugar</li> <li>Normalize operator precedence</li> </ul>"},{"location":"reference/compiler-architecture/#phase-3-type-checking","title":"Phase 3: Type Checking","text":"<p>File: <code>src/main/scala/onion/compiler/Typing.scala</code> (86KB - largest component)</p>"},{"location":"reference/compiler-architecture/#responsibilities","title":"Responsibilities","text":"<ol> <li>Type Inference: Determine types of expressions</li> <li>Type Validation: Ensure type compatibility</li> <li>Name Resolution: Resolve variable and method names</li> <li>Symbol Tables: Build and maintain symbol information</li> </ol>"},{"location":"reference/compiler-architecture/#supporting-components","title":"Supporting Components","text":"<p>Symbol Tables (<code>src/main/scala/onion/compiler/</code>): - <code>ClassTable.scala</code> - Class symbol table - <code>LocalContext.scala</code> - Local variable environments - <code>Symbol.scala</code> - Symbol definitions</p> <p>Error Reporting: - <code>SemanticError.scala</code> - Type error definitions - <code>SemanticErrorReporter.scala</code> - Error collection</p> <p>Type System: - <code>BasicType</code> - Primitive types (Int, Long, Double, etc.) - <code>ClassType</code> - Reference types - <code>ArrayType</code> - Array types - <code>NullType</code> - Null literal type</p>"},{"location":"reference/compiler-architecture/#process_1","title":"Process","text":"<ol> <li>Build class table from class definitions</li> <li>Process imports and resolve external types</li> <li>Type check method bodies</li> <li>Validate assignments and method calls</li> <li>Infer types where possible</li> <li>Report type errors</li> </ol>"},{"location":"reference/compiler-architecture/#output_1","title":"Output","text":"<p>Typed AST defined in <code>src/main/scala/onion/compiler/TypedAST.scala</code>:</p> <ul> <li>Each node has type information</li> <li>Names are resolved to symbols</li> <li>Ready for code generation</li> </ul>"},{"location":"reference/compiler-architecture/#phase-4-code-generation","title":"Phase 4: Code Generation","text":"<p>File: <code>src/main/scala/onion/compiler/AsmCodeGeneration.scala</code> (42KB)</p>"},{"location":"reference/compiler-architecture/#asm-library","title":"ASM Library","text":"<p>Uses the ASM library for bytecode generation: - Type-safe bytecode emission - Stack frame management - Local variable tracking</p>"},{"location":"reference/compiler-architecture/#supporting-components_1","title":"Supporting Components","text":"<p>Bytecode Utilities (<code>src/main/scala/onion/compiler/bytecode/</code>): - <code>MethodEmitter.scala</code> - JVM method generation - <code>LocalVarContext.scala</code> - Local variable management - <code>AsmUtil.scala</code> - ASM helper functions</p> <p>Visitor Pattern: - <code>AsmCodeGenerationVisitor.scala</code> - AST traversal for code generation</p>"},{"location":"reference/compiler-architecture/#process_2","title":"Process","text":"<ol> <li>Create <code>ClassWriter</code> for each class</li> <li>Generate class metadata (name, superclass, interfaces)</li> <li>Generate fields from member variables</li> <li>Generate methods:</li> <li>Create <code>MethodVisitor</code></li> <li>Emit bytecode instructions</li> <li>Manage local variables and stack</li> <li>Generate constructors</li> <li>Finalize class bytecode</li> </ol>"},{"location":"reference/compiler-architecture/#output_2","title":"Output","text":"<p><code>CompiledClass</code> objects containing: - Class name - JVM bytecode (byte array) - Can be written to <code>.class</code> files or loaded in-memory</p>"},{"location":"reference/compiler-architecture/#compiler-orchestration","title":"Compiler Orchestration","text":"<p>File: <code>src/main/scala/onion/compiler/OnionCompiler.scala</code></p>"},{"location":"reference/compiler-architecture/#processor-pipeline","title":"Processor Pipeline","text":"<p>All phases implement <code>Processor[A, B]</code> trait:</p> <pre><code>trait Processor[A, B] {\n  def process(input: A): B\n\n  def andThen[C](next: Processor[B, C]): Processor[A, C]\n}\n</code></pre>"},{"location":"reference/compiler-architecture/#composition","title":"Composition","text":"<p>Phases are composed using <code>andThen</code>:</p> <pre><code>val compiler =\n  Parsing\n    .andThen(Rewriting)\n    .andThen(Typing)\n    .andThen(AsmCodeGeneration)\n</code></pre>"},{"location":"reference/compiler-architecture/#compilation-result","title":"Compilation Result","text":"<p>Returns <code>CompilationOutcome</code>: - <code>Success(classes: Seq[CompiledClass])</code> - Compilation succeeded - <code>Failure(errors: Seq[CompileError])</code> - Compilation failed</p>"},{"location":"reference/compiler-architecture/#entry-points","title":"Entry Points","text":""},{"location":"reference/compiler-architecture/#compilerfrontend","title":"CompilerFrontend","text":"<p>File: <code>src/main/scala/onion/tools/CompilerFrontend.scala</code></p> <p>Command-line interface for <code>onionc</code>: - Parses command-line arguments - Invokes compiler - Writes <code>.class</code> files to disk</p>"},{"location":"reference/compiler-architecture/#scriptrunner","title":"ScriptRunner","text":"<p>File: <code>src/main/scala/onion/tools/ScriptRunner.scala</code></p> <p>Command-line interface for <code>onion</code>: - Compiles source files to memory - Loads classes with custom classloader - Executes main method or top-level code</p>"},{"location":"reference/compiler-architecture/#shell","title":"Shell","text":"<p>File: <code>src/main/scala/onion/tools/Shell.scala</code></p> <p>Interactive REPL: - Reads expressions - Compiles incrementally - Evaluates and prints results</p>"},{"location":"reference/compiler-architecture/#class-loading","title":"Class Loading","text":"<p>File: <code>src/main/scala/onion/compiler/OnionClassLoader.scala</code></p> <p>Custom classloader for in-memory compilation: - Accepts bytecode directly - Defines classes at runtime - Supports script execution</p>"},{"location":"reference/compiler-architecture/#error-handling","title":"Error Handling","text":""},{"location":"reference/compiler-architecture/#compilation-errors","title":"Compilation Errors","text":"<p>Types: - <code>ParseError</code> - Syntax errors - <code>SemanticError</code> - Type errors - <code>CompileError</code> - General compilation errors</p> <p>Reporting: - <code>CompilationReporter</code> - Formats and displays errors - Includes source location (file, line, column) - Shows context around error</p>"},{"location":"reference/compiler-architecture/#example-error","title":"Example Error","text":"<pre><code>Error: Type mismatch\n  Expected: Int\n  Found: String\n  at MyProgram.on:15\n    def x :Int = \"hello\"\n                 ^^^^^^^\n</code></pre>"},{"location":"reference/compiler-architecture/#utilities","title":"Utilities","text":""},{"location":"reference/compiler-architecture/#toolbox","title":"Toolbox","text":"<p>Location: <code>src/main/scala/onion/compiler/toolbox/</code></p> <p>Helper utilities: - <code>Classes.scala</code> - Class manipulation - <code>Paths.scala</code> - Path handling - <code>SymbolGenerator.scala</code> - Unique symbol generation - <code>MethodInvoker.scala</code> - Reflection-based invocation - <code>Boxing.scala</code> - Primitive/object boxing</p>"},{"location":"reference/compiler-architecture/#environment","title":"Environment","text":"<p>Location: <code>src/main/scala/onion/compiler/environment/</code></p> <p>Type resolution: - <code>ClassFileTable.scala</code> - Caches loaded classes - <code>AsmRefs.scala</code> - ASM type references - <code>ReflectionRefs.scala</code> - Reflection-based types</p>"},{"location":"reference/compiler-architecture/#build-process","title":"Build Process","text":""},{"location":"reference/compiler-architecture/#sbt-configuration","title":"SBT Configuration","text":"<p>File: <code>build.sbt</code></p> <ul> <li>Version: 0.2.0-SNAPSHOT</li> <li>Scala version: 3.6.2</li> <li>Main class: <code>onion.tools.CompilerFrontend</code></li> </ul>"},{"location":"reference/compiler-architecture/#parser-generation","title":"Parser Generation","text":"<p>Automatically regenerates parser when grammar changes:</p> <pre><code>sourceGenerators in Compile += Def.task {\n  val grammar = file(\"grammar/JJOnionParser.jj\")\n  val parser = sourceManaged.value / \"java\" / \"onion\" / \"compiler\" / \"parser\" / \"JJOnionParser.java\"\n\n  if (grammar.lastModified() &gt; parser.lastModified()) {\n    javacc(classpath.value, sourceManaged.value / \"java\", streams.value.log)\n  }\n}\n</code></pre>"},{"location":"reference/compiler-architecture/#assembly","title":"Assembly","text":"<p>Creates standalone JAR:</p> <pre><code>sbt assembly\n# Creates onion.jar\n</code></pre>"},{"location":"reference/compiler-architecture/#distribution","title":"Distribution","text":"<p>Creates distribution ZIP:</p> <pre><code>sbt dist\n# Creates target/onion-dist.zip with:\n#   - onion.jar\n#   - lib/ (dependencies)\n#   - bin/ (scripts)\n#   - run/ (examples)\n</code></pre>"},{"location":"reference/compiler-architecture/#testing","title":"Testing","text":"<p>Framework: ScalaTest 3.2.19</p> <p>Location: <code>src/test/scala/onion/compiler/tools/</code></p> <p>Base Class: <code>AbstractShellSpec</code> - Runs Onion code - Captures output - Verifies results</p> <p>Example Tests: - <code>HelloWorldSpec</code> - Basic output - <code>FactorialSpec</code> - Recursion - <code>StringInterpolationSpec</code> - String features</p>"},{"location":"reference/compiler-architecture/#development-workflow","title":"Development Workflow","text":"<ol> <li>Modify Grammar: Edit <code>grammar/JJOnionParser.jj</code></li> <li>Compile: Run <code>sbt compile</code> (regenerates parser)</li> <li>Test: Run <code>sbt test</code></li> <li>Iterate: Repeat</li> </ol>"},{"location":"reference/compiler-architecture/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Parsing: O(n) where n = source size</li> <li>Type Checking: O(n \u00d7 m) where n = nodes, m = symbols</li> <li>Code Generation: O(n) where n = typed AST nodes</li> </ul>"},{"location":"reference/compiler-architecture/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements: - Incremental compilation - Better error messages - Type inference improvements - Optimization passes - Debugging support</p>"},{"location":"reference/compiler-architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Language Specification - Language details</li> <li>Building from Source - Developer guide</li> <li>Contributing - How to contribute</li> </ul>"},{"location":"reference/specification/","title":"Language Specification","text":"<p>Formal specification of the Onion programming language.</p>"},{"location":"reference/specification/#lexical-structure","title":"Lexical Structure","text":""},{"location":"reference/specification/#keywords","title":"Keywords","text":"<p>Reserved words in Onion:</p> <pre><code>break       case        catch       class       continue\ndef         else        false       for         foreach\nforward     if          import      in          module\nnew         null        public      return      select\nself        static      super       true        try\nwhile\n</code></pre>"},{"location":"reference/specification/#identifiers","title":"Identifiers","text":"<ul> <li>Start with a letter or underscore</li> <li>Followed by letters, digits, or underscores</li> <li>Case-sensitive</li> </ul> <p>Valid identifiers: - <code>name</code>, <code>value</code>, <code>_temp</code>, <code>count123</code>, <code>myVariable</code></p> <p>Invalid identifiers: - <code>123abc</code> (starts with digit) - <code>my-variable</code> (contains hyphen) - <code>class</code> (reserved keyword)</p>"},{"location":"reference/specification/#member-variables","title":"Member Variables","text":"<p>Instance variables are prefixed with <code>@</code>: - <code>@name</code>, <code>@count</code>, <code>@value</code></p>"},{"location":"reference/specification/#literals","title":"Literals","text":"<p>Integer Literals: - Decimal: <code>42</code>, <code>0</code>, <code>123</code> - Hexadecimal: <code>0xFF</code>, <code>0x1A2B</code> - Octal: <code>077</code>, <code>0123</code></p> <p>Long Literals: - <code>42L</code>, <code>1234567890L</code></p> <p>Floating Point: - <code>3.14</code>, <code>0.5</code>, <code>1.23e10</code></p> <p>Float Literals: - <code>3.14f</code>, <code>0.5f</code></p> <p>String Literals: - Double quotes: <code>\"Hello, World!\"</code> - Escape sequences: <code>\\n</code>, <code>\\t</code>, <code>\\\\</code>, <code>\\\"</code></p> <p>Character Literals: - Single quotes: <code>'A'</code>, <code>'1'</code>, <code>'\\n'</code></p> <p>Boolean Literals: - <code>true</code>, <code>false</code></p> <p>Null Literal: - <code>null</code></p>"},{"location":"reference/specification/#type-system","title":"Type System","text":""},{"location":"reference/specification/#primitive-types","title":"Primitive Types","text":"Type Size Range <code>Byte</code> 8-bit -128 to 127 <code>Short</code> 16-bit -32768 to 32767 <code>Int</code> 32-bit -2\u00b3\u00b9 to 2\u00b3\u00b9-1 <code>Long</code> 64-bit -2\u2076\u00b3 to 2\u2076\u00b3-1 <code>Float</code> 32-bit IEEE 754 <code>Double</code> 64-bit IEEE 754 <code>Char</code> 16-bit Unicode character <code>Boolean</code> N/A <code>true</code> or <code>false</code>"},{"location":"reference/specification/#reference-types","title":"Reference Types","text":"<ul> <li>Class types: <code>String</code>, <code>Object</code>, user-defined classes</li> <li>Interface types: Java interfaces</li> <li>Array types: <code>Type[]</code></li> <li>Null type: Type of <code>null</code> literal</li> </ul>"},{"location":"reference/specification/#type-annotations","title":"Type Annotations","text":"<p>Syntax: <code>variable :Type</code></p> <pre><code>def name :String\ndef age :Int\ndef scores :Int[]\n</code></pre>"},{"location":"reference/specification/#declarations","title":"Declarations","text":""},{"location":"reference/specification/#variable-declaration","title":"Variable Declaration","text":"<pre><code>def identifier :Type = expression\n</code></pre>"},{"location":"reference/specification/#function-declaration","title":"Function Declaration","text":"<pre><code>def identifier(param :Type, ...) :ReturnType {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#class-declaration","title":"Class Declaration","text":"<pre><code>class ClassName {\n  members\n}\n\nclass ClassName : ParentClass {\n  members\n}\n\nclass ClassName &lt;: Interface {\n  members\n}\n\nclass ClassName : ParentClass &lt;: Interface1 &lt;: Interface2 {\n  members\n}\n</code></pre>"},{"location":"reference/specification/#member-variables_1","title":"Member Variables","text":"<pre><code>class Example {\n  @memberName :Type\n\n  public:\n    @publicMember :Type\n}\n</code></pre>"},{"location":"reference/specification/#constructors","title":"Constructors","text":"<pre><code>def new(params) {\n  body\n}\n\ndef this:(param) {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#methods","title":"Methods","text":"<pre><code>def methodName(params) :ReturnType {\n  body\n}\n\nstatic def staticMethod(params) :ReturnType {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#statements","title":"Statements","text":""},{"location":"reference/specification/#expression-statement","title":"Expression Statement","text":"<pre><code>expression;\n</code></pre>"},{"location":"reference/specification/#block-statement","title":"Block Statement","text":"<pre><code>{\n  statements\n}\n</code></pre>"},{"location":"reference/specification/#if-statement","title":"If Statement","text":"<pre><code>if condition {\n  body\n} else if condition {\n  body\n} else {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#while-loop","title":"While Loop","text":"<pre><code>while condition {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#for-loop","title":"For Loop","text":"<pre><code>for init; condition; update {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#foreach-loop","title":"Foreach Loop","text":"<pre><code>foreach variable :Type in collection {\n  body\n}\n</code></pre>"},{"location":"reference/specification/#select-statement","title":"Select Statement","text":"<pre><code>select expression {\n  case value1, value2:\n    body\n  case value3:\n    body\n  else:\n    body\n}\n</code></pre>"},{"location":"reference/specification/#try-catch-statement","title":"Try-Catch Statement","text":"<pre><code>try {\n  body\n} catch variable :ExceptionType {\n  handler\n}\n</code></pre>"},{"location":"reference/specification/#return-statement","title":"Return Statement","text":"<pre><code>return\nreturn expression\n</code></pre>"},{"location":"reference/specification/#break-and-continue","title":"Break and Continue","text":"<pre><code>break\ncontinue\n</code></pre>"},{"location":"reference/specification/#expressions","title":"Expressions","text":""},{"location":"reference/specification/#operators","title":"Operators","text":"<p>Precedence (highest to lowest):</p> <ol> <li>Member access: <code>.</code>, <code>::</code></li> <li>Postfix: <code>++</code>, <code>--</code></li> <li>Unary: <code>!</code>, <code>-</code>, <code>+</code></li> <li>Type cast: <code>$</code></li> <li>Multiplicative: <code>*</code>, <code>/</code>, <code>%</code></li> <li>Additive: <code>+</code>, <code>-</code></li> <li>Relational: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Equality: <code>==</code>, <code>!=</code></li> <li>Logical AND: <code>&amp;&amp;</code></li> <li>Logical OR: <code>||</code></li> <li>Assignment: <code>=</code></li> <li>List append: <code>&lt;&lt;</code></li> </ol>"},{"location":"reference/specification/#lambda-expressions","title":"Lambda Expressions","text":"<pre><code>#(param :Type, ...) { body }\n</code></pre>"},{"location":"reference/specification/#type-casting","title":"Type Casting","text":"<pre><code>expression$TargetType\n</code></pre>"},{"location":"reference/specification/#object-creation","title":"Object Creation","text":"<pre><code>new ClassName(args)\nnew Type[size]\n</code></pre>"},{"location":"reference/specification/#method-calls","title":"Method Calls","text":"<pre><code>object.method(args)\nClass::staticMethod(args)\n</code></pre>"},{"location":"reference/specification/#array-access","title":"Array Access","text":"<pre><code>array[index]\n</code></pre>"},{"location":"reference/specification/#import-system","title":"Import System","text":"<pre><code>import {\n  package.ClassName;\n  package.OtherClass;\n}\n</code></pre>"},{"location":"reference/specification/#module-system","title":"Module System","text":"<pre><code>module package.name\n\n// Class definitions\n</code></pre>"},{"location":"reference/specification/#visibility-modifiers","title":"Visibility Modifiers","text":"<ul> <li>Private (default): Members are private unless marked public</li> <li>Public: Declared in <code>public:</code> section</li> </ul> <pre><code>class Example {\n  @privateMember :Int\n\n  public:\n    @publicMember :Int\n\n    def publicMethod {\n      // ...\n    }\n}\n</code></pre>"},{"location":"reference/specification/#delegation","title":"Delegation","text":"<pre><code>class MyClass &lt;: Interface {\n  forward @member :Interface\n\n  @member :Implementation\n}\n</code></pre> <p>The <code>forward</code> directive automatically delegates interface methods to the specified member.</p>"},{"location":"reference/specification/#type-conversions","title":"Type Conversions","text":""},{"location":"reference/specification/#widening-conversions-automatic","title":"Widening Conversions (Automatic)","text":"<ul> <li><code>Byte</code> \u2192 <code>Short</code> \u2192 <code>Int</code> \u2192 <code>Long</code> \u2192 <code>Float</code> \u2192 <code>Double</code></li> <li><code>Char</code> \u2192 <code>Int</code></li> </ul>"},{"location":"reference/specification/#narrowing-conversions-explicit","title":"Narrowing Conversions (Explicit)","text":"<p>Require explicit cast using <code>$</code> operator:</p> <pre><code>def d :Double = 3.14\ndef i :Int = d$Int\n</code></pre>"},{"location":"reference/specification/#current-limitations","title":"Current Limitations","text":"<p>As documented in the README:</p> <ol> <li>Abstract methods: Not fully validated at compile time</li> <li>Final methods: Override checking not complete</li> <li>Finally clause: Not yet supported in try-catch</li> <li>Edge cases: Compiler may crash on certain patterns</li> </ol>"},{"location":"reference/specification/#grammar-reference","title":"Grammar Reference","text":"<p>The complete grammar is defined in <code>grammar/JJOnionParser.jj</code> using JavaCC syntax.</p>"},{"location":"reference/specification/#next-steps","title":"Next Steps","text":"<ul> <li>Standard Library - Built-in functions and classes</li> <li>Compiler Architecture - How the compiler works</li> <li>Examples - Code examples</li> </ul>"},{"location":"reference/stdlib/","title":"Standard Library","text":"<p>Onion's standard library consists of built-in modules and interfaces for common functionality.</p>"},{"location":"reference/stdlib/#io-module","title":"IO Module","text":"<p>Console input and output operations.</p>"},{"location":"reference/stdlib/#ioprintln","title":"IO::println","text":"<p>Print a line to standard output:</p> <pre><code>IO::println(\"Hello, World!\")\nIO::println(\"Value: \" + value)\n</code></pre>"},{"location":"reference/stdlib/#ioprint","title":"IO::print","text":"<p>Print without newline:</p> <pre><code>IO::print(\"Enter name: \")\ndef name :String = IO::input(\"\")\n</code></pre>"},{"location":"reference/stdlib/#ioinput","title":"IO::input","text":"<p>Read a line of input from the user:</p> <pre><code>def name :String = IO::input(\"What's your name? \")\nIO::println(\"Hello, \" + name)\n</code></pre>"},{"location":"reference/stdlib/#system-module","title":"System Module","text":"<p>Access to system-level operations via Java's <code>System</code> class.</p>"},{"location":"reference/stdlib/#systemout","title":"System::out","text":"<p>Standard output stream:</p> <pre><code>System::out.println(\"Direct system output\")\nSystem::out.print(\"No newline\")\n</code></pre>"},{"location":"reference/stdlib/#systemin","title":"System::in","text":"<p>Standard input stream:</p> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.InputStreamReader;\n}\n\ndef reader :BufferedReader = new BufferedReader(\n  new InputStreamReader(System::in)\n)\n</code></pre>"},{"location":"reference/stdlib/#systemcurrenttimemillis","title":"System::currentTimeMillis","text":"<p>Get current time in milliseconds:</p> <pre><code>def time :Long = System::currentTimeMillis()\nIO::println(\"Current time: \" + time)\n</code></pre>"},{"location":"reference/stdlib/#systemgetproperty","title":"System::getProperty","text":"<p>Get system properties:</p> <pre><code>def os :String = System::getProperty(\"os.name\")\ndef user :String = System::getProperty(\"user.name\")\ndef home :String = System::getProperty(\"user.home\")\n</code></pre>"},{"location":"reference/stdlib/#systemexit","title":"System::exit","text":"<p>Exit the program:</p> <pre><code>System::exit(0)  // Success\nSystem::exit(1)  // Error\n</code></pre>"},{"location":"reference/stdlib/#math-module","title":"Math Module","text":"<p>Mathematical operations via Java's <code>Math</code> class.</p>"},{"location":"reference/stdlib/#mathrandom","title":"Math::random","text":"<p>Generate random number between 0.0 and 1.0:</p> <pre><code>def r :Double = Math::random()\ndef randomInt :Int = (Math::random() * 100)$Int\n</code></pre>"},{"location":"reference/stdlib/#mathsqrt","title":"Math::sqrt","text":"<p>Square root:</p> <pre><code>def result :Double = Math::sqrt(16.0)  // 4.0\n</code></pre>"},{"location":"reference/stdlib/#mathpow","title":"Math::pow","text":"<p>Exponentiation:</p> <pre><code>def result :Double = Math::pow(2.0, 3.0)  // 8.0\n</code></pre>"},{"location":"reference/stdlib/#mathabs","title":"Math::abs","text":"<p>Absolute value:</p> <pre><code>def abs1 :Int = Math::abs(-10)     // 10\ndef abs2 :Double = Math::abs(-3.14)  // 3.14\n</code></pre>"},{"location":"reference/stdlib/#mathmax-mathmin","title":"Math::max / Math::min","text":"<p>Maximum and minimum:</p> <pre><code>def max :Int = Math::max(10, 20)    // 20\ndef min :Int = Math::min(10, 20)    // 10\n</code></pre>"},{"location":"reference/stdlib/#mathfloor-mathceil-mathround","title":"Math::floor / Math::ceil / Math::round","text":"<p>Rounding functions:</p> <pre><code>def floor :Double = Math::floor(3.7)  // 3.0\ndef ceil :Double = Math::ceil(3.2)    // 4.0\ndef round :Long = Math::round(3.5)    // 4\n</code></pre>"},{"location":"reference/stdlib/#mathsin-mathcos-mathtan","title":"Math::sin / Math::cos / Math::tan","text":"<p>Trigonometric functions (radians):</p> <pre><code>def sine :Double = Math::sin(Math::PI / 2)    // 1.0\ndef cosine :Double = Math::cos(0.0)           // 1.0\ndef tangent :Double = Math::tan(Math::PI / 4) // 1.0\n</code></pre>"},{"location":"reference/stdlib/#math-constants","title":"Math Constants","text":"<pre><code>def pi :Double = Math::PI       // 3.14159...\ndef e :Double = Math::E         // 2.71828...\n</code></pre>"},{"location":"reference/stdlib/#function-interfaces","title":"Function Interfaces","text":"<p>Built-in function types for lambdas and closures.</p>"},{"location":"reference/stdlib/#function0","title":"Function0","text":"<p>Function with no parameters:</p> <pre><code>def func :Function0 = #() { 42 }\ndef result :Int = func.call()$Int\n</code></pre>"},{"location":"reference/stdlib/#function1","title":"Function1","text":"<p>Function with one parameter:</p> <pre><code>def double :Function1 = #(x :Int) { x * 2 }\ndef result :Int = double.call(5)$Int\n</code></pre>"},{"location":"reference/stdlib/#function2","title":"Function2","text":"<p>Function with two parameters:</p> <pre><code>def add :Function2 = #(x :Int, y :Int) { x + y }\ndef result :Int = add.call(3, 7)$Int\n</code></pre>"},{"location":"reference/stdlib/#function3-through-function10","title":"Function3 through Function10","text":"<p>Functions with 3 to 10 parameters follow the same pattern.</p>"},{"location":"reference/stdlib/#wrapper-classes","title":"Wrapper Classes","text":"<p>Java wrapper classes for primitives (accessed with <code>J</code> prefix in some contexts).</p>"},{"location":"reference/stdlib/#jinteger","title":"JInteger","text":"<p>Integer operations:</p> <pre><code>def i :Int = JInteger::parseInt(\"42\")\ndef s :String = JInteger::toString(42)\ndef max :Int = JInteger::MAX_VALUE\ndef min :Int = JInteger::MIN_VALUE\n</code></pre>"},{"location":"reference/stdlib/#jlong","title":"JLong","text":"<p>Long operations:</p> <pre><code>def l :Long = JLong::parseLong(\"1234567890\")\ndef s :String = JLong::toString(1234567890L)\n</code></pre>"},{"location":"reference/stdlib/#jdouble","title":"JDouble","text":"<p>Double operations:</p> <pre><code>def d :Double = JDouble::parseDouble(\"3.14\")\ndef s :String = JDouble::toString(3.14)\n</code></pre>"},{"location":"reference/stdlib/#jboolean","title":"JBoolean","text":"<p>Boolean operations:</p> <pre><code>def b :Boolean = JBoolean::parseBoolean(\"true\")\ndef s :String = JBoolean::toString(true)\n</code></pre>"},{"location":"reference/stdlib/#common-java-classes","title":"Common Java Classes","text":"<p>Frequently used Java standard library classes.</p>"},{"location":"reference/stdlib/#string","title":"String","text":"<p>String operations (automatically available):</p> <pre><code>def text :String = \"Hello, World!\"\ndef upper :String = text.toUpperCase()\ndef lower :String = text.toLowerCase()\ndef length :Int = text.length()\ndef sub :String = text.substring(0, 5)\ndef contains :Boolean = text.contains(\"World\")\ndef starts :Boolean = text.startsWith(\"Hello\")\ndef ends :Boolean = text.endsWith(\"!\")\n</code></pre>"},{"location":"reference/stdlib/#stringbuilder","title":"StringBuilder","text":"<p>Efficient string building:</p> <pre><code>import { java.lang.StringBuilder; }\n\ndef builder :StringBuilder = new StringBuilder()\nbuilder.append(\"Hello\")\nbuilder.append(\" \")\nbuilder.append(\"World\")\ndef result :String = builder.toString()\n</code></pre>"},{"location":"reference/stdlib/#arraylist","title":"ArrayList","text":"<p>Dynamic arrays:</p> <pre><code>import { java.util.ArrayList; }\n\ndef list :ArrayList = new ArrayList\nlist.add(\"First\")\nlist &lt;&lt; \"Second\"  // Using &lt;&lt; operator\ndef size :Int = list.size()\ndef item :Object = list.get(0)\nlist.remove(0)\ndef empty :Boolean = list.isEmpty()\n</code></pre>"},{"location":"reference/stdlib/#hashmap","title":"HashMap","text":"<p>Key-value maps:</p> <pre><code>import { java.util.HashMap; }\n\ndef map :HashMap = new HashMap\nmap.put(\"key1\", \"value1\")\nmap.put(\"key2\", \"value2\")\ndef value :Object = map.get(\"key1\")\ndef has :Boolean = map.containsKey(\"key1\")\ndef size :Int = map.size()\n</code></pre>"},{"location":"reference/stdlib/#file","title":"File","text":"<p>File operations:</p> <pre><code>import { java.io.File; }\n\ndef file :File = new File(\"data.txt\")\ndef exists :Boolean = file.exists()\ndef isFile :Boolean = file.isFile()\ndef isDir :Boolean = file.isDirectory()\ndef name :String = file.getName()\ndef path :String = file.getPath()\ndef length :Long = file.length()\n</code></pre>"},{"location":"reference/stdlib/#bufferedreader","title":"BufferedReader","text":"<p>Reading text:</p> <pre><code>import {\n  java.io.BufferedReader;\n  java.io.FileReader;\n}\n\ndef reader :BufferedReader = new BufferedReader(\n  new FileReader(\"file.txt\")\n)\n\ndef line :String = null\nwhile (line = reader.readLine()) != null {\n  IO::println(line)\n}\n\nreader.close()\n</code></pre>"},{"location":"reference/stdlib/#bufferedwriter","title":"BufferedWriter","text":"<p>Writing text:</p> <pre><code>import {\n  java.io.BufferedWriter;\n  java.io.FileWriter;\n}\n\ndef writer :BufferedWriter = new BufferedWriter(\n  new FileWriter(\"output.txt\")\n)\n\nwriter.write(\"Hello, World!\")\nwriter.newLine()\nwriter.close()\n</code></pre>"},{"location":"reference/stdlib/#iterables-module","title":"Iterables Module","text":"<p>Provided via <code>onion.Iterables</code> (Java interface).</p> <p>Access iteration utilities for collections and arrays.</p>"},{"location":"reference/stdlib/#next-steps","title":"Next Steps","text":"<ul> <li>Language Specification - Formal language spec</li> <li>Compiler Architecture - Compiler internals</li> <li>Java Interoperability - Using Java libraries</li> </ul>"},{"location":"tools/compiler/","title":"Compiler (onionc)","text":"<p>The <code>onionc</code> command compiles Onion source files into JVM class files.</p>"},{"location":"tools/compiler/#usage","title":"Usage","text":"<pre><code>onionc [options] source files...\n</code></pre>"},{"location":"tools/compiler/#options","title":"Options","text":""},{"location":"tools/compiler/#-classpath-classpath","title":"<code>-classpath &lt;classpath&gt;</code>","text":"<p>Set the classpath for compilation. Used when your code references external Java libraries or other compiled Onion classes.</p> <pre><code>onionc -classpath lib/mylib.jar:lib/other.jar MyProgram.on\n</code></pre>"},{"location":"tools/compiler/#-encoding-encoding","title":"<code>-encoding &lt;encoding&gt;</code>","text":"<p>Specify the character encoding of source files. Default is platform-dependent.</p> <pre><code>onionc -encoding UTF-8 MyProgram.on\n</code></pre>"},{"location":"tools/compiler/#-d-output-directory","title":"<code>-d &lt;output directory&gt;</code>","text":"<p>Set the output directory for generated class files. If not specified, classes are written to the current directory.</p> <pre><code>onionc -d build/classes MyProgram.on\n</code></pre> <p>Class files are organized by module name: - Unix-like: <code>org/onion_lang/MyClass.class</code> - Windows: <code>org\\onion_lang\\MyClass.class</code></p>"},{"location":"tools/compiler/#-maxerrorreports-count","title":"<code>-maxErrorReports &lt;count&gt;</code>","text":"<p>Limit the number of compilation errors reported. Useful for large projects with many errors.</p> <pre><code>onionc -maxErrorReports 10 MyProgram.on\n</code></pre>"},{"location":"tools/compiler/#examples","title":"Examples","text":""},{"location":"tools/compiler/#basic-compilation","title":"Basic Compilation","text":"<p>Compile a single file:</p> <pre><code>onionc Hello.on\n</code></pre> <p>This creates <code>Hello.class</code> in the current directory.</p>"},{"location":"tools/compiler/#multiple-files","title":"Multiple Files","text":"<p>Compile multiple source files:</p> <pre><code>onionc Person.on Employee.on Manager.on\n</code></pre>"},{"location":"tools/compiler/#with-output-directory","title":"With Output Directory","text":"<p>Organize output:</p> <pre><code>onionc -d out/classes src/Main.on src/Utils.on\n</code></pre> <p>Class files appear in <code>out/classes/</code>.</p>"},{"location":"tools/compiler/#with-classpath","title":"With Classpath","text":"<p>Reference external libraries:</p> <pre><code>onionc -classpath lib/gson-2.8.jar:lib/commons-lang.jar \\\n       src/JsonParser.on\n</code></pre>"},{"location":"tools/compiler/#complete-example","title":"Complete Example","text":"<pre><code>onionc \\\n  -d build/classes \\\n  -classpath lib/external.jar \\\n  -encoding UTF-8 \\\n  -maxErrorReports 20 \\\n  src/*.on\n</code></pre>"},{"location":"tools/compiler/#running-compiled-programs","title":"Running Compiled Programs","text":"<p>After compilation, run with Java:</p> <pre><code># Compile\nonionc -d build Main.on\n\n# Run with Java\njava -cp build Main\n</code></pre> <p>Or with a JAR:</p> <pre><code># Compile\nonionc -d build Main.on Helper.on\n\n# Create JAR\njar cvfe program.jar Main -C build .\n\n# Run JAR\njava -jar program.jar\n</code></pre>"},{"location":"tools/compiler/#module-organization","title":"Module Organization","text":"<p>Onion uses module names (packages) similar to Java:</p> <p>MyClass.on: <pre><code>module com.example.myapp\n\nclass MyClass {\n  public:\n    static def main(args :String[]) {\n      IO::println(\"Hello\")\n    }\n}\n</code></pre></p> <p>Compile: <pre><code>onionc -d build MyClass.on\n</code></pre></p> <p>Output: <pre><code>build/com/example/myapp/MyClass.class\n</code></pre></p> <p>Run: <pre><code>java -cp build com.example.myapp.MyClass\n</code></pre></p>"},{"location":"tools/compiler/#compilation-errors","title":"Compilation Errors","text":""},{"location":"tools/compiler/#common-errors","title":"Common Errors","text":"<p>Type mismatch: <pre><code>Error: Type mismatch\n  Expected: Int\n  Found: String\n  at MyProgram.on:10\n</code></pre></p> <p>Undefined variable: <pre><code>Error: Undefined variable 'count'\n  at MyProgram.on:15\n</code></pre></p> <p>Method not found: <pre><code>Error: Method 'getValue()' not found in class Person\n  at MyProgram.on:23\n</code></pre></p>"},{"location":"tools/compiler/#incremental-compilation","title":"Incremental Compilation","text":"<p><code>onionc</code> compiles all specified files each time. For large projects, consider:</p> <ol> <li>Compile only changed files</li> <li>Use a build tool (Make, SBT, Gradle)</li> <li>Organize code into modules</li> </ol>"},{"location":"tools/compiler/#build-integration","title":"Build Integration","text":""},{"location":"tools/compiler/#makefile-example","title":"Makefile Example","text":"<pre><code>SRC_DIR = src\nOUT_DIR = build/classes\nSOURCES = $(wildcard $(SRC_DIR)/*.on)\n\nall: compile\n\ncompile:\n    mkdir -p $(OUT_DIR)\n    onionc -d $(OUT_DIR) $(SOURCES)\n\nclean:\n    rm -rf $(OUT_DIR)\n\nrun: compile\n    java -cp $(OUT_DIR) Main\n</code></pre>"},{"location":"tools/compiler/#shell-script-example","title":"Shell Script Example","text":"<pre><code>#!/bin/bash\n\nSRC_DIR=\"src\"\nOUT_DIR=\"build/classes\"\nCLASSPATH=\"lib/*\"\n\nmkdir -p \"$OUT_DIR\"\n\necho \"Compiling Onion sources...\"\nonionc -d \"$OUT_DIR\" -classpath \"$CLASSPATH\" \"$SRC_DIR\"/*.on\n\nif [ $? -eq 0 ]; then\n    echo \"Compilation successful\"\n    echo \"Running program...\"\n    java -cp \"$OUT_DIR:$CLASSPATH\" Main\nelse\n    echo \"Compilation failed\"\n    exit 1\nfi\n</code></pre>"},{"location":"tools/compiler/#compiler-output","title":"Compiler Output","text":""},{"location":"tools/compiler/#successful-compilation","title":"Successful Compilation","text":"<p>No output typically means success:</p> <pre><code>$ onionc Hello.on\n$ ls\nHello.class  Hello.on\n</code></pre>"},{"location":"tools/compiler/#compilation-errors_1","title":"Compilation Errors","text":"<p>Errors are written to standard error:</p> <pre><code>$ onionc BadProgram.on\nError: Type mismatch at BadProgram.on:5\nError: Undefined variable at BadProgram.on:10\nCompilation failed with 2 errors\n</code></pre>"},{"location":"tools/compiler/#next-steps","title":"Next Steps","text":"<ul> <li>Script Runner - Run Onion scripts directly</li> <li>REPL Shell - Interactive programming</li> <li>Building from Source - Build the compiler</li> </ul>"},{"location":"tools/repl/","title":"REPL Shell","text":"<p>The Onion REPL (Read-Eval-Print Loop) provides an interactive environment for experimenting with Onion code.</p>"},{"location":"tools/repl/#starting-the-repl","title":"Starting the REPL","text":"<p>Launch the interactive shell:</p> <pre><code># Using SBT (for development)\nsbt\n&gt; runMain onion.tools.Shell\n\n# Or if you have the onion-shell command\nonion-shell\n</code></pre>"},{"location":"tools/repl/#basic-usage","title":"Basic Usage","text":""},{"location":"tools/repl/#simple-expressions","title":"Simple Expressions","text":"<pre><code>onion&gt; 2 + 2\n4\n\nonion&gt; \"Hello\" + \" \" + \"World\"\nHello World\n\nonion&gt; 10 * 5\n50\n</code></pre>"},{"location":"tools/repl/#variable-definitions","title":"Variable Definitions","text":"<pre><code>onion&gt; def x :Int = 42\nx: Int = 42\n\nonion&gt; def name :String = \"Alice\"\nname: String = Alice\n\nonion&gt; IO::println(name)\nAlice\n</code></pre>"},{"location":"tools/repl/#function-calls","title":"Function Calls","text":"<pre><code>onion&gt; Math::sqrt(16.0)\n4.0\n\nonion&gt; \"hello\".toUpperCase()\nHELLO\n\nonion&gt; Math::max(10, 20)\n20\n</code></pre>"},{"location":"tools/repl/#defining-functions","title":"Defining Functions","text":"<pre><code>onion&gt; def square(x :Int) :Int { x * x }\nsquare: (Int) =&gt; Int\n\nonion&gt; square(5)\n25\n\nonion&gt; def greet(name :String) :String { \"Hello, \" + name }\ngreet: (String) =&gt; String\n\nonion&gt; greet(\"World\")\nHello, World\n</code></pre>"},{"location":"tools/repl/#working-with-classes","title":"Working with Classes","text":""},{"location":"tools/repl/#import-classes","title":"Import Classes","text":"<pre><code>onion&gt; import { java.util.ArrayList; }\n\nonion&gt; def list :ArrayList = new ArrayList\nlist: ArrayList = []\n\nonion&gt; list.add(\"First\")\ntrue\n\nonion&gt; list.add(\"Second\")\ntrue\n\nonion&gt; list.size()\n2\n</code></pre>"},{"location":"tools/repl/#define-classes","title":"Define Classes","text":"<pre><code>onion&gt; class Point {\n         @x :Int\n         @y :Int\n         public:\n           def new(x :Int, y :Int) {\n             @x = x\n             @y = y\n           }\n           def distance :Double {\n             Math::sqrt(@x * @x + @y * @y)\n           }\n       }\n\nonion&gt; def p :Point = new Point(3, 4)\np: Point = Point@1a2b3c4d\n\nonion&gt; p.distance()\n5.0\n</code></pre>"},{"location":"tools/repl/#lambda-expressions","title":"Lambda Expressions","text":"<pre><code>onion&gt; def double = #(x :Int) { x * 2 }\ndouble: Function1\n\nonion&gt; double.call(5)\n10\n\nonion&gt; def add = #(a :Int, b :Int) { a + b }\nadd: Function2\n\nonion&gt; add.call(3, 7)\n10\n</code></pre>"},{"location":"tools/repl/#multi-line-input","title":"Multi-line Input","text":"<p>For complex expressions, use multiple lines:</p> <pre><code>onion&gt; def factorial(n :Int) :Int {\n         if n &lt;= 1 {\n           1\n         } else {\n           n * factorial(n - 1)\n         }\n       }\n\nonion&gt; factorial(5)\n120\n</code></pre>"},{"location":"tools/repl/#viewing-previous-results","title":"Viewing Previous Results","text":"<p>The REPL stores results for quick reference:</p> <pre><code>onion&gt; 2 + 2\nres0: Int = 4\n\nonion&gt; res0 * 10\nres1: Int = 40\n\nonion&gt; res1 + res0\n44\n</code></pre>"},{"location":"tools/repl/#helpful-commands","title":"Helpful Commands","text":""},{"location":"tools/repl/#get-help","title":"Get Help","text":"<pre><code>onion&gt; :help\nAvailable commands:\n  :help    - Show this help message\n  :quit    - Exit the REPL\n  :reset   - Reset the session\n  :imports - Show current imports\n</code></pre>"},{"location":"tools/repl/#show-imports","title":"Show Imports","text":"<pre><code>onion&gt; :imports\nCurrent imports:\n  java.util.ArrayList\n  java.io.File\n</code></pre>"},{"location":"tools/repl/#exit-the-repl","title":"Exit the REPL","text":"<pre><code>onion&gt; :quit\nGoodbye!\n</code></pre> <p>Or use <code>Ctrl+D</code> (Unix) / <code>Ctrl+Z</code> (Windows).</p>"},{"location":"tools/repl/#practical-examples","title":"Practical Examples","text":""},{"location":"tools/repl/#quick-math","title":"Quick Math","text":"<pre><code>onion&gt; def hypotenuse(a :Double, b :Double) :Double {\n         Math::sqrt(a * a + b * b)\n       }\n\nonion&gt; hypotenuse(3.0, 4.0)\n5.0\n\nonion&gt; hypotenuse(5.0, 12.0)\n13.0\n</code></pre>"},{"location":"tools/repl/#string-manipulation","title":"String Manipulation","text":"<pre><code>onion&gt; def text :String = \"Hello, World!\"\nonion&gt; text.length()\n13\n\nonion&gt; text.toUpperCase()\nHELLO, WORLD!\n\nonion&gt; text.substring(0, 5)\nHello\n</code></pre>"},{"location":"tools/repl/#collections","title":"Collections","text":"<pre><code>onion&gt; import { java.util.ArrayList; }\n\nonion&gt; def numbers :ArrayList = new ArrayList\nonion&gt; numbers &lt;&lt; 10\nonion&gt; numbers &lt;&lt; 20\nonion&gt; numbers &lt;&lt; 30\n\nonion&gt; numbers.size()\n3\n\nonion&gt; numbers.get(1)\n20\n</code></pre>"},{"location":"tools/repl/#testing-code-snippets","title":"Testing Code Snippets","text":"<pre><code>onion&gt; def isPrime(n :Int) :Boolean {\n         if n &lt;= 1 {\n           return false\n         }\n         for i = 2; i * i &lt;= n; i = i + 1 {\n           if n % i == 0 {\n             return false\n           }\n         }\n         true\n       }\n\nonion&gt; isPrime(7)\ntrue\n\nonion&gt; isPrime(10)\nfalse\n\nonion&gt; isPrime(17)\ntrue\n</code></pre>"},{"location":"tools/repl/#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"tools/repl/#quick-prototyping","title":"Quick Prototyping","text":"<p>Use the REPL to test ideas before writing full programs:</p> <pre><code>onion&gt; // Test string formatting\nonion&gt; def format(name :String, age :Int) :String {\n         name + \" is \" + age + \" years old\"\n       }\n\nonion&gt; format(\"Alice\", 30)\nAlice is 30 years old\n</code></pre>"},{"location":"tools/repl/#debugging","title":"Debugging","text":"<p>Test individual functions:</p> <pre><code>onion&gt; def calculate(x :Int) :Int {\n         def temp :Int = x * 2\n         IO::println(\"temp = \" + temp)\n         temp + 10\n       }\n\nonion&gt; calculate(5)\ntemp = 10\n20\n</code></pre>"},{"location":"tools/repl/#learning","title":"Learning","text":"<p>Experiment with language features:</p> <pre><code>onion&gt; // Test type casting\nonion&gt; def x :Double = 3.14\nonion&gt; def y :Int = x$Int\nonion&gt; IO::println(y)\n3\n\nonion&gt; // Test closures\nonion&gt; def makeAdder(n :Int) {\n         #(x :Int) { x + n }\n       }\nonion&gt; def add5 = makeAdder(5)\nonion&gt; add5.call(10)\n15\n</code></pre>"},{"location":"tools/repl/#limitations","title":"Limitations","text":"<ul> <li>Session state is lost when you exit</li> <li>No command history persistence (use arrow keys during session)</li> <li>Limited debugging capabilities</li> <li>Performance not optimized for large computations</li> </ul>"},{"location":"tools/repl/#use-cases","title":"Use Cases","text":"<p>Perfect for: - Learning Onion syntax - Testing code snippets - Quick calculations - Prototyping functions - Exploring Java libraries</p> <p>Not ideal for: - Large programs - File I/O heavy tasks - Long-running processes - Production code</p>"},{"location":"tools/repl/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn more syntax</li> <li>Examples - See example programs</li> <li>Language Guide - Deep dive into features</li> </ul>"},{"location":"tools/script-runner/","title":"Script Runner (onion)","text":"<p>The <code>onion</code> command compiles and executes Onion source files directly in memory, without creating <code>.class</code> files.</p>"},{"location":"tools/script-runner/#usage","title":"Usage","text":"<pre><code>onion [options] source files... [program arguments]\n</code></pre>"},{"location":"tools/script-runner/#options","title":"Options","text":""},{"location":"tools/script-runner/#-classpath-classpath","title":"<code>-classpath &lt;classpath&gt;</code>","text":"<p>Set the classpath for compilation and execution.</p> <pre><code>onion -classpath lib/mylib.jar MyScript.on\n</code></pre>"},{"location":"tools/script-runner/#-encoding-encoding","title":"<code>-encoding &lt;encoding&gt;</code>","text":"<p>Specify the character encoding of source files.</p> <pre><code>onion -encoding UTF-8 MyScript.on\n</code></pre>"},{"location":"tools/script-runner/#-maxerrorreports-count","title":"<code>-maxErrorReports &lt;count&gt;</code>","text":"<p>Limit the number of compilation errors reported.</p> <pre><code>onion -maxErrorReports 10 MyScript.on\n</code></pre>"},{"location":"tools/script-runner/#program-arguments","title":"Program Arguments","text":"<p>Arguments after the source file(s) are passed to your program:</p> <pre><code>onion MyScript.on arg1 arg2 arg3\n</code></pre> <p>Access them in your code:</p> <pre><code>class MyScript {\n  public:\n    static def main(args :String[]) {\n      foreach arg :String in args {\n        IO::println(\"Argument: \" + arg)\n      }\n    }\n}\n</code></pre>"},{"location":"tools/script-runner/#entry-point","title":"Entry Point","text":"<p>The script runner determines the entry point automatically:</p>"},{"location":"tools/script-runner/#1-explicit-main-method","title":"1. Explicit Main Method","text":"<p>If a class has a <code>main</code> method, it's used as the entry point:</p> <pre><code>class MyProgram {\n  public:\n    static def main(args :String[]) {\n      IO::println(\"Hello from main method\")\n    }\n}\n</code></pre>"},{"location":"tools/script-runner/#2-first-class-with-main","title":"2. First Class with Main","text":"<p>If multiple classes have <code>main</code> methods, the first one is used:</p> <pre><code>class First {\n  public:\n    static def main(args :String[]) {\n      IO::println(\"This will run\")\n    }\n}\n\nclass Second {\n  public:\n    static def main(args :String[]) {\n      IO::println(\"This won't run\")\n    }\n}\n</code></pre>"},{"location":"tools/script-runner/#3-top-level-statements","title":"3. Top-Level Statements","text":"<p>If there's no explicit <code>main</code> method, the first top-level statement is the entry point:</p> <pre><code>IO::println(\"Hello, World!\")\n\ndef x :Int = 10\nIO::println(\"x = \" + x)\n\n// These statements execute immediately\n</code></pre>"},{"location":"tools/script-runner/#examples","title":"Examples","text":""},{"location":"tools/script-runner/#simple-script","title":"Simple Script","text":"<p>hello.on: <pre><code>IO::println(\"Hello, World!\")\n</code></pre></p> <p>Run: <pre><code>$ onion hello.on\nHello, World!\n</code></pre></p>"},{"location":"tools/script-runner/#with-arguments","title":"With Arguments","text":"<p>greet.on: <pre><code>class Greeter {\n  public:\n    static def main(args :String[]) {\n      if args.length &gt; 0 {\n        IO::println(\"Hello, \" + args[0] + \"!\")\n      } else {\n        IO::println(\"Hello, stranger!\")\n      }\n    }\n}\n</code></pre></p> <p>Run: <pre><code>$ onion greet.on Alice\nHello, Alice!\n\n$ onion greet.on\nHello, stranger!\n</code></pre></p>"},{"location":"tools/script-runner/#quick-calculations","title":"Quick Calculations","text":"<p>calc.on: <pre><code>def a :Int = 10\ndef b :Int = 20\nIO::println(\"Sum: \" + (a + b))\nIO::println(\"Product: \" + (a * b))\n</code></pre></p> <p>Run: <pre><code>$ onion calc.on\nSum: 30\nProduct: 200\n</code></pre></p>"},{"location":"tools/script-runner/#file-processing","title":"File Processing","text":"<p>count_lines.on: <pre><code>import {\n  java.io.BufferedReader;\n  java.io.FileReader;\n}\n\nclass LineCounter {\n  public:\n    static def main(args :String[]) {\n      if args.length == 0 {\n        IO::println(\"Usage: onion count_lines.on &lt;filename&gt;\")\n        return\n      }\n\n      def filename :String = args[0]\n      def reader :BufferedReader = new BufferedReader(\n        new FileReader(filename)\n      )\n\n      def count :Int = 0\n      def line :String = null\n      while (line = reader.readLine()) != null {\n        count = count + 1\n      }\n\n      reader.close()\n      IO::println(\"Lines: \" + count)\n    }\n}\n</code></pre></p> <p>Run: <pre><code>$ onion count_lines.on data.txt\nLines: 42\n</code></pre></p>"},{"location":"tools/script-runner/#in-memory-compilation","title":"In-Memory Compilation","text":"<p>The <code>onion</code> command:</p> <ol> <li>Compiles source files to bytecode</li> <li>Loads classes into memory</li> <li>Executes the entry point</li> <li>No <code>.class</code> files are created</li> </ol> <p>This is ideal for: - Quick scripts - Testing code snippets - Automation tasks - One-off programs</p>"},{"location":"tools/script-runner/#multiple-source-files","title":"Multiple Source Files","text":"<p>Compile and run multiple files:</p> <pre><code>onion Main.on Utils.on Helper.on\n</code></pre> <p>All files are compiled together, and the entry point is determined from the first file.</p>"},{"location":"tools/script-runner/#error-handling","title":"Error Handling","text":""},{"location":"tools/script-runner/#compilation-errors","title":"Compilation Errors","text":"<pre><code>$ onion bad_syntax.on\nError: Type mismatch at bad_syntax.on:5\nCompilation failed\n</code></pre>"},{"location":"tools/script-runner/#runtime-errors","title":"Runtime Errors","text":"<pre><code>$ onion runtime_error.on\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n    at RuntimeError.main(runtime_error.on:10)\n</code></pre>"},{"location":"tools/script-runner/#comparison-with-onionc","title":"Comparison with onionc","text":"Feature onion onionc Creates .class files No Yes Execution Immediate Requires <code>java</code> command Use case Scripts, testing Production, libraries Speed Fast for small programs Better for repeated runs Distribution Requires source Can distribute .class/.jar"},{"location":"tools/script-runner/#scripting-best-practices","title":"Scripting Best Practices","text":""},{"location":"tools/script-runner/#shebang-line-unix-like-systems","title":"Shebang Line (Unix-like systems)","text":"<p>Make scripts executable:</p> <p>hello.on: <pre><code>#!/usr/bin/env onion\nIO::println(\"Hello from script!\")\n</code></pre></p> <p>Make executable: <pre><code>chmod +x hello.on\n./hello.on\n</code></pre></p>"},{"location":"tools/script-runner/#error-messages","title":"Error Messages","text":"<p>Provide helpful error messages:</p> <pre><code>class Script {\n  public:\n    static def main(args :String[]) {\n      if args.length &lt; 2 {\n        IO::println(\"Error: Missing arguments\")\n        IO::println(\"Usage: onion script.on &lt;input&gt; &lt;output&gt;\")\n        return\n      }\n\n      // Process arguments...\n    }\n}\n</code></pre>"},{"location":"tools/script-runner/#exit-codes","title":"Exit Codes","text":"<p>Return appropriate exit codes:</p> <pre><code>class Script {\n  public:\n    static def main(args :String[]) {\n      if args.length == 0 {\n        System::exit(1)  // Error\n      }\n\n      // Success\n      System::exit(0)\n    }\n}\n</code></pre>"},{"location":"tools/script-runner/#next-steps","title":"Next Steps","text":"<ul> <li>Compiler (onionc) - Compile to class files</li> <li>REPL Shell - Interactive programming</li> <li>Examples - Example scripts</li> </ul>"}]}